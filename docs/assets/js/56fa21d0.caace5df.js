"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[82602],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>c});var s=n(96540);const a={},r=s.createContext(a);function i(e){const t=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:t},e.children)}},55698:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"rfc-015","title":"Plugin Acceptance Test Framework (Interface-Based Testing)","description":"Abstract","source":"@site/../docs-cms/rfcs/rfc-015-plugin-acceptance-test-framework.md","sourceDirName":".","slug":"/rfc-015","permalink":"/prism-data-layer/rfc/rfc-015","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/rfcs/rfc-015-plugin-acceptance-test-framework.md","tags":[{"inline":true,"label":"testing","permalink":"/prism-data-layer/rfc/tags/testing"},{"inline":true,"label":"plugins","permalink":"/prism-data-layer/rfc/tags/plugins"},{"inline":true,"label":"interfaces","permalink":"/prism-data-layer/rfc/tags/interfaces"},{"inline":true,"label":"acceptance","permalink":"/prism-data-layer/rfc/tags/acceptance"},{"inline":true,"label":"quality-assurance","permalink":"/prism-data-layer/rfc/tags/quality-assurance"}],"version":"current","frontMatter":{"author":"Platform Team","created":"2025-10-09T00:00:00.000Z","date":"2025-10-09T00:00:00.000Z","doc_uuid":"33768d6a-c62f-41b1-ba6c-dd94831cba81","id":"rfc-015","project_id":"prism-data-layer","status":"Proposed","tags":["testing","plugins","interfaces","acceptance","quality-assurance"],"title":"Plugin Acceptance Test Framework (Interface-Based Testing)","updated":"2025-10-09T00:00:00.000Z"},"sidebar":"rfcSidebar","previous":{"title":"Layered Data Access Patterns \u2022 RFC-014","permalink":"/prism-data-layer/rfc/rfc-014"},"next":{"title":"Local Development Infrastructure \u2022 RFC-016","permalink":"/prism-data-layer/rfc/rfc-016"}}');var a=n(74848),r=n(28453);const i={author:"Platform Team",created:new Date("2025-10-09T00:00:00.000Z"),date:new Date("2025-10-09T00:00:00.000Z"),doc_uuid:"33768d6a-c62f-41b1-ba6c-dd94831cba81",id:"rfc-015",project_id:"prism-data-layer",status:"Proposed",tags:["testing","plugins","interfaces","acceptance","quality-assurance"],title:"Plugin Acceptance Test Framework (Interface-Based Testing)",updated:new Date("2025-10-09T00:00:00.000Z")},c="RFC-015: Plugin Acceptance Test Framework (Interface-Based Testing)",l={},o=[{value:"Abstract",id:"abstract",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Problem Statement",id:"problem-statement",level:3},{value:"Goals",id:"goals",level:3},{value:"Non-Goals",id:"non-goals",level:3},{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Interface-Based Test Structure",id:"interface-based-test-structure",level:3},{value:"Test Execution Flow",id:"test-execution-flow",level:3},{value:"Interface Compliance Test Suites",id:"interface-compliance-test-suites",level:2},{value:"Example: KeyValue Basic Interface",id:"example-keyvalue-basic-interface",level:3},{value:"Example: KeyValue Scan Interface",id:"example-keyvalue-scan-interface",level:3},{value:"Backend Interface Registry",id:"backend-interface-registry",level:2},{value:"Registry Loading",id:"registry-loading",level:3},{value:"Compliance Matrix Test",id:"compliance-matrix-test",level:2},{value:"CI/CD Integration",id:"cicd-integration",level:2},{value:"GitHub Actions Workflow",id:"github-actions-workflow",level:3},{value:"Benefits",id:"benefits",level:2},{value:"1. Interface Compliance Verification",id:"1-interface-compliance-verification",level:3},{value:"2. Cross-Backend Test Reuse",id:"2-cross-backend-test-reuse",level:3},{value:"3. Clear Contract Definition",id:"3-clear-contract-definition",level:3},{value:"4. Incremental Implementation",id:"4-incremental-implementation",level:3},{value:"5. Registry-Driven Testing",id:"5-registry-driven-testing",level:3},{value:"Running Tests Locally",id:"running-tests-locally",level:2},{value:"Makefile Targets",id:"makefile-targets",level:3},{value:"Test Output Example",id:"test-output-example",level:2},{value:"Compliance Matrix Summary",id:"compliance-matrix-summary",level:3},{value:"Future Enhancements",id:"future-enhancements",level:2},{value:"Phase 1: Complete Interface Coverage (Q1 2026)",id:"phase-1-complete-interface-coverage-q1-2026",level:3},{value:"Phase 2: Performance Baseline Tests (Q2 2026)",id:"phase-2-performance-baseline-tests-q2-2026",level:3},{value:"Phase 3: Chaos Testing (Q3 2026)",id:"phase-3-chaos-testing-q3-2026",level:3},{value:"Related Documents",id:"related-documents",level:2},{value:"Revision History",id:"revision-history",level:2}];function u(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"rfc-015-plugin-acceptance-test-framework-interface-based-testing",children:"RFC-015: Plugin Acceptance Test Framework (Interface-Based Testing)"})}),"\n",(0,a.jsx)(t.h2,{id:"abstract",children:"Abstract"}),"\n",(0,a.jsxs)(t.p,{children:["This RFC defines a comprehensive ",(0,a.jsx)(t.strong,{children:"acceptance test framework"})," for Prism backend plugins based on ",(0,a.jsx)(t.strong,{children:"interface compliance"})," rather than backend types. Following MEMO-006's interface decomposition principles, the framework tests plugins against the thin, composable interfaces they claim to implement (e.g., ",(0,a.jsx)(t.code,{children:"keyvalue_basic"}),", ",(0,a.jsx)(t.code,{children:"pubsub_persistent"}),", ",(0,a.jsx)(t.code,{children:"stream_consumer_groups"}),") rather than treating backends as monolithic units."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Key Innovation"}),": Backends declare which interfaces they implement in ",(0,a.jsx)(t.code,{children:"registry/backends/*.yaml"}),". Tests verify each interface independently, enabling fine-grained validation and clear contracts."]}),"\n",(0,a.jsx)(t.p,{children:"The framework provides:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Interface Compliance Test Suites"}),": Reusable tests for each of the 45 backend interfaces"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Backend Verification Matrix"}),": Automated validation that backends implement their declared interfaces"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Test Harness with testcontainers"}),": Real backend instances for integration testing"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"CI/CD Integration"}),": Interface compliance checked on every commit"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"motivation",children:"Motivation"}),"\n",(0,a.jsx)(t.h3,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,a.jsx)(t.p,{children:"MEMO-006 decomposes backends into thin interfaces (e.g., Redis implements 16 interfaces across 6 data models), but without interface-level testing, we can't verify compliance:"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Current Approach (Backend-Type Testing)"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-go",children:"func TestPostgresPlugin(t *testing.T) {\n    // Tests all PostgreSQL features mixed together\n    testInsert(t)        // keyvalue_basic\n    testJSONTypes(t)     // document_basic\n    testTransactions(t)  // keyvalue_transactional\n    testListenNotify(t)  // pubsub_basic (LISTEN/NOTIFY)\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Problems"}),":"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Monolithic tests obscure which interface is being tested"}),"\n",(0,a.jsxs)(t.li,{children:["Can't reuse tests across backends (PostgreSQL and Redis both implement ",(0,a.jsx)(t.code,{children:"keyvalue_basic"})," but have separate test suites)"]}),"\n",(0,a.jsx)(t.li,{children:"No clear mapping between test failures and interface violations"}),"\n",(0,a.jsx)(t.li,{children:"Hard to verify partial interface implementations"}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"MEMO-006 Approach (Interface-Based Testing)"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-go",children:'// Test keyvalue_basic interface (works for ANY backend implementing it)\nfunc TestKeyValueBasicInterface(t *testing.T, backend TestBackend) {\n    // Tests ONLY keyvalue_basic operations\n    testSet(t, backend)\n    testGet(t, backend)\n    testDelete(t, backend)\n    testExists(t, backend)\n}\n\n// Run for all backends implementing keyvalue_basic\nfor backend := range FindBackendsImplementing("keyvalue_basic") {\n    t.Run(backend.Name, func(t *testing.T) {\n        TestKeyValueBasicInterface(t, backend)\n    })\n}\n'})}),"\n",(0,a.jsx)(t.h3,{id:"goals",children:"Goals"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Interface Compliance"}),": Test each interface independently (45 interface test suites)"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Cross-Backend Reuse"}),": Same test suite verifies Redis, PostgreSQL, DynamoDB for ",(0,a.jsx)(t.code,{children:"keyvalue_basic"})]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Explicit Contracts"}),": Interface tests define the exact behavior backends must implement"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Registry-Driven"}),": Backends declare interfaces in ",(0,a.jsx)(t.code,{children:"registry/backends/*.yaml"}),", tests verify claims"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Incremental Implementation"}),": Backends can implement subsets of interfaces (MemStore implements 6, Redis implements 16)"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"CI/CD Ready"}),": Automated interface compliance matrix on every commit"]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"non-goals",children:"Non-Goals"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Not load testing"}),": Performance benchmarks are separate (covered in other RFCs)"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Not pattern testing"}),": Pattern composition tested separately (RFC-014)"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Not end-to-end testing"}),": Focus on plugin-backend interface compliance only"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,a.jsx)(t.h3,{id:"interface-based-test-structure",children:"Interface-Based Test Structure"}),"\n",(0,a.jsx)(t.p,{children:"Following MEMO-006's 45 interface catalog, the framework provides test suites for each interface:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-text",children:"tests/acceptance/\n\u251c\u2500\u2500 harness/\n\u2502   \u251c\u2500\u2500 plugin_harness.go         # Plugin lifecycle management\n\u2502   \u251c\u2500\u2500 backend_manager.go        # testcontainers integration\n\u2502   \u2514\u2500\u2500 interface_registry.go     # Load backend interface declarations\n\u2502\n\u251c\u2500\u2500 interfaces/                    # Interface compliance test suites\n\u2502   \u251c\u2500\u2500 keyvalue/\n\u2502   \u2502   \u251c\u2500\u2500 keyvalue_basic_test.go        # Test keyvalue_basic interface\n\u2502   \u2502   \u251c\u2500\u2500 keyvalue_scan_test.go         # Test keyvalue_scan interface\n\u2502   \u2502   \u251c\u2500\u2500 keyvalue_ttl_test.go          # Test keyvalue_ttl interface\n\u2502   \u2502   \u251c\u2500\u2500 keyvalue_transactional_test.go\n\u2502   \u2502   \u251c\u2500\u2500 keyvalue_batch_test.go\n\u2502   \u2502   \u2514\u2500\u2500 keyvalue_cas_test.go\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 pubsub/\n\u2502   \u2502   \u251c\u2500\u2500 pubsub_basic_test.go          # Test pubsub_basic interface\n\u2502   \u2502   \u251c\u2500\u2500 pubsub_wildcards_test.go      # Test pubsub_wildcards interface\n\u2502   \u2502   \u251c\u2500\u2500 pubsub_persistent_test.go     # Test pubsub_persistent interface\n\u2502   \u2502   \u251c\u2500\u2500 pubsub_filtering_test.go\n\u2502   \u2502   \u2514\u2500\u2500 pubsub_ordering_test.go\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 stream/\n\u2502   \u2502   \u251c\u2500\u2500 stream_basic_test.go\n\u2502   \u2502   \u251c\u2500\u2500 stream_consumer_groups_test.go\n\u2502   \u2502   \u251c\u2500\u2500 stream_replay_test.go\n\u2502   \u2502   \u251c\u2500\u2500 stream_retention_test.go\n\u2502   \u2502   \u2514\u2500\u2500 stream_partitioning_test.go\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 queue/\n\u2502   \u2502   \u251c\u2500\u2500 queue_basic_test.go\n\u2502   \u2502   \u251c\u2500\u2500 queue_visibility_test.go\n\u2502   \u2502   \u251c\u2500\u2500 queue_dead_letter_test.go\n\u2502   \u2502   \u251c\u2500\u2500 queue_priority_test.go\n\u2502   \u2502   \u2514\u2500\u2500 queue_delayed_test.go\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 list/\n\u2502   \u2502   \u251c\u2500\u2500 list_basic_test.go\n\u2502   \u2502   \u251c\u2500\u2500 list_indexing_test.go\n\u2502   \u2502   \u251c\u2500\u2500 list_range_test.go\n\u2502   \u2502   \u2514\u2500\u2500 list_blocking_test.go\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 set/\n\u2502   \u2502   \u251c\u2500\u2500 set_basic_test.go\n\u2502   \u2502   \u251c\u2500\u2500 set_operations_test.go\n\u2502   \u2502   \u251c\u2500\u2500 set_cardinality_test.go\n\u2502   \u2502   \u2514\u2500\u2500 set_random_test.go\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 sortedset/\n\u2502   \u2502   \u251c\u2500\u2500 sortedset_basic_test.go\n\u2502   \u2502   \u251c\u2500\u2500 sortedset_range_test.go\n\u2502   \u2502   \u251c\u2500\u2500 sortedset_rank_test.go\n\u2502   \u2502   \u251c\u2500\u2500 sortedset_operations_test.go\n\u2502   \u2502   \u2514\u2500\u2500 sortedset_lex_test.go\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 timeseries/\n\u2502   \u2502   \u251c\u2500\u2500 timeseries_basic_test.go\n\u2502   \u2502   \u251c\u2500\u2500 timeseries_aggregation_test.go\n\u2502   \u2502   \u251c\u2500\u2500 timeseries_retention_test.go\n\u2502   \u2502   \u2514\u2500\u2500 timeseries_interpolation_test.go\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 graph/\n\u2502   \u2502   \u251c\u2500\u2500 graph_basic_test.go\n\u2502   \u2502   \u251c\u2500\u2500 graph_traversal_test.go\n\u2502   \u2502   \u251c\u2500\u2500 graph_query_test.go\n\u2502   \u2502   \u2514\u2500\u2500 graph_analytics_test.go\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 document/\n\u2502       \u251c\u2500\u2500 document_basic_test.go\n\u2502       \u251c\u2500\u2500 document_query_test.go\n\u2502       \u2514\u2500\u2500 document_indexing_test.go\n\u2502\n\u251c\u2500\u2500 instances/                     # Backend testcontainers\n\u2502   \u251c\u2500\u2500 redis_instance.go\n\u2502   \u251c\u2500\u2500 postgres_instance.go\n\u2502   \u251c\u2500\u2500 kafka_instance.go\n\u2502   \u251c\u2500\u2500 memstore_instance.go\n\u2502   \u2514\u2500\u2500 backend_interface.go       # Common interface\n\u2502\n\u2514\u2500\u2500 matrix/\n    \u251c\u2500\u2500 compliance_matrix_test.go  # Run interface tests for all backends\n    \u2514\u2500\u2500 registry_validator_test.go # Verify backend registry declarations\n"})}),"\n",(0,a.jsx)(t.h3,{id:"test-execution-flow",children:"Test Execution Flow"}),"\n",(0,a.jsx)(t.mermaid,{value:'sequenceDiagram\n    participant Registry as Backend Registry\n    participant Matrix as Compliance Matrix\n    participant Harness as Test Harness\n    participant Backend as Backend Instance\n    participant Test as Interface Test Suite\n\n    Registry->>Matrix: Load registry/backends/redis.yaml\n    Registry->>Matrix: Redis claims: keyvalue_basic, keyvalue_scan, ...\n\n    Matrix->>Harness: Start Redis testcontainer\n    activate Harness\n    Harness->>Backend: docker run redis:7.2\n    Backend--\x3e>Harness: Container ready\n\n    Matrix->>Test: Run KeyValueBasicTest(redis)\n    Test->>Backend: Set("key1", "value1")\n    Backend--\x3e>Test: OK\n    Test->>Backend: Get("key1")\n    Backend--\x3e>Test: "value1"\n    Test->>Backend: Delete("key1")\n    Backend--\x3e>Test: OK\n    Test->>Backend: Exists("key1")\n    Backend--\x3e>Test: false\n    Test--\x3e>Matrix: \u2713 keyvalue_basic PASS\n\n    Matrix->>Test: Run KeyValueScanTest(redis)\n    Test->>Backend: Set("user:1", "alice")\n    Test->>Backend: Set("user:2", "bob")\n    Test->>Backend: Scan("user:")\n    Backend--\x3e>Test: ["user:1", "user:2"]\n    Test--\x3e>Matrix: \u2713 keyvalue_scan PASS\n\n    Matrix->>Harness: Stop Redis\n    Harness->>Backend: docker stop\n    deactivate Harness\n\n    Matrix->>Registry: \u2713 Redis implements all claimed interfaces'}),"\n",(0,a.jsx)(t.h2,{id:"interface-compliance-test-suites",children:"Interface Compliance Test Suites"}),"\n",(0,a.jsx)(t.h3,{id:"example-keyvalue-basic-interface",children:"Example: KeyValue Basic Interface"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-go",children:'// tests/acceptance/interfaces/keyvalue/keyvalue_basic_test.go\n\npackage keyvalue\n\nimport (\n\t"context"\n\t"testing"\n\n\t"github.com/prism/plugin-core/proto"\n\t"github.com/prism/tests/acceptance/harness"\n\t"github.com/stretchr/testify/assert"\n\t"github.com/stretchr/testify/require"\n)\n\n// KeyValueBasicTestSuite verifies keyvalue_basic interface compliance\ntype KeyValueBasicTestSuite struct {\n\tharness *harness.PluginHarness\n\tt       *testing.T\n}\n\n// NewKeyValueBasicTestSuite creates interface test suite\nfunc NewKeyValueBasicTestSuite(t *testing.T, h *harness.PluginHarness) *KeyValueBasicTestSuite {\n\treturn &KeyValueBasicTestSuite{\n\t\tharness: h,\n\t\tt:       t,\n\t}\n}\n\n// Run executes all keyvalue_basic interface tests\nfunc (s *KeyValueBasicTestSuite) Run() {\n\ts.t.Run("Set", s.testSet)\n\ts.t.Run("Get", s.testGet)\n\ts.t.Run("Delete", s.testDelete)\n\ts.t.Run("Exists", s.testExists)\n\ts.t.Run("SetGetDelete", s.testSetGetDelete)\n\ts.t.Run("GetNonExistent", s.testGetNonExistent)\n\ts.t.Run("DeleteNonExistent", s.testDeleteNonExistent)\n\ts.t.Run("ExistsNonExistent", s.testExistsNonExistent)\n\ts.t.Run("OverwriteValue", s.testOverwriteValue)\n\ts.t.Run("ConcurrentSets", s.testConcurrentSets)\n}\n\n// testSet verifies Set operation\nfunc (s *KeyValueBasicTestSuite) testSet() {\n\tctx := context.Background()\n\n\treq := &proto.KeyValueSetRequest{\n\t\tNamespace: "test",\n\t\tKey:       "test-key",\n\t\tValue:     []byte("test-value"),\n\t}\n\n\tresp, err := s.harness.Plugin.KeyValueSet(ctx, req)\n\trequire.NoError(s.t, err, "Set should succeed")\n\tassert.True(s.t, resp.Success, "Set response should indicate success")\n}\n\n// testGet verifies Get operation\nfunc (s *KeyValueBasicTestSuite) testGet() {\n\tctx := context.Background()\n\n\t// First, set a value\n\tsetReq := &proto.KeyValueSetRequest{\n\t\tNamespace: "test",\n\t\tKey:       "get-test-key",\n\t\tValue:     []byte("get-test-value"),\n\t}\n\t_, err := s.harness.Plugin.KeyValueSet(ctx, setReq)\n\trequire.NoError(s.t, err)\n\n\t// Then, get it back\n\tgetReq := &proto.KeyValueGetRequest{\n\t\tNamespace: "test",\n\t\tKey:       "get-test-key",\n\t}\n\tgetResp, err := s.harness.Plugin.KeyValueGet(ctx, getReq)\n\trequire.NoError(s.t, err, "Get should succeed")\n\tassert.Equal(s.t, []byte("get-test-value"), getResp.Value, "Value should match what was set")\n}\n\n// testDelete verifies Delete operation\nfunc (s *KeyValueBasicTestSuite) testDelete() {\n\tctx := context.Background()\n\n\t// Set a value\n\tsetReq := &proto.KeyValueSetRequest{\n\t\tNamespace: "test",\n\t\tKey:       "delete-test-key",\n\t\tValue:     []byte("delete-test-value"),\n\t}\n\t_, err := s.harness.Plugin.KeyValueSet(ctx, setReq)\n\trequire.NoError(s.t, err)\n\n\t// Delete it\n\tdelReq := &proto.KeyValueDeleteRequest{\n\t\tNamespace: "test",\n\t\tKey:       "delete-test-key",\n\t}\n\tdelResp, err := s.harness.Plugin.KeyValueDelete(ctx, delReq)\n\trequire.NoError(s.t, err, "Delete should succeed")\n\tassert.True(s.t, delResp.Found, "Delete should report key was found")\n}\n\n// testExists verifies Exists operation\nfunc (s *KeyValueBasicTestSuite) testExists() {\n\tctx := context.Background()\n\n\t// Set a value\n\tsetReq := &proto.KeyValueSetRequest{\n\t\tNamespace: "test",\n\t\tKey:       "exists-test-key",\n\t\tValue:     []byte("exists-test-value"),\n\t}\n\t_, err := s.harness.Plugin.KeyValueSet(ctx, setReq)\n\trequire.NoError(s.t, err)\n\n\t// Check existence\n\texistsReq := &proto.KeyValueExistsRequest{\n\t\tNamespace: "test",\n\t\tKey:       "exists-test-key",\n\t}\n\texistsResp, err := s.harness.Plugin.KeyValueExists(ctx, existsReq)\n\trequire.NoError(s.t, err, "Exists should succeed")\n\tassert.True(s.t, existsResp.Exists, "Key should exist")\n}\n\n// testSetGetDelete verifies full lifecycle\nfunc (s *KeyValueBasicTestSuite) testSetGetDelete() {\n\tctx := context.Background()\n\tkey := "lifecycle-key"\n\tvalue := []byte("lifecycle-value")\n\n\t// Set\n\tsetReq := &proto.KeyValueSetRequest{\n\t\tNamespace: "test",\n\t\tKey:       key,\n\t\tValue:     value,\n\t}\n\t_, err := s.harness.Plugin.KeyValueSet(ctx, setReq)\n\trequire.NoError(s.t, err)\n\n\t// Get\n\tgetReq := &proto.KeyValueGetRequest{\n\t\tNamespace: "test",\n\t\tKey:       key,\n\t}\n\tgetResp, err := s.harness.Plugin.KeyValueGet(ctx, getReq)\n\trequire.NoError(s.t, err)\n\tassert.Equal(s.t, value, getResp.Value)\n\n\t// Delete\n\tdelReq := &proto.KeyValueDeleteRequest{\n\t\tNamespace: "test",\n\t\tKey:       key,\n\t}\n\tdelResp, err := s.harness.Plugin.KeyValueDelete(ctx, delReq)\n\trequire.NoError(s.t, err)\n\tassert.True(s.t, delResp.Found)\n\n\t// Verify deleted\n\texistsReq := &proto.KeyValueExistsRequest{\n\t\tNamespace: "test",\n\t\tKey:       key,\n\t}\n\texistsResp, err := s.harness.Plugin.KeyValueExists(ctx, existsReq)\n\trequire.NoError(s.t, err)\n\tassert.False(s.t, existsResp.Exists, "Key should not exist after delete")\n}\n\n// testGetNonExistent verifies Get returns NotFound for missing keys\nfunc (s *KeyValueBasicTestSuite) testGetNonExistent() {\n\tctx := context.Background()\n\n\tgetReq := &proto.KeyValueGetRequest{\n\t\tNamespace: "test",\n\t\tKey:       "non-existent-key",\n\t}\n\n\t_, err := s.harness.Plugin.KeyValueGet(ctx, getReq)\n\tassert.Error(s.t, err, "Get on non-existent key should return error")\n\t// Should be gRPC NotFound status code\n}\n\n// testDeleteNonExistent verifies Delete returns Found=false for missing keys\nfunc (s *KeyValueBasicTestSuite) testDeleteNonExistent() {\n\tctx := context.Background()\n\n\tdelReq := &proto.KeyValueDeleteRequest{\n\t\tNamespace: "test",\n\t\tKey:       "non-existent-key",\n\t}\n\n\tdelResp, err := s.harness.Plugin.KeyValueDelete(ctx, delReq)\n\trequire.NoError(s.t, err, "Delete should not error on non-existent key")\n\tassert.False(s.t, delResp.Found, "Delete should report key was not found")\n}\n\n// testExistsNonExistent verifies Exists returns false for missing keys\nfunc (s *KeyValueBasicTestSuite) testExistsNonExistent() {\n\tctx := context.Background()\n\n\texistsReq := &proto.KeyValueExistsRequest{\n\t\tNamespace: "test",\n\t\tKey:       "non-existent-key",\n\t}\n\n\texistsResp, err := s.harness.Plugin.KeyValueExists(ctx, existsReq)\n\trequire.NoError(s.t, err, "Exists should not error on non-existent key")\n\tassert.False(s.t, existsResp.Exists, "Key should not exist")\n}\n\n// testOverwriteValue verifies Set overwrites existing values\nfunc (s *KeyValueBasicTestSuite) testOverwriteValue() {\n\tctx := context.Background()\n\tkey := "overwrite-key"\n\n\t// Set initial value\n\tsetReq := &proto.KeyValueSetRequest{\n\t\tNamespace: "test",\n\t\tKey:       key,\n\t\tValue:     []byte("initial-value"),\n\t}\n\t_, err := s.harness.Plugin.KeyValueSet(ctx, setReq)\n\trequire.NoError(s.t, err)\n\n\t// Overwrite with new value\n\tsetReq.Value = []byte("new-value")\n\t_, err = s.harness.Plugin.KeyValueSet(ctx, setReq)\n\trequire.NoError(s.t, err)\n\n\t// Verify new value\n\tgetReq := &proto.KeyValueGetRequest{\n\t\tNamespace: "test",\n\t\tKey:       key,\n\t}\n\tgetResp, err := s.harness.Plugin.KeyValueGet(ctx, getReq)\n\trequire.NoError(s.t, err)\n\tassert.Equal(s.t, []byte("new-value"), getResp.Value, "Value should be overwritten")\n}\n\n// testConcurrentSets verifies concurrent Set operations are safe\nfunc (s *KeyValueBasicTestSuite) testConcurrentSets() {\n\tctx := context.Background()\n\tconcurrency := 100\n\terrChan := make(chan error, concurrency)\n\n\tfor i := 0; i < concurrency; i++ {\n\t\tgo func(idx int) {\n\t\t\tsetReq := &proto.KeyValueSetRequest{\n\t\t\t\tNamespace: "test",\n\t\t\t\tKey:       fmt.Sprintf("concurrent-key-%d", idx),\n\t\t\t\tValue:     []byte(fmt.Sprintf("concurrent-value-%d", idx)),\n\t\t\t}\n\n\t\t\t_, err := s.harness.Plugin.KeyValueSet(ctx, setReq)\n\t\t\terrChan <- err\n\t\t}(i)\n\t}\n\n\t// Wait for all operations\n\tfor i := 0; i < concurrency; i++ {\n\t\terr := <-errChan\n\t\tassert.NoError(s.t, err, "Concurrent Set operations should succeed")\n\t}\n}\n'})}),"\n",(0,a.jsx)(t.h3,{id:"example-keyvalue-scan-interface",children:"Example: KeyValue Scan Interface"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-go",children:'// tests/acceptance/interfaces/keyvalue/keyvalue_scan_test.go\n\npackage keyvalue\n\nimport (\n\t"context"\n\t"fmt"\n\t"testing"\n\n\t"github.com/prism/plugin-core/proto"\n\t"github.com/prism/tests/acceptance/harness"\n\t"github.com/stretchr/testify/assert"\n\t"github.com/stretchr/testify/require"\n)\n\n// KeyValueScanTestSuite verifies keyvalue_scan interface compliance\ntype KeyValueScanTestSuite struct {\n\tharness *harness.PluginHarness\n\tt       *testing.T\n}\n\nfunc NewKeyValueScanTestSuite(t *testing.T, h *harness.PluginHarness) *KeyValueScanTestSuite {\n\treturn &KeyValueScanTestSuite{\n\t\tharness: h,\n\t\tt:       t,\n\t}\n}\n\nfunc (s *KeyValueScanTestSuite) Run() {\n\ts.t.Run("ScanAll", s.testScanAll)\n\ts.t.Run("ScanPrefix", s.testScanPrefix)\n\ts.t.Run("ScanLimit", s.testScanLimit)\n\ts.t.Run("ScanKeys", s.testScanKeys)\n\ts.t.Run("Count", s.testCount)\n\ts.t.Run("CountWithPrefix", s.testCountWithPrefix)\n}\n\nfunc (s *KeyValueScanTestSuite) testScanAll() {\n\tctx := context.Background()\n\n\t// Seed data\n\tfor i := 0; i < 10; i++ {\n\t\tsetReq := &proto.KeyValueSetRequest{\n\t\t\tNamespace: "test",\n\t\t\tKey:       fmt.Sprintf("scan-key-%d", i),\n\t\t\tValue:     []byte(fmt.Sprintf("scan-value-%d", i)),\n\t\t}\n\t\t_, err := s.harness.Plugin.KeyValueSet(ctx, setReq)\n\t\trequire.NoError(s.t, err)\n\t}\n\n\t// Scan all keys\n\tscanReq := &proto.KeyValueScanRequest{\n\t\tNamespace: "test",\n\t\tPrefix:    "",\n\t\tLimit:     0, // Unlimited\n\t}\n\n\tstream, err := s.harness.Plugin.KeyValueScan(ctx, scanReq)\n\trequire.NoError(s.t, err)\n\n\tresults := make(map[string][]byte)\n\tfor {\n\t\tresp, err := stream.Recv()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\trequire.NoError(s.t, err)\n\t\tresults[resp.Key] = resp.Value\n\t}\n\n\tassert.GreaterOrEqual(s.t, len(results), 10, "Should scan at least 10 keys")\n}\n\nfunc (s *KeyValueScanTestSuite) testScanPrefix() {\n\tctx := context.Background()\n\n\t// Seed data with different prefixes\n\tfor i := 0; i < 5; i++ {\n\t\tsetReq := &proto.KeyValueSetRequest{\n\t\t\tNamespace: "test",\n\t\t\tKey:       fmt.Sprintf("user:%d", i),\n\t\t\tValue:     []byte(fmt.Sprintf("user-data-%d", i)),\n\t\t}\n\t\t_, err := s.harness.Plugin.KeyValueSet(ctx, setReq)\n\t\trequire.NoError(s.t, err)\n\t}\n\n\tfor i := 0; i < 5; i++ {\n\t\tsetReq := &proto.KeyValueSetRequest{\n\t\t\tNamespace: "test",\n\t\t\tKey:       fmt.Sprintf("post:%d", i),\n\t\t\tValue:     []byte(fmt.Sprintf("post-data-%d", i)),\n\t\t}\n\t\t_, err := s.harness.Plugin.KeyValueSet(ctx, setReq)\n\t\trequire.NoError(s.t, err)\n\t}\n\n\t// Scan only user: prefix\n\tscanReq := &proto.KeyValueScanRequest{\n\t\tNamespace: "test",\n\t\tPrefix:    "user:",\n\t\tLimit:     0,\n\t}\n\n\tstream, err := s.harness.Plugin.KeyValueScan(ctx, scanReq)\n\trequire.NoError(s.t, err)\n\n\tuserKeys := 0\n\tfor {\n\t\tresp, err := stream.Recv()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\trequire.NoError(s.t, err)\n\t\tassert.Contains(s.t, resp.Key, "user:", "All keys should have user: prefix")\n\t\tuserKeys++\n\t}\n\n\tassert.Equal(s.t, 5, userKeys, "Should scan exactly 5 user keys")\n}\n\nfunc (s *KeyValueScanTestSuite) testScanLimit() {\n\tctx := context.Background()\n\n\t// Seed 20 keys\n\tfor i := 0; i < 20; i++ {\n\t\tsetReq := &proto.KeyValueSetRequest{\n\t\t\tNamespace: "test",\n\t\t\tKey:       fmt.Sprintf("limit-key-%d", i),\n\t\t\tValue:     []byte(fmt.Sprintf("limit-value-%d", i)),\n\t\t}\n\t\t_, err := s.harness.Plugin.KeyValueSet(ctx, setReq)\n\t\trequire.NoError(s.t, err)\n\t}\n\n\t// Scan with limit=10\n\tscanReq := &proto.KeyValueScanRequest{\n\t\tNamespace: "test",\n\t\tPrefix:    "limit-key-",\n\t\tLimit:     10,\n\t}\n\n\tstream, err := s.harness.Plugin.KeyValueScan(ctx, scanReq)\n\trequire.NoError(s.t, err)\n\n\tcount := 0\n\tfor {\n\t\t_, err := stream.Recv()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\trequire.NoError(s.t, err)\n\t\tcount++\n\t}\n\n\tassert.Equal(s.t, 10, count, "Should scan exactly 10 keys (limit)")\n}\n\nfunc (s *KeyValueScanTestSuite) testScanKeys() {\n\tctx := context.Background()\n\n\t// Seed data\n\tfor i := 0; i < 5; i++ {\n\t\tsetReq := &proto.KeyValueSetRequest{\n\t\t\tNamespace: "test",\n\t\t\tKey:       fmt.Sprintf("keys-only-%d", i),\n\t\t\tValue:     []byte(fmt.Sprintf("large-value-%d", i)), // Values not needed\n\t\t}\n\t\t_, err := s.harness.Plugin.KeyValueSet(ctx, setReq)\n\t\trequire.NoError(s.t, err)\n\t}\n\n\t// Scan keys only (no values)\n\tscanKeysReq := &proto.KeyValueScanKeysRequest{\n\t\tNamespace: "test",\n\t\tPrefix:    "keys-only-",\n\t\tLimit:     0,\n\t}\n\n\tstream, err := s.harness.Plugin.KeyValueScanKeys(ctx, scanKeysReq)\n\trequire.NoError(s.t, err)\n\n\tkeys := []string{}\n\tfor {\n\t\tresp, err := stream.Recv()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\trequire.NoError(s.t, err)\n\t\tkeys = append(keys, resp.Key)\n\t}\n\n\tassert.Equal(s.t, 5, len(keys), "Should scan 5 keys")\n}\n\nfunc (s *KeyValueScanTestSuite) testCount() {\n\tctx := context.Background()\n\n\t// Seed data\n\tfor i := 0; i < 15; i++ {\n\t\tsetReq := &proto.KeyValueSetRequest{\n\t\t\tNamespace: "test",\n\t\t\tKey:       fmt.Sprintf("count-key-%d", i),\n\t\t\tValue:     []byte(fmt.Sprintf("count-value-%d", i)),\n\t\t}\n\t\t_, err := s.harness.Plugin.KeyValueSet(ctx, setReq)\n\t\trequire.NoError(s.t, err)\n\t}\n\n\t// Count all keys\n\tcountReq := &proto.KeyValueCountRequest{\n\t\tNamespace: "test",\n\t\tPrefix:    "",\n\t}\n\n\tcountResp, err := s.harness.Plugin.KeyValueCount(ctx, countReq)\n\trequire.NoError(s.t, err)\n\tassert.GreaterOrEqual(s.t, countResp.Count, int64(15), "Should count at least 15 keys")\n}\n\nfunc (s *KeyValueScanTestSuite) testCountWithPrefix() {\n\tctx := context.Background()\n\n\t// Seed data\n\tfor i := 0; i < 10; i++ {\n\t\tsetReq := &proto.KeyValueSetRequest{\n\t\t\tNamespace: "test",\n\t\t\tKey:       fmt.Sprintf("prefix-count-key-%d", i),\n\t\t\tValue:     []byte(fmt.Sprintf("prefix-count-value-%d", i)),\n\t\t}\n\t\t_, err := s.harness.Plugin.KeyValueSet(ctx, setReq)\n\t\trequire.NoError(s.t, err)\n\t}\n\n\t// Count keys with prefix\n\tcountReq := &proto.KeyValueCountRequest{\n\t\tNamespace: "test",\n\t\tPrefix:    "prefix-count-",\n\t}\n\n\tcountResp, err := s.harness.Plugin.KeyValueCount(ctx, countReq)\n\trequire.NoError(s.t, err)\n\tassert.Equal(s.t, int64(10), countResp.Count, "Should count exactly 10 keys with prefix")\n}\n'})}),"\n",(0,a.jsx)(t.h2,{id:"backend-interface-registry",children:"Backend Interface Registry"}),"\n",(0,a.jsx)(t.h3,{id:"registry-loading",children:"Registry Loading"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-go",children:'// tests/acceptance/harness/interface_registry.go\n\npackage harness\n\nimport (\n\t"fmt"\n\t"io/ioutil"\n\t"path/filepath"\n\n\t"gopkg.in/yaml.v3"\n)\n\n// BackendRegistry loads backend interface declarations from registry/backends/*.yaml\ntype BackendRegistry struct {\n\tBackends map[string]*BackendDeclaration\n}\n\n// BackendDeclaration represents a backend\'s declared interfaces\ntype BackendDeclaration struct {\n\tBackend     string   `yaml:"backend"`\n\tDescription string   `yaml:"description"`\n\tPlugin      string   `yaml:"plugin"`\n\tImplements  []string `yaml:"implements"`\n}\n\n// LoadBackendRegistry loads all backend declarations from registry/backends/\nfunc LoadBackendRegistry(registryPath string) (*BackendRegistry, error) {\n\tregistry := &BackendRegistry{\n\t\tBackends: make(map[string]*BackendDeclaration),\n\t}\n\n\tfiles, err := filepath.Glob(filepath.Join(registryPath, "backends", "*.yaml"))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf("failed to list backend files: %w", err)\n\t}\n\n\tfor _, file := range files {\n\t\tdata, err := ioutil.ReadFile(file)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf("failed to read %s: %w", file, err)\n\t\t}\n\n\t\tvar decl BackendDeclaration\n\t\tif err := yaml.Unmarshal(data, &decl); err != nil {\n\t\t\treturn nil, fmt.Errorf("failed to parse %s: %w", file, err)\n\t\t}\n\n\t\tregistry.Backends[decl.Backend] = &decl\n\t}\n\n\treturn registry, nil\n}\n\n// FindBackendsImplementing returns backends that implement the given interface\nfunc (r *BackendRegistry) FindBackendsImplementing(interfaceName string) []*BackendDeclaration {\n\tbackends := []*BackendDeclaration{}\n\n\tfor _, backend := range r.Backends {\n\t\tfor _, iface := range backend.Implements {\n\t\t\tif iface == interfaceName {\n\t\t\t\tbackends = append(backends, backend)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn backends\n}\n\n// VerifyInterfaceImplemented checks if backend declares the interface\nfunc (r *BackendRegistry) VerifyInterfaceImplemented(backend, interfaceName string) bool {\n\tdecl, ok := r.Backends[backend]\n\tif !ok {\n\t\treturn false\n\t}\n\n\tfor _, iface := range decl.Implements {\n\t\tif iface == interfaceName {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n'})}),"\n",(0,a.jsx)(t.h2,{id:"compliance-matrix-test",children:"Compliance Matrix Test"}),"\n",(0,a.jsx)(t.p,{children:"The compliance matrix runs all interface tests for backends that claim to implement them:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-go",children:'// tests/acceptance/matrix/compliance_matrix_test.go\n\npackage matrix\n\nimport (\n\t"testing"\n\n\t"github.com/prism/tests/acceptance/harness"\n\t"github.com/prism/tests/acceptance/instances"\n\t"github.com/prism/tests/acceptance/interfaces/keyvalue"\n\t"github.com/prism/tests/acceptance/interfaces/pubsub"\n\t"github.com/prism/tests/acceptance/interfaces/stream"\n\t// ... import other interface test suites\n)\n\n// TestComplianceMatrix runs interface tests for all backends\nfunc TestComplianceMatrix(t *testing.T) {\n\t// Load backend registry\n\tregistry, err := harness.LoadBackendRegistry("../../registry")\n\tif err != nil {\n\t\tt.Fatalf("Failed to load backend registry: %v", err)\n\t}\n\n\t// Test each backend\n\tfor backendName, backend := range registry.Backends {\n\t\tt.Run(backendName, func(t *testing.T) {\n\t\t\ttestBackendCompliance(t, backend, registry)\n\t\t})\n\t}\n}\n\nfunc testBackendCompliance(t *testing.T, backend *harness.BackendDeclaration, registry *harness.BackendRegistry) {\n\t// Start backend testcontainer\n\tinstance := startBackendInstance(t, backend.Backend)\n\tdefer instance.Stop()\n\n\t// Create plugin harness\n\th := harness.NewPluginHarness(t, backend.Backend, instance)\n\tdefer h.Cleanup()\n\n\t// Run interface tests for each declared interface\n\tfor _, interfaceName := range backend.Implements {\n\t\tt.Run(interfaceName, func(t *testing.T) {\n\t\t\ttestInterface(t, interfaceName, h)\n\t\t})\n\t}\n}\n\nfunc testInterface(t *testing.T, interfaceName string, h *harness.PluginHarness) {\n\tswitch interfaceName {\n\t// KeyValue interfaces\n\tcase "keyvalue_basic":\n\t\tsuite := keyvalue.NewKeyValueBasicTestSuite(t, h)\n\t\tsuite.Run()\n\n\tcase "keyvalue_scan":\n\t\tsuite := keyvalue.NewKeyValueScanTestSuite(t, h)\n\t\tsuite.Run()\n\n\tcase "keyvalue_ttl":\n\t\tsuite := keyvalue.NewKeyValueTTLTestSuite(t, h)\n\t\tsuite.Run()\n\n\tcase "keyvalue_transactional":\n\t\tsuite := keyvalue.NewKeyValueTransactionalTestSuite(t, h)\n\t\tsuite.Run()\n\n\tcase "keyvalue_batch":\n\t\tsuite := keyvalue.NewKeyValueBatchTestSuite(t, h)\n\t\tsuite.Run()\n\n\tcase "keyvalue_cas":\n\t\tsuite := keyvalue.NewKeyValueCASTestSuite(t, h)\n\t\tsuite.Run()\n\n\t// PubSub interfaces\n\tcase "pubsub_basic":\n\t\tsuite := pubsub.NewPubSubBasicTestSuite(t, h)\n\t\tsuite.Run()\n\n\tcase "pubsub_wildcards":\n\t\tsuite := pubsub.NewPubSubWildcardsTestSuite(t, h)\n\t\tsuite.Run()\n\n\tcase "pubsub_persistent":\n\t\tsuite := pubsub.NewPubSubPersistentTestSuite(t, h)\n\t\tsuite.Run()\n\n\t// Stream interfaces\n\tcase "stream_basic":\n\t\tsuite := stream.NewStreamBasicTestSuite(t, h)\n\t\tsuite.Run()\n\n\tcase "stream_consumer_groups":\n\t\tsuite := stream.NewStreamConsumerGroupsTestSuite(t, h)\n\t\tsuite.Run()\n\n\tcase "stream_replay":\n\t\tsuite := stream.NewStreamReplayTestSuite(t, h)\n\t\tsuite.Run()\n\n\t// ... handle other interfaces\n\n\tdefault:\n\t\tt.Fatalf("Unknown interface: %s", interfaceName)\n\t}\n}\n\nfunc startBackendInstance(t *testing.T, backendType string) instances.TestBackend {\n\tswitch backendType {\n\tcase "redis":\n\t\treturn instances.NewRedisInstance(t)\n\tcase "postgres":\n\t\treturn instances.NewPostgresInstance(t)\n\tcase "kafka":\n\t\treturn instances.NewKafkaInstance(t)\n\tcase "memstore":\n\t\treturn instances.NewMemStoreInstance(t)\n\t// ... other backends\n\tdefault:\n\t\tt.Fatalf("Unknown backend type: %s", backendType)\n\t\treturn nil\n\t}\n}\n'})}),"\n",(0,a.jsx)(t.h2,{id:"cicd-integration",children:"CI/CD Integration"}),"\n",(0,a.jsx)(t.h3,{id:"github-actions-workflow",children:"GitHub Actions Workflow"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:'# .github/workflows/interface-compliance.yml\n\nname: Interface Compliance Matrix\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  compliance:\n    name: ${{ matrix.backend }} - ${{ matrix.interface }}\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n\n    strategy:\n      fail-fast: false\n      matrix:\n        include:\n          # Redis (16 interfaces)\n          - backend: redis\n            interface: keyvalue_basic\n          - backend: redis\n            interface: keyvalue_scan\n          - backend: redis\n            interface: keyvalue_ttl\n          - backend: redis\n            interface: keyvalue_transactional\n          - backend: redis\n            interface: keyvalue_batch\n          - backend: redis\n            interface: pubsub_basic\n          - backend: redis\n            interface: pubsub_wildcards\n          - backend: redis\n            interface: stream_basic\n          - backend: redis\n            interface: stream_consumer_groups\n          - backend: redis\n            interface: stream_replay\n          - backend: redis\n            interface: stream_retention\n          - backend: redis\n            interface: list_basic\n          - backend: redis\n            interface: list_indexing\n          - backend: redis\n            interface: list_range\n          - backend: redis\n            interface: list_blocking\n          - backend: redis\n            interface: set_basic\n          # ... (all Redis interfaces)\n\n          # PostgreSQL (16 interfaces)\n          - backend: postgres\n            interface: keyvalue_basic\n          - backend: postgres\n            interface: keyvalue_scan\n          - backend: postgres\n            interface: keyvalue_transactional\n          - backend: postgres\n            interface: keyvalue_batch\n          - backend: postgres\n            interface: queue_basic\n          - backend: postgres\n            interface: queue_visibility\n          - backend: postgres\n            interface: queue_dead_letter\n          - backend: postgres\n            interface: queue_delayed\n          - backend: postgres\n            interface: timeseries_basic\n          - backend: postgres\n            interface: timeseries_aggregation\n          - backend: postgres\n            interface: timeseries_retention\n          - backend: postgres\n            interface: document_basic\n          - backend: postgres\n            interface: document_query\n          - backend: postgres\n            interface: document_indexing\n          - backend: postgres\n            interface: graph_basic\n          - backend: postgres\n            interface: graph_traversal\n\n          # MemStore (6 interfaces - minimal for testing)\n          - backend: memstore\n            interface: keyvalue_basic\n          - backend: memstore\n            interface: keyvalue_ttl\n          - backend: memstore\n            interface: list_basic\n          - backend: memstore\n            interface: list_indexing\n          - backend: memstore\n            interface: list_range\n          - backend: memstore\n            interface: list_blocking\n\n          # Kafka (7 interfaces - streaming focus)\n          - backend: kafka\n            interface: stream_basic\n          - backend: kafka\n            interface: stream_consumer_groups\n          - backend: kafka\n            interface: stream_replay\n          - backend: kafka\n            interface: stream_retention\n          - backend: kafka\n            interface: stream_partitioning\n          - backend: kafka\n            interface: pubsub_basic\n          - backend: kafka\n            interface: pubsub_persistent\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Setup Go\n        uses: actions/setup-go@v4\n        with:\n          go-version: \'1.21\'\n\n      - name: Install dependencies\n        run: |\n          go mod download\n          go install github.com/testcontainers/testcontainers-go@latest\n\n      - name: Build plugin\n        run: |\n          cd plugins/${{ matrix.backend }}\n          go build -o plugin-server ./cmd/server\n\n      - name: Run interface test\n        env:\n          BACKEND_TYPE: ${{ matrix.backend }}\n          INTERFACE_NAME: ${{ matrix.interface }}\n          DOCKER_HOST: unix:///var/run/docker.sock\n        run: |\n          go test -v -timeout 5m \\\n            ./tests/acceptance/matrix/... \\\n            -run "TestComplianceMatrix/${{ matrix.backend }}/${{ matrix.interface }}"\n\n      - name: Upload test results\n        if: always()\n        uses: actions/upload-artifact@v3\n        with:\n          name: test-results-${{ matrix.backend }}-${{ matrix.interface }}\n          path: test-results/\n\n  compliance-summary:\n    name: Compliance Summary\n    runs-on: ubuntu-latest\n    needs: compliance\n    if: always()\n\n    steps:\n      - name: Download all test results\n        uses: actions/download-artifact@v3\n\n      - name: Generate compliance matrix\n        run: |\n          echo "## Interface Compliance Matrix" >> $GITHUB_STEP_SUMMARY\n          echo "" >> $GITHUB_STEP_SUMMARY\n          echo "| Backend | Interface | Status |" >> $GITHUB_STEP_SUMMARY\n          echo "|---------|-----------|--------|" >> $GITHUB_STEP_SUMMARY\n\n          for dir in test-results-*/; do\n            backend=$(echo $dir | cut -d\'-\' -f3)\n            interface=$(echo $dir | cut -d\'-\' -f4 | tr -d \'/\')\n\n            if [ -f "$dir/PASS" ]; then\n              status="\u2705 PASS"\n            else\n              status="\u274c FAIL"\n            fi\n\n            echo "| $backend | $interface | $status |" >> $GITHUB_STEP_SUMMARY\n          done\n'})}),"\n",(0,a.jsx)(t.h2,{id:"benefits",children:"Benefits"}),"\n",(0,a.jsx)(t.h3,{id:"1-interface-compliance-verification",children:"1. Interface Compliance Verification"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Problem"}),": Backend claims to implement ",(0,a.jsx)(t.code,{children:"keyvalue_scan"})," but actually doesn't support prefix filtering."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Solution"}),": Interface test suite validates all operations defined in ",(0,a.jsx)(t.code,{children:"keyvalue_scan.proto"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-go",children:'func (s *KeyValueScanTestSuite) Run() {\n    s.t.Run("ScanAll", s.testScanAll)\n    s.t.Run("ScanPrefix", s.testScanPrefix)  // \u2190 Will fail if not implemented\n    s.t.Run("ScanLimit", s.testScanLimit)\n    s.t.Run("ScanKeys", s.testScanKeys)\n    s.t.Run("Count", s.testCount)\n}\n'})}),"\n",(0,a.jsx)(t.h3,{id:"2-cross-backend-test-reuse",children:"2. Cross-Backend Test Reuse"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Before"})," (backend-type testing):"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Write PostgreSQL-specific test suite (500 lines)"}),"\n",(0,a.jsx)(t.li,{children:"Write Redis-specific test suite (500 lines)"}),"\n",(0,a.jsx)(t.li,{children:"Write DynamoDB-specific test suite (500 lines)"}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Total"}),": 1500 lines, duplicated logic"]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"After"})," (interface-based testing):"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Write ",(0,a.jsx)(t.code,{children:"keyvalue_basic"})," test suite ONCE (100 lines)"]}),"\n",(0,a.jsx)(t.li,{children:"Run for PostgreSQL, Redis, DynamoDB, etcd, MemStore"}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Total"}),": 100 lines, shared across 5 backends"]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"3-clear-contract-definition",children:"3. Clear Contract Definition"}),"\n",(0,a.jsx)(t.p,{children:"Interface test suites serve as executable specifications:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-go",children:"// KeyValueBasicTestSuite defines EXACTLY what keyvalue_basic means:\n// 1. Set(key, value) stores a value\n// 2. Get(key) retrieves the value\n// 3. Delete(key) removes the value\n// 4. Exists(key) checks if key exists\n// 5. Set on existing key overwrites value\n// 6. Get on non-existent key returns NotFound\n// 7. Concurrent operations are safe\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Backends implementing ",(0,a.jsx)(t.code,{children:"keyvalue_basic"})," MUST pass all 10 tests."]}),"\n",(0,a.jsx)(t.h3,{id:"4-incremental-implementation",children:"4. Incremental Implementation"}),"\n",(0,a.jsx)(t.p,{children:"Backends can implement subsets of interfaces:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:"# registry/backends/memstore.yaml\nimplements:\n  - keyvalue_basic  # Minimal KV (Set, Get, Delete, Exists)\n  - keyvalue_ttl    # TTL support\n  - list_basic      # List operations\n\n# NOT implemented (skipped in tests):\n# - keyvalue_scan   # MemStore doesn't support efficient scanning\n# - keyvalue_transactional  # No transactions\n"})}),"\n",(0,a.jsx)(t.p,{children:"Tests run ONLY for declared interfaces - no false failures."}),"\n",(0,a.jsx)(t.h3,{id:"5-registry-driven-testing",children:"5. Registry-Driven Testing"}),"\n",(0,a.jsxs)(t.p,{children:["Backend registry (",(0,a.jsx)(t.code,{children:"registry/backends/*.yaml"}),") is single source of truth:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:"# registry/backends/redis.yaml\nbackend: redis\nimplements:\n  - keyvalue_basic\n  - keyvalue_scan\n  - keyvalue_ttl\n  # ... 13 more interfaces\n"})}),"\n",(0,a.jsx)(t.p,{children:"Test framework:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"Loads registry"}),"\n",(0,a.jsxs)(t.li,{children:["Finds backends implementing ",(0,a.jsx)(t.code,{children:"keyvalue_basic"})]}),"\n",(0,a.jsxs)(t.li,{children:["Runs ",(0,a.jsx)(t.code,{children:"KeyValueBasicTestSuite"})," for each backend"]}),"\n",(0,a.jsx)(t.li,{children:"Reports pass/fail in compliance matrix"}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"running-tests-locally",children:"Running Tests Locally"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'# Run full compliance matrix (tests all backends \xd7 interfaces)\nmake test-compliance\n\n# Run compliance tests for specific backend\nmake test-compliance-redis\n\n# Run tests for specific interface (across all backends)\ngo test ./tests/acceptance/matrix/... -run "TestComplianceMatrix/.*/keyvalue_basic"\n\n# Run tests for specific backend+interface\ngo test ./tests/acceptance/matrix/... -run "TestComplianceMatrix/redis/keyvalue_scan"\n\n# Run tests with verbose output\ngo test -v ./tests/acceptance/matrix/...\n\n# Generate coverage report\ngo test -coverprofile=coverage.out ./tests/acceptance/...\ngo tool cover -html=coverage.out\n'})}),"\n",(0,a.jsx)(t.h3,{id:"makefile-targets",children:"Makefile Targets"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-makefile",children:'# Makefile\n\n.PHONY: test-compliance\ntest-compliance: ## Run full interface compliance matrix\n\t@echo "Running interface compliance tests..."\n\tgo test -v -timeout 30m ./tests/acceptance/matrix/...\n\n.PHONY: test-compliance-redis\ntest-compliance-redis: ## Run Redis compliance tests\n\tgo test -v -timeout 10m ./tests/acceptance/matrix/... -run TestComplianceMatrix/redis\n\n.PHONY: test-compliance-postgres\ntest-compliance-postgres: ## Run PostgreSQL compliance tests\n\tgo test -v -timeout 10m ./tests/acceptance/matrix/... -run TestComplianceMatrix/postgres\n\n.PHONY: test-compliance-memstore\ntest-compliance-memstore: ## Run MemStore compliance tests\n\tgo test -v -timeout 5m ./tests/acceptance/matrix/... -run TestComplianceMatrix/memstore\n\n.PHONY: test-interface\ntest-interface: ## Run tests for specific interface (e.g., make test-interface INTERFACE=keyvalue_basic)\n\tgo test -v ./tests/acceptance/matrix/... -run "TestComplianceMatrix/.*/${INTERFACE}"\n\n.PHONY: validate-registry\nvalidate-registry: ## Validate backend registry files\n\tgo test -v ./tests/acceptance/matrix/... -run TestRegistryValidator\n'})}),"\n",(0,a.jsx)(t.h2,{id:"test-output-example",children:"Test Output Example"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"$ make test-compliance\n\n=== RUN   TestComplianceMatrix\n=== RUN   TestComplianceMatrix/redis\n=== RUN   TestComplianceMatrix/redis/keyvalue_basic\n=== RUN   TestComplianceMatrix/redis/keyvalue_basic/Set\n=== RUN   TestComplianceMatrix/redis/keyvalue_basic/Get\n=== RUN   TestComplianceMatrix/redis/keyvalue_basic/Delete\n=== RUN   TestComplianceMatrix/redis/keyvalue_basic/Exists\n=== RUN   TestComplianceMatrix/redis/keyvalue_basic/SetGetDelete\n=== RUN   TestComplianceMatrix/redis/keyvalue_basic/GetNonExistent\n=== RUN   TestComplianceMatrix/redis/keyvalue_basic/DeleteNonExistent\n=== RUN   TestComplianceMatrix/redis/keyvalue_basic/ExistsNonExistent\n=== RUN   TestComplianceMatrix/redis/keyvalue_basic/OverwriteValue\n=== RUN   TestComplianceMatrix/redis/keyvalue_basic/ConcurrentSets\n--- PASS: TestComplianceMatrix/redis/keyvalue_basic (2.3s)\n\n=== RUN   TestComplianceMatrix/redis/keyvalue_scan\n=== RUN   TestComplianceMatrix/redis/keyvalue_scan/ScanAll\n=== RUN   TestComplianceMatrix/redis/keyvalue_scan/ScanPrefix\n=== RUN   TestComplianceMatrix/redis/keyvalue_scan/ScanLimit\n=== RUN   TestComplianceMatrix/redis/keyvalue_scan/ScanKeys\n=== RUN   TestComplianceMatrix/redis/keyvalue_scan/Count\n=== RUN   TestComplianceMatrix/redis/keyvalue_scan/CountWithPrefix\n--- PASS: TestComplianceMatrix/redis/keyvalue_scan (3.1s)\n\n=== RUN   TestComplianceMatrix/postgres\n=== RUN   TestComplianceMatrix/postgres/keyvalue_basic\n--- PASS: TestComplianceMatrix/postgres/keyvalue_basic (2.8s)\n\n=== RUN   TestComplianceMatrix/postgres/keyvalue_scan\n--- PASS: TestComplianceMatrix/postgres/keyvalue_scan (3.5s)\n\n=== RUN   TestComplianceMatrix/memstore\n=== RUN   TestComplianceMatrix/memstore/keyvalue_basic\n--- PASS: TestComplianceMatrix/memstore/keyvalue_basic (0.1s)\n\n=== RUN   TestComplianceMatrix/memstore/keyvalue_ttl\n--- PASS: TestComplianceMatrix/memstore/keyvalue_ttl (1.2s)\n\nPASS\nok      github.com/prism/tests/acceptance/matrix        15.234s\n"})}),"\n",(0,a.jsx)(t.h3,{id:"compliance-matrix-summary",children:"Compliance Matrix Summary"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-text",children:"Interface Compliance Matrix\n===========================\n\nBackend: redis (16/16 interfaces PASS)\n  \u2713 keyvalue_basic\n  \u2713 keyvalue_scan\n  \u2713 keyvalue_ttl\n  \u2713 keyvalue_transactional\n  \u2713 keyvalue_batch\n  \u2713 pubsub_basic\n  \u2713 pubsub_wildcards\n  \u2713 stream_basic\n  \u2713 stream_consumer_groups\n  \u2713 stream_replay\n  \u2713 stream_retention\n  \u2713 list_basic\n  \u2713 list_indexing\n  \u2713 list_range\n  \u2713 list_blocking\n  \u2713 set_basic\n\nBackend: postgres (16/16 interfaces PASS)\n  \u2713 keyvalue_basic\n  \u2713 keyvalue_scan\n  \u2713 keyvalue_transactional\n  \u2713 keyvalue_batch\n  \u2713 queue_basic\n  \u2713 queue_visibility\n  \u2713 queue_dead_letter\n  \u2713 queue_delayed\n  \u2713 timeseries_basic\n  \u2713 timeseries_aggregation\n  \u2713 timeseries_retention\n  \u2713 document_basic\n  \u2713 document_query\n  \u2713 document_indexing\n  \u2713 graph_basic\n  \u2713 graph_traversal\n\nBackend: memstore (6/6 interfaces PASS)\n  \u2713 keyvalue_basic\n  \u2713 keyvalue_ttl\n  \u2713 list_basic\n  \u2713 list_indexing\n  \u2713 list_range\n  \u2713 list_blocking\n\nBackend: kafka (7/7 interfaces PASS)\n  \u2713 stream_basic\n  \u2713 stream_consumer_groups\n  \u2713 stream_replay\n  \u2713 stream_retention\n  \u2713 stream_partitioning\n  \u2713 pubsub_basic\n  \u2713 pubsub_persistent\n\nTotal: 45/45 interfaces PASS across 4 backends\n"})}),"\n",(0,a.jsx)(t.h2,{id:"future-enhancements",children:"Future Enhancements"}),"\n",(0,a.jsx)(t.h3,{id:"phase-1-complete-interface-coverage-q1-2026",children:"Phase 1: Complete Interface Coverage (Q1 2026)"}),"\n",(0,a.jsx)(t.p,{children:"Implement test suites for all 45 interfaces:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"\u2705 KeyValue (6 interfaces) - Completed"}),"\n",(0,a.jsx)(t.li,{children:"\u23f3 PubSub (5 interfaces) - In progress"}),"\n",(0,a.jsx)(t.li,{children:"\u23f3 Stream (5 interfaces) - In progress"}),"\n",(0,a.jsx)(t.li,{children:"\u23f3 Queue (5 interfaces) - Planned"}),"\n",(0,a.jsx)(t.li,{children:"\u23f3 List (4 interfaces) - Planned"}),"\n",(0,a.jsx)(t.li,{children:"\u23f3 Set (4 interfaces) - Planned"}),"\n",(0,a.jsx)(t.li,{children:"\u23f3 SortedSet (5 interfaces) - Planned"}),"\n",(0,a.jsx)(t.li,{children:"\u23f3 TimeSeries (4 interfaces) - Planned"}),"\n",(0,a.jsx)(t.li,{children:"\u23f3 Graph (4 interfaces) - Planned"}),"\n",(0,a.jsx)(t.li,{children:"\u23f3 Document (3 interfaces) - Planned"}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"phase-2-performance-baseline-tests-q2-2026",children:"Phase 2: Performance Baseline Tests (Q2 2026)"}),"\n",(0,a.jsx)(t.p,{children:"Add performance benchmarks to interface tests:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-go",children:"func (s *KeyValueBasicTestSuite) BenchmarkSet() {\n    // Verify latency < P99 SLO (5ms)\n    // Verify throughput > 10k ops/sec\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"phase-3-chaos-testing-q3-2026",children:"Phase 3: Chaos Testing (Q3 2026)"}),"\n",(0,a.jsx)(t.p,{children:"Test interface compliance under failure conditions:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Network partitions"}),"\n",(0,a.jsx)(t.li,{children:"Backend crashes"}),"\n",(0,a.jsx)(t.li,{children:"Slow backends (timeout testing)"}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"related-documents",children:"Related Documents"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.a,{href:"/memos/memo-006",children:"MEMO-006: Backend Interface Decomposition"})," - Interface design principles"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.a,{href:"/rfc/rfc-008",children:"RFC-008: Proxy Plugin Architecture"})," - Plugin system overview"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.a,{href:"/memos/memo-004",children:"MEMO-004: Backend Plugin Implementation Guide"})," - Backend implementability rankings"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"2025-10-09: Rewritten based on MEMO-006 interface decomposition principles - changed from backend-type testing to interface-based testing"}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}}}]);