"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[6072],{1242:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"memo-008","title":"Vault Token Exchange Flow for Plugin Authentication","description":"Purpose","source":"@site/../docs-cms/memos/memo-008-vault-token-exchange-flow.md","sourceDirName":".","slug":"/memo-008","permalink":"/prism-data-layer/memos/memo-008","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/memos/memo-008-vault-token-exchange-flow.md","tags":[{"inline":true,"label":"vault","permalink":"/prism-data-layer/memos/tags/vault"},{"inline":true,"label":"authentication","permalink":"/prism-data-layer/memos/tags/authentication"},{"inline":true,"label":"security","permalink":"/prism-data-layer/memos/tags/security"},{"inline":true,"label":"plugins","permalink":"/prism-data-layer/memos/tags/plugins"},{"inline":true,"label":"credentials","permalink":"/prism-data-layer/memos/tags/credentials"},{"inline":true,"label":"service-identity","permalink":"/prism-data-layer/memos/tags/service-identity"},{"inline":true,"label":"kubernetes","permalink":"/prism-data-layer/memos/tags/kubernetes"},{"inline":true,"label":"aws","permalink":"/prism-data-layer/memos/tags/aws"}],"version":"current","frontMatter":{"author":"Platform Team","created":"2025-10-09T00:00:00.000Z","doc_uuid":"4cdc89a6-7121-493e-9a80-0348af5851d9","id":"memo-008","project_id":"prism-data-layer","status":"Active","tags":["vault","authentication","security","plugins","credentials","service-identity","kubernetes","aws"],"title":"Vault Token Exchange Flow for Plugin Authentication","updated":"2025-10-10T00:00:00.000Z"},"sidebar":"memosSidebar","previous":{"title":"Podman Demo for Scratch-Based Containers with Native Runtime \u2022 MEMO-007","permalink":"/prism-data-layer/memos/memo-007"},"next":{"title":"Topaz Local Authorizer Configuration for Development and Integration Testing \u2022 MEMO-009","permalink":"/prism-data-layer/memos/memo-009"}}');var r=t(74848),a=t(28453);const s={author:"Platform Team",created:new Date("2025-10-09T00:00:00.000Z"),doc_uuid:"4cdc89a6-7121-493e-9a80-0348af5851d9",id:"memo-008",project_id:"prism-data-layer",status:"Active",tags:["vault","authentication","security","plugins","credentials","service-identity","kubernetes","aws"],title:"Vault Token Exchange Flow for Plugin Authentication",updated:new Date("2025-10-10T00:00:00.000Z")},o="MEMO-008: Vault Token Exchange Flow for Plugin Authentication",l={},c=[{value:"Purpose",id:"purpose",level:2},{value:"Overview",id:"overview",level:2},{value:"Token Exchange Flows",id:"token-exchange-flows",level:2},{value:"Human-Originated Flow (Primary)",id:"human-originated-flow-primary",level:3},{value:"Service-Originated Flow",id:"service-originated-flow",level:3},{value:"Detailed Sequence Diagram (Human-Originated)",id:"detailed-sequence-diagram-human-originated",level:3},{value:"Detailed Sequence Diagram (Service-Originated)",id:"detailed-sequence-diagram-service-originated",level:3},{value:"Implementation Details",id:"implementation-details",level:2},{value:"Service Authentication Methods",id:"service-authentication-methods",level:3},{value:"Kubernetes Service Account Authentication",id:"kubernetes-service-account-authentication",level:3},{value:"AWS IAM Role Authentication",id:"aws-iam-role-authentication",level:3},{value:"Service Identity Propagation",id:"service-identity-propagation",level:3},{value:"Service Session Manager",id:"service-session-manager",level:3},{value:"Vault Configuration for Service Authentication",id:"vault-configuration-for-service-authentication",level:3},{value:"Kubernetes Auth Method",id:"kubernetes-auth-method",level:4},{value:"AWS IAM Auth Method",id:"aws-iam-auth-method",level:4},{value:"Service vs Human Authentication Comparison",id:"service-vs-human-authentication-comparison",level:3},{value:"Implementation Details (Human-Originated)",id:"implementation-details-human-originated",level:2},{value:"Step 1: Extract JWT from gRPC Metadata",id:"step-1-extract-jwt-from-grpc-metadata",level:3},{value:"Step 2: Validate JWT Token",id:"step-2-validate-jwt-token",level:3},{value:"Step 3: Exchange JWT for Vault Token",id:"step-3-exchange-jwt-for-vault-token",level:3},{value:"Step 4: Fetch Backend Credentials",id:"step-4-fetch-backend-credentials",level:3},{value:"Step 5: Background Credential Renewal",id:"step-5-background-credential-renewal",level:3},{value:"Step 6: Complete Plugin Integration",id:"step-6-complete-plugin-integration",level:3},{value:"Vault Configuration",id:"vault-configuration",level:2},{value:"JWT Auth Method Setup",id:"jwt-auth-method-setup",level:3},{value:"Database Secrets Engine Setup",id:"database-secrets-engine-setup",level:3},{value:"Vault Policy",id:"vault-policy",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Common Failure Scenarios",id:"common-failure-scenarios",level:3},{value:"Retry Logic Example",id:"retry-logic-example",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Token Validation Caching",id:"token-validation-caching",level:3},{value:"Connection Pooling",id:"connection-pooling",level:3},{value:"Security Best Practices",id:"security-best-practices",level:2},{value:"Related Documents",id:"related-documents",level:2},{value:"Revision History",id:"revision-history",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"memo-008-vault-token-exchange-flow-for-plugin-authentication",children:"MEMO-008: Vault Token Exchange Flow for Plugin Authentication"})}),"\n",(0,r.jsx)(n.h2,{id:"purpose",children:"Purpose"}),"\n",(0,r.jsx)(n.p,{children:"This memo documents the complete token exchange flow between Prism plugins and HashiCorp Vault for obtaining dynamic, per-session backend credentials. This flow is critical for implementing the architectural decision from RFC-019 to push token validation and credential exchange to the plugin layer."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Plugins need to securely obtain backend credentials (database username/password, API keys) without using shared long-lived credentials."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),": Plugins exchange validated user JWT tokens with Vault to receive dynamic, short-lived credentials that are unique per session."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Per-user audit trails in backend logs"}),"\n",(0,r.jsx)(n.li,{children:"Automatic credential rotation"}),"\n",(0,r.jsx)(n.li,{children:"Zero shared credentials (breach of one session doesn't compromise others)"}),"\n",(0,r.jsx)(n.li,{children:"Fine-grained access control at backend level"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"token-exchange-flows",children:"Token Exchange Flows"}),"\n",(0,r.jsx)(n.p,{children:"Prism supports two authentication flows:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Human-Originated Requests"}),": User applications with OIDC JWT tokens"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Service-Originated Requests"}),": Service-to-service with machine identity"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"human-originated-flow-primary",children:"Human-Originated Flow (Primary)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Human-Originated Token Exchange Lifecycle           \u2502\n\u2502                                                                  \u2502\n\u2502  1. Client Request       \u2192 JWT token in gRPC metadata           \u2502\n\u2502  2. Token Validation     \u2192 Plugin verifies JWT signature        \u2502\n\u2502  3. Vault JWT Auth       \u2192 Exchange user JWT for Vault token    \u2502\n\u2502  4. Credential Fetch     \u2192 Use Vault token to get DB creds      \u2502\n\u2502  5. Backend Connection   \u2192 Establish connection with creds      \u2502\n\u2502  6. Credential Renewal   \u2192 Background goroutine renews lease    \u2502\n\u2502  7. Session Teardown     \u2192 Revoke Vault lease, close connection \u2502\n\u2502                                                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(n.h3,{id:"service-originated-flow",children:"Service-Originated Flow"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            Service-Originated Token Exchange Lifecycle           \u2502\n\u2502                                                                  \u2502\n\u2502  1. Service Request      \u2192 Service identity (K8s SA, IAM role)  \u2502\n\u2502  2. Identity Validation  \u2192 Plugin validates service identity    \u2502\n\u2502  3. Vault Auth           \u2192 Exchange identity for Vault token    \u2502\n\u2502  4. Credential Fetch     \u2192 Use Vault token to get DB creds      \u2502\n\u2502  5. Backend Connection   \u2192 Establish connection with creds      \u2502\n\u2502  6. Credential Renewal   \u2192 Background goroutine renews lease    \u2502\n\u2502  7. Service Shutdown     \u2192 Revoke Vault lease, close connection \u2502\n\u2502                                                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(n.h3,{id:"detailed-sequence-diagram-human-originated",children:"Detailed Sequence Diagram (Human-Originated)"}),"\n",(0,r.jsx)(n.mermaid,{value:'sequenceDiagram\n    participant Client\n    participant Plugin as Plugin (Redis)\n    participant JWKS as OIDC Provider<br/>(JWKS endpoint)\n    participant Vault as HashiCorp Vault\n    participant Backend as Backend (Redis)\n\n    Note over Client,Backend: Step 1: Initial Request with JWT\n\n    Client->>Plugin: gRPC Request<br/>(Authorization: Bearer <JWT>)\n\n    Note over Plugin: Step 2: Token Validation\n\n    Plugin->>JWKS: GET /.well-known/jwks.json\n    JWKS--\x3e>Plugin: Public keys for JWT verification\n    Plugin->>Plugin: Verify JWT signature<br/>Check exp, aud, iss claims\n\n    alt Token Invalid\n        Plugin--\x3e>Client: 401 Unauthenticated\n    end\n\n    Note over Plugin,Vault: Step 3: Exchange JWT for Vault Token\n\n    Plugin->>Vault: POST /v1/auth/jwt/login<br/>{jwt: "<user-jwt>", role: "prism-redis"}\n    Vault->>Vault: Validate JWT claims<br/>Check role bindings\n    Vault--\x3e>Plugin: {client_token: "<vault-token>", lease_duration: 3600}\n\n    Note over Plugin,Vault: Step 4: Fetch Backend Credentials\n\n    Plugin->>Vault: GET /v1/database/creds/redis-role<br/>Header: X-Vault-Token: <vault-token>\n    Vault->>Vault: Generate dynamic credentials<br/>username: v-jwt-alice-abc123<br/>password: <random>\n    Vault--\x3e>Plugin: {username: "v-jwt-alice-abc123",<br/>password: "...", lease_id: "...",<br/>lease_duration: 3600}\n\n    Note over Plugin,Backend: Step 5: Establish Backend Connection\n\n    Plugin->>Backend: AUTH v-jwt-alice-abc123 <password>\n    Backend--\x3e>Plugin: OK\n    Plugin->>Backend: Execute operation (GET/SET/etc)\n    Backend--\x3e>Plugin: Result\n    Plugin--\x3e>Client: Response\n\n    Note over Plugin,Vault: Step 6: Background Credential Renewal (every 30 min)\n\n    loop Every lease_duration/2\n        Plugin->>Vault: POST /v1/auth/token/renew-self\n        Vault--\x3e>Plugin: {lease_duration: 3600}\n        Plugin->>Vault: PUT /v1/sys/leases/renew<br/>{lease_id: "..."}\n        Vault--\x3e>Plugin: {lease_duration: 3600}\n    end\n\n    Note over Plugin,Backend: Step 7: Session Teardown\n\n    Client->>Plugin: Close session / disconnect\n    Plugin->>Vault: PUT /v1/sys/leases/revoke<br/>{lease_id: "..."}\n    Vault->>Backend: DROP USER v-jwt-alice-abc123\n    Backend--\x3e>Vault: OK\n    Vault--\x3e>Plugin: OK\n    Plugin->>Backend: Close connection'}),"\n",(0,r.jsx)(n.h3,{id:"detailed-sequence-diagram-service-originated",children:"Detailed Sequence Diagram (Service-Originated)"}),"\n",(0,r.jsx)(n.mermaid,{value:'sequenceDiagram\n    participant Service as Prism Service<br/>(Background Job)\n    participant Plugin as Plugin (Redis)\n    participant K8s as Kubernetes<br/>Service Account\n    participant Vault as HashiCorp Vault\n    participant Backend as Backend (Redis)\n\n    Note over Service,Backend: Step 1: Service Initialization with Identity\n\n    Service->>K8s: Read service account token<br/>/var/run/secrets/kubernetes.io/serviceaccount/token\n    K8s--\x3e>Service: Service Account JWT\n\n    Service->>Plugin: gRPC Request<br/>(X-Service-Identity: prism-aggregator)\n\n    Note over Plugin,Vault: Step 2: Service Identity Validation\n\n    Plugin->>Plugin: Extract service identity<br/>from metadata\n\n    Plugin->>Vault: POST /v1/auth/kubernetes/login<br/>{jwt: "<k8s-sa-token>", role: "prism-service"}\n    Vault->>Vault: Validate K8s SA token<br/>Check role bindings<br/>Verify service namespace\n    Vault--\x3e>Plugin: {client_token: "<vault-token>", lease_duration: 3600}\n\n    Note over Plugin,Vault: Step 3: Fetch Backend Credentials\n\n    Plugin->>Vault: GET /v1/database/creds/redis-service-role<br/>Header: X-Vault-Token: <vault-token>\n    Vault->>Vault: Generate service credentials<br/>username: v-k8s-prism-aggregator-xyz<br/>password: <random>\n    Vault--\x3e>Plugin: {username: "v-k8s-prism-aggregator-xyz",<br/>password: "...", lease_id: "...",<br/>lease_duration: 3600}\n\n    Note over Plugin,Backend: Step 4: Establish Backend Connection\n\n    Plugin->>Backend: AUTH v-k8s-prism-aggregator-xyz <password>\n    Backend--\x3e>Plugin: OK\n    Plugin->>Backend: Execute operation (GET/SET/etc)\n    Backend--\x3e>Plugin: Result\n    Plugin--\x3e>Service: Response\n\n    Note over Plugin,Vault: Step 5: Background Credential Renewal\n\n    loop Every lease_duration/2\n        Plugin->>Vault: POST /v1/auth/token/renew-self\n        Vault--\x3e>Plugin: {lease_duration: 3600}\n        Plugin->>Vault: PUT /v1/sys/leases/renew<br/>{lease_id: "..."}\n        Vault--\x3e>Plugin: {lease_duration: 3600}\n    end\n\n    Note over Plugin,Backend: Step 6: Service Shutdown\n\n    Service->>Plugin: Shutdown signal\n    Plugin->>Vault: PUT /v1/sys/leases/revoke<br/>{lease_id: "..."}\n    Vault->>Backend: DROP USER v-k8s-prism-aggregator-xyz\n    Backend--\x3e>Vault: OK\n    Vault--\x3e>Plugin: OK\n    Plugin->>Backend: Close connection'}),"\n",(0,r.jsx)(n.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,r.jsx)(n.h3,{id:"service-authentication-methods",children:"Service Authentication Methods"}),"\n",(0,r.jsx)(n.p,{children:"Prism supports multiple service authentication methods:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Kubernetes Service Accounts"})," (Recommended for K8s deployments)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"AWS IAM Roles"})," (Recommended for AWS deployments)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Azure Managed Identity"})," (Recommended for Azure deployments)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"GCP Service Accounts"})," (Recommended for GCP deployments)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"kubernetes-service-account-authentication",children:"Kubernetes Service Account Authentication"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// pkg/authz/k8s_auth.go\npackage authz\n\nimport (\n    "context"\n    "fmt"\n    "os"\n    "time"\n\n    vault "github.com/hashicorp/vault/api"\n)\n\nconst (\n    // Default service account token path\n    k8sTokenPath = "/var/run/secrets/kubernetes.io/serviceaccount/token"\n)\n\n// K8sAuthenticator handles Kubernetes service account authentication\ntype K8sAuthenticator struct {\n    client      *vault.Client\n    role        string\n    tokenPath   string\n    mountPath   string\n}\n\ntype K8sAuthConfig struct {\n    VaultAddr  string // https://vault:8200\n    Role       string // prism-service\n    TokenPath  string // Optional, defaults to k8sTokenPath\n    MountPath  string // auth/kubernetes\n}\n\nfunc NewK8sAuthenticator(config K8sAuthConfig) (*K8sAuthenticator, error) {\n    vaultConfig := vault.DefaultConfig()\n    vaultConfig.Address = config.VaultAddr\n\n    client, err := vault.NewClient(vaultConfig)\n    if err != nil {\n        return nil, fmt.Errorf("failed to create Vault client: %w", err)\n    }\n\n    tokenPath := config.TokenPath\n    if tokenPath == "" {\n        tokenPath = k8sTokenPath\n    }\n\n    return &K8sAuthenticator{\n        client:    client,\n        role:      config.Role,\n        tokenPath: tokenPath,\n        mountPath: config.MountPath,\n    }, nil\n}\n\n// AuthenticateServiceAccount exchanges K8s SA token for Vault token\nfunc (k *K8sAuthenticator) AuthenticateServiceAccount(ctx context.Context) (string, time.Duration, error) {\n    // Read service account token\n    saToken, err := os.ReadFile(k.tokenPath)\n    if err != nil {\n        return "", 0, fmt.Errorf("failed to read service account token: %w", err)\n    }\n\n    // Prepare authentication request\n    authPath := fmt.Sprintf("%s/login", k.mountPath)\n    data := map[string]interface{}{\n        "jwt":  string(saToken),\n        "role": k.role,\n    }\n\n    // Authenticate to Vault\n    secret, err := k.client.Logical().WriteWithContext(ctx, authPath, data)\n    if err != nil {\n        return "", 0, fmt.Errorf("K8s authentication failed: %w", err)\n    }\n\n    if secret == nil || secret.Auth == nil {\n        return "", 0, fmt.Errorf("no auth data in response")\n    }\n\n    // Extract Vault token\n    vaultToken := secret.Auth.ClientToken\n    leaseDuration := time.Duration(secret.Auth.LeaseDuration) * time.Second\n\n    // Set token on client\n    k.client.SetToken(vaultToken)\n\n    return vaultToken, leaseDuration, nil\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"aws-iam-role-authentication",children:"AWS IAM Role Authentication"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// pkg/authz/aws_auth.go\npackage authz\n\nimport (\n    "context"\n    "fmt"\n    "time"\n\n    vault "github.com/hashicorp/vault/api"\n    "github.com/aws/aws-sdk-go/aws/session"\n    "github.com/aws/aws-sdk-go/service/sts"\n)\n\ntype AWSAuthenticator struct {\n    client    *vault.Client\n    role      string\n    mountPath string\n}\n\ntype AWSAuthConfig struct {\n    VaultAddr string // https://vault:8200\n    Role      string // prism-service-role\n    MountPath string // auth/aws\n}\n\nfunc NewAWSAuthenticator(config AWSAuthConfig) (*AWSAuthenticator, error) {\n    vaultConfig := vault.DefaultConfig()\n    vaultConfig.Address = config.VaultAddr\n\n    client, err := vault.NewClient(vaultConfig)\n    if err != nil {\n        return nil, fmt.Errorf("failed to create Vault client: %w", err)\n    }\n\n    return &AWSAuthenticator{\n        client:    client,\n        role:      config.Role,\n        mountPath: config.MountPath,\n    }, nil\n}\n\n// AuthenticateIAMRole exchanges AWS IAM role for Vault token\nfunc (a *AWSAuthenticator) AuthenticateIAMRole(ctx context.Context) (string, time.Duration, error) {\n    // Get AWS session (uses IAM role credentials automatically)\n    sess := session.Must(session.NewSession())\n    stsClient := sts.New(sess)\n\n    // Get caller identity to prove IAM role\n    identity, err := stsClient.GetCallerIdentityWithContext(ctx, &sts.GetCallerIdentityInput{})\n    if err != nil {\n        return "", 0, fmt.Errorf("failed to get AWS caller identity: %w", err)\n    }\n\n    // Prepare authentication request\n    authPath := fmt.Sprintf("%s/login", a.mountPath)\n    data := map[string]interface{}{\n        "role":              a.role,\n        "iam_http_request_method": "POST",\n        "iam_request_url":   "https://sts.amazonaws.com/",\n        "iam_request_body":  "Action=GetCallerIdentity&Version=2011-06-15",\n        // AWS SigV4 headers would be added here\n    }\n\n    // Authenticate to Vault\n    secret, err := a.client.Logical().WriteWithContext(ctx, authPath, data)\n    if err != nil {\n        return "", 0, fmt.Errorf("AWS authentication failed: %w", err)\n    }\n\n    if secret == nil || secret.Auth == nil {\n        return "", 0, fmt.Errorf("no auth data in response")\n    }\n\n    vaultToken := secret.Auth.ClientToken\n    leaseDuration := time.Duration(secret.Auth.LeaseDuration) * time.Second\n\n    a.client.SetToken(vaultToken)\n\n    return vaultToken, leaseDuration, nil\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"service-identity-propagation",children:"Service Identity Propagation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// pkg/authz/service_identity.go\npackage authz\n\nimport (\n    "context"\n    "fmt"\n\n    "google.golang.org/grpc/metadata"\n)\n\nconst (\n    // Metadata key for service identity\n    ServiceIdentityKey = "x-service-identity"\n)\n\n// ServiceIdentity represents a service\'s identity\ntype ServiceIdentity struct {\n    ServiceName string\n    Namespace   string\n    ClusterName string\n}\n\n// ExtractServiceIdentity extracts service identity from gRPC metadata\nfunc ExtractServiceIdentity(ctx context.Context) (*ServiceIdentity, error) {\n    md, ok := metadata.FromIncomingContext(ctx)\n    if !ok {\n        return nil, fmt.Errorf("no metadata in request")\n    }\n\n    // Check for service identity header\n    identityHeaders := md.Get(ServiceIdentityKey)\n    if len(identityHeaders) == 0 {\n        return nil, fmt.Errorf("no service identity header")\n    }\n\n    // Parse service identity\n    // Format: "service-name.namespace.cluster"\n    identity := identityHeaders[0]\n\n    // Simple parsing (could be more sophisticated)\n    return &ServiceIdentity{\n        ServiceName: identity,\n    }, nil\n}\n\n// InjectServiceIdentity adds service identity to outgoing gRPC metadata\nfunc InjectServiceIdentity(ctx context.Context, identity *ServiceIdentity) context.Context {\n    md := metadata.Pairs(\n        ServiceIdentityKey, identity.ServiceName,\n    )\n\n    return metadata.NewOutgoingContext(ctx, md)\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"service-session-manager",children:"Service Session Manager"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// pkg/authz/service_session.go\npackage authz\n\nimport (\n    "context"\n    "fmt"\n    "sync"\n\n    "github.com/go-redis/redis/v8"\n)\n\n// ServiceSessionManager manages service-to-service sessions\ntype ServiceSessionManager struct {\n    k8sAuth     *K8sAuthenticator\n    awsAuth     *AWSAuthenticator\n    vault       *VaultClient\n    connections map[string]*redis.Client\n    mu          sync.RWMutex\n}\n\nfunc NewServiceSessionManager(k8s *K8sAuthenticator, aws *AWSAuthenticator, vault *VaultClient) *ServiceSessionManager {\n    return &ServiceSessionManager{\n        k8sAuth:     k8s,\n        awsAuth:     aws,\n        vault:       vault,\n        connections: make(map[string]*redis.Client),\n    }\n}\n\n// CreateServiceSession establishes service session with appropriate auth method\nfunc (ssm *ServiceSessionManager) CreateServiceSession(ctx context.Context, serviceID string) (*redis.Client, error) {\n    // Check if session already exists\n    ssm.mu.RLock()\n    if client, ok := ssm.connections[serviceID]; ok {\n        ssm.mu.RUnlock()\n        return client, nil\n    }\n    ssm.mu.RUnlock()\n\n    // Authenticate to Vault based on environment\n    var vaultToken string\n    var leaseDuration time.Duration\n    var err error\n\n    // Try Kubernetes first (most common for Prism services)\n    if ssm.k8sAuth != nil {\n        vaultToken, leaseDuration, err = ssm.k8sAuth.AuthenticateServiceAccount(ctx)\n        if err == nil {\n            goto authenticated\n        }\n    }\n\n    // Try AWS IAM role\n    if ssm.awsAuth != nil {\n        vaultToken, leaseDuration, err = ssm.awsAuth.AuthenticateIAMRole(ctx)\n        if err == nil {\n            goto authenticated\n        }\n    }\n\n    return nil, fmt.Errorf("all service authentication methods failed")\n\nauthenticated:\n    // Set Vault token on client\n    ssm.vault.client.SetToken(vaultToken)\n\n    // Fetch backend credentials\n    creds, err := ssm.vault.GetBackendCredentials(ctx)\n    if err != nil {\n        return nil, fmt.Errorf("failed to get credentials: %w", err)\n    }\n\n    // Establish backend connection\n    redisClient := redis.NewClient(&redis.Options{\n        Addr:     "localhost:6379",\n        Username: creds.Username,\n        Password: creds.Password,\n        DB:       0,\n    })\n\n    // Test connection\n    if err := redisClient.Ping(ctx).Err(); err != nil {\n        redisClient.Close()\n        return nil, fmt.Errorf("Redis connection failed: %w", err)\n    }\n\n    // Start credential renewal\n    sessionCtx, cancel := context.WithCancel(context.Background())\n    go func() {\n        ssm.vault.StartCredentialRenewal(sessionCtx, creds)\n    }()\n\n    // Store connection\n    ssm.mu.Lock()\n    ssm.connections[serviceID] = redisClient\n    ssm.mu.Unlock()\n\n    return redisClient, nil\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"vault-configuration-for-service-authentication",children:"Vault Configuration for Service Authentication"}),"\n",(0,r.jsx)(n.h4,{id:"kubernetes-auth-method",children:"Kubernetes Auth Method"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# Enable Kubernetes auth method\nvault auth enable kubernetes\n\n# Configure Kubernetes auth with API server\nvault write auth/kubernetes/config \\\n    kubernetes_host="https://kubernetes.default.svc:443" \\\n    kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt \\\n    token_reviewer_jwt=@/var/run/secrets/kubernetes.io/serviceaccount/token\n\n# Create role for Prism services\nvault write auth/kubernetes/role/prism-service \\\n    bound_service_account_names="prism-aggregator,prism-worker" \\\n    bound_service_account_namespaces="prism-system" \\\n    token_ttl="1h" \\\n    token_max_ttl="2h" \\\n    token_policies="prism-service-policy"\n'})}),"\n",(0,r.jsx)(n.h4,{id:"aws-iam-auth-method",children:"AWS IAM Auth Method"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# Enable AWS auth method\nvault auth enable aws\n\n# Configure AWS auth\nvault write auth/aws/config/client \\\n    access_key="AKIA..." \\\n    secret_key="..." \\\n    region="us-west-2"\n\n# Create role for EC2 instances\nvault write auth/aws/role/prism-service-role \\\n    auth_type="iam" \\\n    bound_iam_principal_arn="arn:aws:iam::123456789012:role/prism-service" \\\n    token_ttl="1h" \\\n    token_max_ttl="2h" \\\n    token_policies="prism-service-policy"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"service-vs-human-authentication-comparison",children:"Service vs Human Authentication Comparison"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Aspect"}),(0,r.jsx)(n.th,{children:"Human-Originated"}),(0,r.jsx)(n.th,{children:"Service-Originated"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Identity Source"})}),(0,r.jsx)(n.td,{children:"OIDC provider (Dex, Auth0)"}),(0,r.jsx)(n.td,{children:"Platform (K8s SA, IAM role)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Token Format"})}),(0,r.jsx)(n.td,{children:"User JWT (email, groups)"}),(0,r.jsx)(n.td,{children:"Service JWT (service name, namespace)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Credential Username"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"v-jwt-alice-abc123"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"v-k8s-prism-aggregator-xyz"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Session Lifetime"})}),(0,r.jsx)(n.td,{children:"Variable (user session)"}),(0,r.jsx)(n.td,{children:"Long-lived (service uptime)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Audit Logging"})}),(0,r.jsx)(n.td,{children:"User email in backend logs"}),(0,r.jsx)(n.td,{children:"Service name in backend logs"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Revocation"})}),(0,r.jsx)(n.td,{children:"On user logout"}),(0,r.jsx)(n.td,{children:"On service shutdown"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Common Use Cases"})}),(0,r.jsx)(n.td,{children:"Interactive applications"}),(0,r.jsx)(n.td,{children:"Background jobs, aggregators, ETL"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"implementation-details-human-originated",children:"Implementation Details (Human-Originated)"}),"\n",(0,r.jsx)(n.h3,{id:"step-1-extract-jwt-from-grpc-metadata",children:"Step 1: Extract JWT from gRPC Metadata"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// pkg/authz/token_extractor.go\npackage authz\n\nimport (\n    "context"\n    "fmt"\n    "strings"\n\n    "google.golang.org/grpc/metadata"\n)\n\n// ExtractToken extracts JWT token from gRPC metadata\nfunc ExtractToken(ctx context.Context) (string, error) {\n    md, ok := metadata.FromIncomingContext(ctx)\n    if !ok {\n        return "", fmt.Errorf("no metadata in request")\n    }\n\n    // Check Authorization header (Bearer token)\n    authHeaders := md.Get("authorization")\n    if len(authHeaders) == 0 {\n        return "", fmt.Errorf("no authorization header")\n    }\n\n    // Extract token from "Bearer <token>"\n    authHeader := authHeaders[0]\n    if !strings.HasPrefix(authHeader, "Bearer ") {\n        return "", fmt.Errorf("invalid authorization header format")\n    }\n\n    token := strings.TrimPrefix(authHeader, "Bearer ")\n    if token == "" {\n        return "", fmt.Errorf("empty token")\n    }\n\n    return token, nil\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"step-2-validate-jwt-token",children:"Step 2: Validate JWT Token"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// pkg/authz/token_validator.go\npackage authz\n\nimport (\n    "context"\n    "fmt"\n    "time"\n\n    "github.com/coreos/go-oidc/v3/oidc"\n    "github.com/golang-jwt/jwt/v5"\n)\n\ntype TokenValidator struct {\n    issuer   string\n    audience string\n    verifier *oidc.IDTokenVerifier\n}\n\ntype Claims struct {\n    UserID    string    `json:"sub"`\n    Email     string    `json:"email"`\n    Groups    []string  `json:"groups"`\n    ExpiresAt time.Time `json:"exp"`\n    IssuedAt  time.Time `json:"iat"`\n    Issuer    string    `json:"iss"`\n}\n\nfunc NewTokenValidator(issuer, audience string) (*TokenValidator, error) {\n    ctx := context.Background()\n\n    // Initialize OIDC provider\n    provider, err := oidc.NewProvider(ctx, issuer)\n    if err != nil {\n        return nil, fmt.Errorf("failed to create OIDC provider: %w", err)\n    }\n\n    // Create verifier\n    verifier := provider.Verifier(&oidc.Config{\n        ClientID: audience,\n    })\n\n    return &TokenValidator{\n        issuer:   issuer,\n        audience: audience,\n        verifier: verifier,\n    }, nil\n}\n\nfunc (v *TokenValidator) Validate(ctx context.Context, tokenString string) (*Claims, error) {\n    // Verify token with OIDC provider\n    idToken, err := v.verifier.Verify(ctx, tokenString)\n    if err != nil {\n        return nil, fmt.Errorf("token verification failed: %w", err)\n    }\n\n    // Extract claims\n    var claims Claims\n    if err := idToken.Claims(&claims); err != nil {\n        return nil, fmt.Errorf("failed to parse claims: %w", err)\n    }\n\n    // Additional validation\n    if claims.UserID == "" {\n        return nil, fmt.Errorf("missing subject (sub) claim")\n    }\n\n    if time.Now().After(claims.ExpiresAt) {\n        return nil, fmt.Errorf("token expired at %v", claims.ExpiresAt)\n    }\n\n    return &claims, nil\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"step-3-exchange-jwt-for-vault-token",children:"Step 3: Exchange JWT for Vault Token"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// pkg/authz/vault_client.go\npackage authz\n\nimport (\n    "context"\n    "fmt"\n    "time"\n\n    vault "github.com/hashicorp/vault/api"\n)\n\ntype VaultClient struct {\n    client *vault.Client\n    config VaultConfig\n}\n\ntype VaultConfig struct {\n    Address       string        // https://vault:8200\n    Namespace     string        // Optional Vault namespace\n    Role          string        // JWT auth role (prism-redis)\n    AuthPath      string        // JWT auth mount path (auth/jwt)\n    SecretPath    string        // Secret engine path (database/creds/redis-role)\n    RenewInterval time.Duration // Renew credentials every X (default: lease/2)\n    TLS           TLSConfig     // TLS configuration\n}\n\ntype TLSConfig struct {\n    Enabled  bool\n    CACert   string // Path to CA certificate\n    SkipVerify bool // Skip TLS verification (dev only)\n}\n\nfunc NewVaultClient(config VaultConfig) (*VaultClient, error) {\n    // Create Vault client config\n    vaultConfig := vault.DefaultConfig()\n    vaultConfig.Address = config.Address\n\n    // Configure TLS if enabled\n    if config.TLS.Enabled {\n        tlsConfig := &vault.TLSConfig{\n            CACert: config.TLS.CACert,\n            Insecure: config.TLS.SkipVerify,\n        }\n        if err := vaultConfig.ConfigureTLS(tlsConfig); err != nil {\n            return nil, fmt.Errorf("failed to configure TLS: %w", err)\n        }\n    }\n\n    // Create client\n    client, err := vault.NewClient(vaultConfig)\n    if err != nil {\n        return nil, fmt.Errorf("failed to create Vault client: %w", err)\n    }\n\n    // Set namespace if provided\n    if config.Namespace != "" {\n        client.SetNamespace(config.Namespace)\n    }\n\n    return &VaultClient{\n        client: client,\n        config: config,\n    }, nil\n}\n\n// AuthenticateWithJWT exchanges user JWT for Vault token\nfunc (v *VaultClient) AuthenticateWithJWT(ctx context.Context, userJWT string) (string, time.Duration, error) {\n    // Prepare JWT auth request\n    authPath := fmt.Sprintf("%s/login", v.config.AuthPath)\n    data := map[string]interface{}{\n        "jwt":  userJWT,\n        "role": v.config.Role,\n    }\n\n    // Authenticate to Vault\n    secret, err := v.client.Logical().WriteWithContext(ctx, authPath, data)\n    if err != nil {\n        return "", 0, fmt.Errorf("JWT authentication failed: %w", err)\n    }\n\n    if secret == nil || secret.Auth == nil {\n        return "", 0, fmt.Errorf("no auth data in response")\n    }\n\n    // Extract Vault token and lease duration\n    vaultToken := secret.Auth.ClientToken\n    leaseDuration := time.Duration(secret.Auth.LeaseDuration) * time.Second\n\n    // Set token on client\n    v.client.SetToken(vaultToken)\n\n    return vaultToken, leaseDuration, nil\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"step-4-fetch-backend-credentials",children:"Step 4: Fetch Backend Credentials"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// pkg/authz/vault_credentials.go\npackage authz\n\nimport (\n    "context"\n    "fmt"\n    "time"\n)\n\ntype BackendCredentials struct {\n    Username      string\n    Password      string\n    LeaseID       string\n    LeaseDuration time.Duration\n    VaultToken    string\n    RenewedAt     time.Time\n}\n\n// GetBackendCredentials fetches dynamic credentials from Vault\nfunc (v *VaultClient) GetBackendCredentials(ctx context.Context) (*BackendCredentials, error) {\n    // Read credentials from Vault secret engine\n    secret, err := v.client.Logical().ReadWithContext(ctx, v.config.SecretPath)\n    if err != nil {\n        return nil, fmt.Errorf("failed to read credentials: %w", err)\n    }\n\n    if secret == nil || secret.Data == nil {\n        return nil, fmt.Errorf("no credential data in response")\n    }\n\n    // Extract credentials\n    username, ok := secret.Data["username"].(string)\n    if !ok {\n        return nil, fmt.Errorf("username not found in response")\n    }\n\n    password, ok := secret.Data["password"].(string)\n    if !ok {\n        return nil, fmt.Errorf("password not found in response")\n    }\n\n    leaseDuration := time.Duration(secret.LeaseDuration) * time.Second\n\n    creds := &BackendCredentials{\n        Username:      username,\n        Password:      password,\n        LeaseID:       secret.LeaseID,\n        LeaseDuration: leaseDuration,\n        VaultToken:    v.client.Token(),\n        RenewedAt:     time.Now(),\n    }\n\n    return creds, nil\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"step-5-background-credential-renewal",children:"Step 5: Background Credential Renewal"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// pkg/authz/vault_renewal.go\npackage authz\n\nimport (\n    "context"\n    "log"\n    "time"\n)\n\n// StartCredentialRenewal starts background goroutine to renew credentials\nfunc (v *VaultClient) StartCredentialRenewal(ctx context.Context, creds *BackendCredentials) {\n    // Calculate renewal interval (half of lease duration)\n    renewInterval := creds.LeaseDuration / 2\n    if v.config.RenewInterval > 0 {\n        renewInterval = v.config.RenewInterval\n    }\n\n    ticker := time.NewTicker(renewInterval)\n    defer ticker.Stop()\n\n    log.Printf("Starting credential renewal (interval: %v, lease_id: %s)",\n        renewInterval, creds.LeaseID)\n\n    for {\n        select {\n        case <-ctx.Done():\n            log.Printf("Stopping credential renewal: context cancelled")\n            return\n\n        case <-ticker.C:\n            if err := v.renewCredentials(ctx, creds); err != nil {\n                log.Printf("Failed to renew credentials: %v", err)\n                // Continue trying - don\'t exit on error\n                continue\n            }\n\n            log.Printf("Successfully renewed credentials (lease_id: %s)", creds.LeaseID)\n        }\n    }\n}\n\nfunc (v *VaultClient) renewCredentials(ctx context.Context, creds *BackendCredentials) error {\n    // Renew Vault token first\n    tokenSecret, err := v.client.Auth().Token().RenewSelfWithContext(\n        ctx,\n        int(creds.LeaseDuration.Seconds()),\n    )\n    if err != nil {\n        return fmt.Errorf("failed to renew Vault token: %w", err)\n    }\n\n    log.Printf("Renewed Vault token (new lease: %ds)", tokenSecret.Auth.LeaseDuration)\n\n    // Renew backend credentials lease\n    leaseSecret, err := v.client.Logical().WriteWithContext(\n        ctx,\n        "/sys/leases/renew",\n        map[string]interface{}{\n            "lease_id": creds.LeaseID,\n            "increment": int(creds.LeaseDuration.Seconds()),\n        },\n    )\n    if err != nil {\n        return fmt.Errorf("failed to renew credential lease: %w", err)\n    }\n\n    // Update lease duration if changed\n    if leaseSecret != nil {\n        creds.LeaseDuration = time.Duration(leaseSecret.LeaseDuration) * time.Second\n        creds.RenewedAt = time.Now()\n    }\n\n    return nil\n}\n\n// RevokeCredentials revokes Vault lease (cleanup on session end)\nfunc (v *VaultClient) RevokeCredentials(ctx context.Context, leaseID string) error {\n    _, err := v.client.Logical().WriteWithContext(\n        ctx,\n        "/sys/leases/revoke",\n        map[string]interface{}{\n            "lease_id": leaseID,\n        },\n    )\n\n    if err != nil {\n        return fmt.Errorf("failed to revoke lease %s: %w", leaseID, err)\n    }\n\n    log.Printf("Revoked Vault lease: %s", leaseID)\n    return nil\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"step-6-complete-plugin-integration",children:"Step 6: Complete Plugin Integration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// patterns/redis/session.go\npackage main\n\nimport (\n    "context"\n    "fmt"\n    "sync"\n\n    "github.com/go-redis/redis/v8"\n    "github.com/prism/pattern-sdk/authz"\n)\n\n// PluginSession represents a single client session with credentials\ntype PluginSession struct {\n    SessionID   string\n    UserID      string\n    Claims      *authz.Claims\n    Credentials *authz.BackendCredentials\n    RedisClient *redis.Client\n    CancelFunc  context.CancelFunc\n\n    mu sync.RWMutex\n}\n\n// SessionManager manages per-session credentials and connections\ntype SessionManager struct {\n    validator *authz.TokenValidator\n    vault     *authz.VaultClient\n    sessions  map[string]*PluginSession\n    mu        sync.RWMutex\n}\n\nfunc NewSessionManager(validator *authz.TokenValidator, vault *authz.VaultClient) *SessionManager {\n    return &SessionManager{\n        validator: validator,\n        vault:     vault,\n        sessions:  make(map[string]*PluginSession),\n    }\n}\n\n// CreateSession establishes new session with token exchange\nfunc (sm *SessionManager) CreateSession(ctx context.Context, sessionID, token string) (*PluginSession, error) {\n    // Step 1: Validate JWT token\n    claims, err := sm.validator.Validate(ctx, token)\n    if err != nil {\n        return nil, fmt.Errorf("token validation failed: %w", err)\n    }\n\n    // Step 2: Exchange JWT for Vault token\n    vaultToken, leaseDuration, err := sm.vault.AuthenticateWithJWT(ctx, token)\n    if err != nil {\n        return nil, fmt.Errorf("Vault authentication failed: %w", err)\n    }\n\n    // Step 3: Fetch backend credentials\n    creds, err := sm.vault.GetBackendCredentials(ctx)\n    if err != nil {\n        return nil, fmt.Errorf("failed to get credentials: %w", err)\n    }\n\n    // Step 4: Establish Redis connection with dynamic credentials\n    redisClient := redis.NewClient(&redis.Options{\n        Addr:     "localhost:6379",\n        Username: creds.Username,\n        Password: creds.Password,\n        DB:       0,\n    })\n\n    // Test connection\n    if err := redisClient.Ping(ctx).Err(); err != nil {\n        redisClient.Close()\n        return nil, fmt.Errorf("Redis connection failed: %w", err)\n    }\n\n    // Create session context for renewal goroutine\n    sessionCtx, cancel := context.WithCancel(context.Background())\n\n    session := &PluginSession{\n        SessionID:   sessionID,\n        UserID:      claims.UserID,\n        Claims:      claims,\n        Credentials: creds,\n        RedisClient: redisClient,\n        CancelFunc:  cancel,\n    }\n\n    // Step 5: Start background credential renewal\n    go sm.vault.StartCredentialRenewal(sessionCtx, creds)\n\n    // Store session\n    sm.mu.Lock()\n    sm.sessions[sessionID] = session\n    sm.mu.Unlock()\n\n    return session, nil\n}\n\n// GetSession retrieves existing session\nfunc (sm *SessionManager) GetSession(sessionID string) (*PluginSession, error) {\n    sm.mu.RLock()\n    defer sm.mu.RUnlock()\n\n    session, ok := sm.sessions[sessionID]\n    if !ok {\n        return nil, fmt.Errorf("session not found: %s", sessionID)\n    }\n\n    return session, nil\n}\n\n// CloseSession terminates session and revokes credentials\nfunc (sm *SessionManager) CloseSession(ctx context.Context, sessionID string) error {\n    sm.mu.Lock()\n    session, ok := sm.sessions[sessionID]\n    if !ok {\n        sm.mu.Unlock()\n        return fmt.Errorf("session not found: %s", sessionID)\n    }\n    delete(sm.sessions, sessionID)\n    sm.mu.Unlock()\n\n    // Stop renewal goroutine\n    session.CancelFunc()\n\n    // Close Redis connection\n    if err := session.RedisClient.Close(); err != nil {\n        return fmt.Errorf("failed to close Redis connection: %w", err)\n    }\n\n    // Revoke Vault lease\n    if err := sm.vault.RevokeCredentials(ctx, session.Credentials.LeaseID); err != nil {\n        return fmt.Errorf("failed to revoke Vault lease: %w", err)\n    }\n\n    return nil\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"vault-configuration",children:"Vault Configuration"}),"\n",(0,r.jsx)(n.h3,{id:"jwt-auth-method-setup",children:"JWT Auth Method Setup"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# Enable JWT auth method\nvault auth enable jwt\n\n# Configure JWT auth with OIDC provider\nvault write auth/jwt/config \\\n    oidc_discovery_url="https://auth.prism.io" \\\n    default_role="prism-redis"\n\n# Create role for Redis pattern provider\nvault write auth/jwt/role/prism-redis \\\n    role_type="jwt" \\\n    bound_audiences="prism-patterns" \\\n    user_claim="sub" \\\n    groups_claim="groups" \\\n    token_ttl="1h" \\\n    token_max_ttl="2h" \\\n    token_policies="prism-redis"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"database-secrets-engine-setup",children:"Database Secrets Engine Setup"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# Enable database secrets engine\nvault secrets enable database\n\n# Configure Redis connection\nvault write database/config/redis \\\n    plugin_name="redis-database-plugin" \\\n    host="redis" \\\n    port=6379 \\\n    username="vault-admin" \\\n    password="admin-password" \\\n    allowed_roles="redis-role"\n\n# Create role for dynamic credentials\nvault write database/roles/redis-role \\\n    db_name="redis" \\\n    creation_statements=\'["ACL SETUSER {{username}} on >{{password}} ~* +@all"]\' \\\n    revocation_statements=\'["ACL DELUSER {{username}}"]\' \\\n    default_ttl="1h" \\\n    max_ttl="2h"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"vault-policy",children:"Vault Policy"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'# Policy for Redis pattern provider\npath "auth/token/renew-self" {\n  capabilities = ["update"]\n}\n\npath "sys/leases/renew" {\n  capabilities = ["update"]\n}\n\npath "database/creds/redis-role" {\n  capabilities = ["read"]\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Apply policy:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"vault policy write prism-redis prism-redis.hcl\n"})}),"\n",(0,r.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsx)(n.h3,{id:"common-failure-scenarios",children:"Common Failure Scenarios"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"JWT Validation Fails"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Check: Token expiry, issuer, audience claims"}),"\n",(0,r.jsx)(n.li,{children:"Action: Return 401 Unauthenticated to client"}),"\n",(0,r.jsx)(n.li,{children:"Log: Token validation error with reason"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Vault Authentication Fails"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Check: JWT role binding, Vault connectivity"}),"\n",(0,r.jsx)(n.li,{children:"Action: Return 503 Service Unavailable"}),"\n",(0,r.jsx)(n.li,{children:"Log: Vault authentication error"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Credential Fetch Fails"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Check: Vault token validity, database secrets engine"}),"\n",(0,r.jsx)(n.li,{children:"Action: Return 503 Service Unavailable"}),"\n",(0,r.jsx)(n.li,{children:"Log: Credential fetch error"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Backend Connection Fails"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Check: Credentials correctness, backend availability"}),"\n",(0,r.jsx)(n.li,{children:"Action: Retry with exponential backoff (3 attempts)"}),"\n",(0,r.jsx)(n.li,{children:"Log: Backend connection error"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Credential Renewal Fails"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Check: Vault token validity, lease expiry"}),"\n",(0,r.jsx)(n.li,{children:"Action: Continue retrying, alert if consecutive failures > 3"}),"\n",(0,r.jsx)(n.li,{children:"Log: Renewal failure with lease_id"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"retry-logic-example",children:"Retry Logic Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'func connectWithRetry(ctx context.Context, creds *authz.BackendCredentials, maxRetries int) (*redis.Client, error) {\n    var client *redis.Client\n    var lastErr error\n\n    backoff := time.Second\n\n    for i := 0; i < maxRetries; i++ {\n        client = redis.NewClient(&redis.Options{\n            Addr:     "localhost:6379",\n            Username: creds.Username,\n            Password: creds.Password,\n        })\n\n        if err := client.Ping(ctx).Err(); err == nil {\n            return client, nil\n        } else {\n            lastErr = err\n            client.Close()\n\n            if i < maxRetries-1 {\n                log.Printf("Connection attempt %d failed: %v, retrying in %v",\n                    i+1, err, backoff)\n                time.Sleep(backoff)\n                backoff *= 2 // Exponential backoff\n            }\n        }\n    }\n\n    return nil, fmt.Errorf("failed after %d attempts: %w", maxRetries, lastErr)\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"token-validation-caching",children:"Token Validation Caching"}),"\n",(0,r.jsx)(n.p,{children:"Cache JWKS public keys to avoid fetching on every validation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"type CachedValidator struct {\n    validator *authz.TokenValidator\n    cache     *sync.Map\n    cacheTTL  time.Duration\n}\n\ntype cachedToken struct {\n    claims    *authz.Claims\n    expiresAt time.Time\n}\n\nfunc (cv *CachedValidator) Validate(ctx context.Context, token string) (*authz.Claims, error) {\n    // Check cache first (keyed by token hash)\n    tokenHash := sha256Hash(token)\n\n    if cached, ok := cv.cache.Load(tokenHash); ok {\n        ct := cached.(cachedToken)\n        if time.Now().Before(ct.expiresAt) {\n            return ct.claims, nil\n        }\n        cv.cache.Delete(tokenHash)\n    }\n\n    // Validate token\n    claims, err := cv.validator.Validate(ctx, token)\n    if err != nil {\n        return nil, err\n    }\n\n    // Cache for shorter of: token expiry or cache TTL\n    cacheExpiry := time.Now().Add(cv.cacheTTL)\n    if claims.ExpiresAt.Before(cacheExpiry) {\n        cacheExpiry = claims.ExpiresAt\n    }\n\n    cv.cache.Store(tokenHash, cachedToken{\n        claims:    claims,\n        expiresAt: cacheExpiry,\n    })\n\n    return claims, nil\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"connection-pooling",children:"Connection Pooling"}),"\n",(0,r.jsx)(n.p,{children:"Maintain connection pool per session (not per request):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'type SessionConnectionPool struct {\n    pools map[string]*redis.Client\n    mu    sync.RWMutex\n}\n\nfunc (scp *SessionConnectionPool) GetConnection(sessionID string) (*redis.Client, error) {\n    scp.mu.RLock()\n    client, ok := scp.pools[sessionID]\n    scp.mu.RUnlock()\n\n    if ok {\n        return client, nil\n    }\n\n    return nil, fmt.Errorf("no connection for session %s", sessionID)\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"security-best-practices",children:"Security Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Never Log Credentials"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Log lease_id, username, but NEVER passwords or tokens"}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"[REDACTED]"})," placeholder in logs"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Secure Token Transmission"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Always use TLS for gRPC connections"}),"\n",(0,r.jsx)(n.li,{children:"Verify client certificates (mTLS) in production"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Vault Token Rotation"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Renew Vault tokens every lease_duration/2"}),"\n",(0,r.jsx)(n.li,{children:"Use short TTLs (1h default)"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Credential Isolation"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Each session gets unique credentials"}),"\n",(0,r.jsx)(n.li,{children:"Backend ACLs enforce user-specific permissions"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Lease Revocation"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Always revoke leases on session close"}),"\n",(0,r.jsx)(n.li,{children:"Implement timeout for idle sessions"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"related-documents",children:"Related Documents"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/rfc/rfc-019",children:"RFC-019: Pattern SDK Authorization Layer"})," - Authorization architecture"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/rfc/rfc-011-data-proxy-authentication",children:"RFC-011: Data Proxy Authentication"})," - Secrets provider abstraction"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/adr/adr-050-topaz-policy-authorization",children:"ADR-050: Topaz for Policy Authorization"})," - Policy enforcement"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'2025-10-11: Updated terminology from "Plugin SDK" to "Pattern SDK" for consistency with RFC-022'}),"\n",(0,r.jsx)(n.li,{children:"2025-10-10: Added service-originated request flow (K8s SA, AWS IAM, Azure MI, GCP SA authentication)"}),"\n",(0,r.jsx)(n.li,{children:"2025-10-09: Initial memo documenting Vault token exchange flow for human-originated requests"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var i=t(96540);const r={},a=i.createContext(r);function s(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);