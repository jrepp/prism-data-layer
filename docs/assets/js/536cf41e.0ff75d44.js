"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[1798],{5587:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>p,frontMatter:()=>i,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"rfc-011","title":"Data Proxy Authentication (Input/Output)","description":"Abstract","source":"@site/../docs-cms/rfcs/rfc-011-data-proxy-authentication.md","sourceDirName":".","slug":"/rfc-011","permalink":"/prism-data-layer/rfc/rfc-011","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/rfcs/rfc-011-data-proxy-authentication.md","tags":[{"inline":true,"label":"authentication","permalink":"/prism-data-layer/rfc/tags/authentication"},{"inline":true,"label":"mtls","permalink":"/prism-data-layer/rfc/tags/mtls"},{"inline":true,"label":"proxy","permalink":"/prism-data-layer/rfc/tags/proxy"},{"inline":true,"label":"backends","permalink":"/prism-data-layer/rfc/tags/backends"},{"inline":true,"label":"security","permalink":"/prism-data-layer/rfc/tags/security"}],"version":"current","frontMatter":{"author":"Platform Team","created":"2025-10-09T00:00:00.000Z","doc_uuid":"7c8693e5-6401-4934-afb9-617b3c5c7e9b","id":"rfc-011","project_id":"prism-data-layer","status":"Proposed","tags":["authentication","mtls","proxy","backends","security"],"title":"Data Proxy Authentication (Input/Output)","updated":"2025-10-09T00:00:00.000Z"},"sidebar":"rfcSidebar","previous":{"title":"Admin Protocol with OIDC Authentication \u2022 RFC-010","permalink":"/prism-data-layer/rfc/rfc-010"},"next":{"title":"Prism Network Gateway (prism-netgw) - Multi-Region Control Plane \u2022 RFC-012","permalink":"/prism-data-layer/rfc/rfc-012"}}');var a=r(74848),s=r(28453);const i={author:"Platform Team",created:new Date("2025-10-09T00:00:00.000Z"),doc_uuid:"7c8693e5-6401-4934-afb9-617b3c5c7e9b",id:"rfc-011",project_id:"prism-data-layer",status:"Proposed",tags:["authentication","mtls","proxy","backends","security"],title:"Data Proxy Authentication (Input/Output)",updated:new Date("2025-10-09T00:00:00.000Z")},c=void 0,l={},o=[{value:"Abstract",id:"abstract",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Input Authentication (Client \u2192 Proxy)",id:"input-authentication-client--proxy",level:2},{value:"mTLS Certificate-Based Authentication",id:"mtls-certificate-based-authentication",level:3},{value:"Certificate Structure",id:"certificate-structure",level:3},{value:"Rust Implementation",id:"rust-implementation",level:3},{value:"Request Flow with mTLS",id:"request-flow-with-mtls",level:3},{value:"Certificate Rotation",id:"certificate-rotation",level:3},{value:"Output Authentication (Proxy \u2192 Backend)",id:"output-authentication-proxy--backend",level:2},{value:"Per-Backend Authentication Strategies",id:"per-backend-authentication-strategies",level:3},{value:"Credential Rotation",id:"credential-rotation",level:3}];function d(e){const n={a:"a",backendcredentials:"backendcredentials",code:"code",credentials:"credentials",dyn:"dyn",h1:"h1",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",string:"string",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",utc:"utc",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"abstract",children:"Abstract"}),"\n",(0,a.jsxs)(n.p,{children:["This RFC specifies the complete authentication model for Prism's data proxy, covering both ",(0,a.jsx)(n.strong,{children:"input authentication"})," (how clients authenticate to the proxy) and ",(0,a.jsx)(n.strong,{children:"output authentication"})," (how the proxy authenticates to backend data stores). The design emphasizes mTLS for service-to-service communication, certificate management, and secure backend connectivity."]}),"\n",(0,a.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,a.jsx)(n.p,{children:"The Prism data proxy sits between client applications and heterogeneous backends, requiring:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Input Authentication (Client \u2192 Proxy):"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Verify client service identity"}),"\n",(0,a.jsx)(n.li,{children:"Prevent unauthorized access to data plane"}),"\n",(0,a.jsx)(n.li,{children:"Support namespace-level access control"}),"\n",(0,a.jsx)(n.li,{children:"Provide audit trail of data access"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Output Authentication (Proxy \u2192 Backend):"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Authenticate proxy to backend services"}),"\n",(0,a.jsx)(n.li,{children:"Manage credentials for multiple backend types"}),"\n",(0,a.jsx)(n.li,{children:"Support credential rotation without downtime"}),"\n",(0,a.jsx)(n.li,{children:"Isolate backend credentials from clients"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Goals:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Define mTLS-based client authentication"}),"\n",(0,a.jsx)(n.li,{children:"Specify backend authentication patterns per backend type"}),"\n",(0,a.jsx)(n.li,{children:"Document credential management and rotation"}),"\n",(0,a.jsx)(n.li,{children:"Provide sequence diagrams for all authentication flows"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Non-Goals:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Admin API authentication (covered in RFC-010)"}),"\n",(0,a.jsx)(n.li,{children:"Application user authentication (application responsibility)"}),"\n",(0,a.jsx)(n.li,{children:"Data encryption at rest (backend responsibility)"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,a.jsx)(n.p,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                      Authentication Boundaries                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"}),"\n",(0,a.jsx)(n.p,{children:"Client Service \u2192 [mTLS] \u2192 Prism Proxy \u2192 [Backend Auth] \u2192 Backends\n(Input Auth)              (Identity)    (Output Auth)"}),"\n",(0,a.jsx)(n.p,{children:"Input:  mTLS certificates validate client identity\nOutput: Backend-specific credentials (mTLS, passwords, API keys)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n### Ports and Security Zones\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        Security Zones                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nZone 1: Client Services (Service Mesh)\n  - mTLS enforced\n  - Certificates issued by company CA\n  - Short-lived (24 hours)\n\nZone 2: Prism Proxy (DMZ)\n  - Accepts mTLS from clients\n  - Holds backend credentials\n  - Enforces namespace ACLs\n\nZone 3: Backend Services (Secure Network)\n  - Postgres: mTLS or password\n  - Kafka: SASL/SCRAM or mTLS\n  - NATS: JWT or mTLS\n  - Redis: ACL + password\n"})}),"\n",(0,a.jsx)(n.h2,{id:"input-authentication-client--proxy",children:"Input Authentication (Client \u2192 Proxy)"}),"\n",(0,a.jsx)(n.h3,{id:"mtls-certificate-based-authentication",children:"mTLS Certificate-Based Authentication"}),"\n",(0,a.jsx)(n.mermaid,{value:'sequenceDiagram\n    participant Client as Client Service<br/>(user-api.prod)\n    participant CA as Certificate Authority\n    participant Proxy as Prism Proxy\n    participant AuthZ as Authorization Service\n\n    Note over Client,AuthZ: Initial Setup (Once per deployment)\n\n    Client->>CA: Request certificate<br/>CSR: CN=user-api.prod.us-east-1\n    CA->>CA: Validate service identity<br/>Check DNS/registry\n    CA--\x3e>Client: Issue certificate<br/>Valid: 24 hours\n\n    Note over Client,AuthZ: Every Request\n\n    Client->>Proxy: TLS Handshake<br/>ClientHello + Certificate\n    Proxy->>Proxy: Verify certificate:<br/>- Signature valid?<br/>- Not expired?<br/>- Issued by trusted CA?\n\n    alt Certificate valid\n        Proxy->>Proxy: Extract service identity<br/>CN: user-api.prod.us-east-1\n\n        Proxy->>AuthZ: Authorize request<br/>{service: "user-api.prod",<br/> namespace: "user-profiles",<br/> operation: "get"}\n\n        alt Authorized\n            AuthZ--\x3e>Proxy: Allow\n            Proxy->>Proxy: Process request\n            Proxy--\x3e>Client: Response\n        else Not authorized\n            AuthZ--\x3e>Proxy: Deny (no permissions)\n            Proxy--\x3e>Client: PermissionDenied (7)\n        end\n\n    else Certificate invalid/expired\n        Proxy--\x3e>Client: Unauthenticated (16)<br/>"Certificate expired"\n    end'}),"\n",(0,a.jsx)(n.h3,{id:"certificate-structure",children:"Certificate Structure"}),"\n",(0,a.jsx)(n.p,{children:"Client certificates must include:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"Subject:\n  CN: user-api.prod.us-east-1        # Service name + env + region\n  O: Company Name\n  OU: Platform Services\n\nSubject Alternative Names:\n  - DNS: user-api.prod.us-east-1.internal\n  - DNS: user-api.prod.svc.cluster.local\n  - URI: spiffe://company.com/ns/prod/sa/user-api\n\nExtensions:\n  Key Usage: Digital Signature, Key Encipherment\n  Extended Key Usage: Client Authentication\n  Validity: 24 hours\n"})}),"\n",(0,a.jsx)(n.h3,{id:"rust-implementation",children:"Rust Implementation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'use rustls::{ServerConfig, ClientCertVerifier, Certificate};\nuse x509_parser::prelude::*;\n\npub struct PrismClientVerifier {\n    ca_cert: Certificate,\n}\n\nimpl ClientCertVerifier for PrismClientVerifier {\n    fn verify_client_cert(\n        &self,\n        cert_chain: &[Certificate],\n        _sni: Option<&str>,\n    ) -> Result<ClientCertVerified, TLSError> {\n        if cert_chain.is_empty() {\n            return Err(TLSError::NoCertificatesPresented);\n        }\n\n        let client_cert = &cert_chain[0];\n\n        // Verify signature chain\n        self.verify_cert_chain(client_cert, &self.ca_cert)?;\n\n        // Check expiry\n        let (_, parsed) = X509Certificate::from_der(&client_cert.0)\n            .map_err(|_| TLSError::InvalidCertificateData("Failed to parse".into()))?;\n\n        if !parsed.validity().is_valid() {\n            return Err(TLSError::InvalidCertificateData("Expired".into()));\n        }\n\n        Ok(ClientCertVerified::assertion())\n    }\n}\n\npub struct ServiceIdentity {\n    pub service_name: String,\n    pub environment: String,\n    pub region: String,\n}\n\nimpl ServiceIdentity {\n    pub fn from_certificate(cert: &Certificate) -> Result<Self> {\n        let (_, parsed) = X509Certificate::from_der(&cert.0)?;\n\n        // Extract CN from subject\n        let cn = parsed.subject()\n            .iter_common_name()\n            .next()\n            .and_then(|cn| cn.as_str().ok())\n            .ok_or(Error::MissingCommonName)?;\n\n        // Parse: user-api.prod.us-east-1\n        let parts: Vec<&str> = cn.split(\'.\').collect();\n        if parts.len() < 2 {\n            return Err(Error::InvalidCommonName);\n        }\n\n        Ok(ServiceIdentity {\n            service_name: parts[0].to_string(),\n            environment: parts.get(1).unwrap_or(&"unknown").to_string(),\n            region: parts.get(2).unwrap_or(&"unknown").to_string(),\n        })\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"request-flow-with-mtls",children:"Request Flow with mTLS"}),"\n",(0,a.jsx)(n.mermaid,{value:'sequenceDiagram\n    participant App as Application<br/>(user-api)\n    participant Proxy as Prism Proxy\n    participant Backend as Backend<br/>(Postgres)\n\n    Note over App,Backend: Data Request with mTLS\n\n    App->>Proxy: TLS Handshake<br/>Present certificate\n\n    Proxy->>Proxy: Verify certificate<br/>Extract identity:<br/>service=user-api.prod\n\n    App->>Proxy: gRPC: Get()<br/>{namespace: "user-profiles",<br/> id: "user:123", key: "profile"}\n\n    Proxy->>Proxy: Authorize:<br/>Can user-api.prod read<br/>namespace user-profiles?\n\n    alt Authorized\n        Proxy->>Proxy: Determine backend:<br/>user-profiles \u2192 postgres-main\n\n        Proxy->>Backend: Authenticate via<br/>backend credentials<br/>(see Output Auth)\n\n        Backend--\x3e>Proxy: Data\n\n        Proxy->>Proxy: Audit log:<br/>service=user-api.prod,<br/>namespace=user-profiles,<br/>operation=get,<br/>result=success\n\n        Proxy--\x3e>App: GetResponse\n\n    else Not authorized\n        Proxy->>Proxy: Audit log:<br/>service=user-api.prod,<br/>namespace=user-profiles,<br/>operation=get,<br/>result=denied\n\n        Proxy--\x3e>App: PermissionDenied (7)\n    end'}),"\n",(0,a.jsx)(n.h3,{id:"certificate-rotation",children:"Certificate Rotation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'use notify::{Watcher, RecursiveMode};\n\npub struct CertificateReloader {\n    cert_path: PathBuf,\n    key_path: PathBuf,\n    server_config: Arc<RwLock<ServerConfig>>,\n}\n\nimpl CertificateReloader {\n    pub async fn watch(&self) -> Result<()> {\n        let (tx, rx) = mpsc::channel();\n        let mut watcher = notify::watcher(tx, Duration::from_secs(30))?;\n\n        watcher.watch(&self.cert_path, RecursiveMode::NonRecursive)?;\n        watcher.watch(&self.key_path, RecursiveMode::NonRecursive)?;\n\n        loop {\n            match rx.recv() {\n                Ok(DebouncedEvent::Write(_) | DebouncedEvent::Create(_)) => {\n                    tracing::info!("Certificate files changed, reloading...");\n\n                    let new_config = self.load_server_config().await?;\n\n                    let mut config = self.server_config.write().await;\n                    *config = new_config;\n\n                    tracing::info!("Certificate reloaded successfully");\n                }\n                _ => {}\n            }\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"output-authentication-proxy--backend",children:"Output Authentication (Proxy \u2192 Backend)"}),"\n",(0,a.jsx)(n.h3,{id:"per-backend-authentication-strategies",children:"Per-Backend Authentication Strategies"}),"\n",(0,a.jsx)(n.p,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 Backend Authentication Matrix                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Backend"}),(0,a.jsx)(n.th,{children:"Primary Auth"}),(0,a.jsx)(n.th,{children:"Fallback"}),(0,a.jsx)(n.th,{children:"Credential Store"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Postgres"}),(0,a.jsx)(n.td,{children:"mTLS"}),(0,a.jsx)(n.td,{children:"Password"}),(0,a.jsx)(n.td,{children:"Vault/K8s Secret"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Kafka"}),(0,a.jsx)(n.td,{children:"SASL/SCRAM"}),(0,a.jsx)(n.td,{children:"mTLS"}),(0,a.jsx)(n.td,{children:"Vault/K8s Secret"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"NATS"}),(0,a.jsx)(n.td,{children:"JWT"}),(0,a.jsx)(n.td,{children:"NKey"}),(0,a.jsx)(n.td,{children:"Vault/K8s Secret"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Redis"}),(0,a.jsx)(n.td,{children:"ACL + Password"}),(0,a.jsx)(n.td,{children:"None"}),(0,a.jsx)(n.td,{children:"Vault/K8s Secret"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"SQLite"}),(0,a.jsx)(n.td,{children:"File permissions"}),(0,a.jsx)(n.td,{children:"None"}),(0,a.jsx)(n.td,{children:"N/A (local)"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"S3"}),(0,a.jsx)(n.td,{children:"IAM Role"}),(0,a.jsx)(n.td,{children:"Access Keys"}),(0,a.jsx)(n.td,{children:"Instance Profile"})]})]})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n### Postgres Authentication\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"sequenceDiagram\nparticipant Proxy as Prism Proxy\nparticipant Vault as HashiCorp Vault\nparticipant PG as PostgreSQL"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Note over Proxy,PG: Initial Connection\n\nProxy->>Vault: Request credentials<br/>GET /v1/database/creds/postgres-main\nVault->>Vault: Generate dynamic credentials<br/>User: prism-prod-abc123<br/>Password: <random><br/>TTL: 1 hour\nVault->>PG: CREATE ROLE prism-prod-abc123<br/>WITH LOGIN PASSWORD '...'<br/>VALID UNTIL '2025-10-09 15:00'\nVault--\x3e>Proxy: {username, password, lease_id}\n\nProxy->>Proxy: Cache credentials<br/>Set lease renewal timer\n\nNote over Proxy,PG: Data Operations\n\nProxy->>PG: Connect<br/>SSL mode: require<br/>User: prism-prod-abc123<br/>Password: <from vault>\nPG->>PG: Verify credentials\nPG--\x3e>Proxy: Connection established\n\nProxy->>PG: SELECT * FROM user_profiles<br/>WHERE id = 'user:123'\nPG--\x3e>Proxy: Row data\n\nNote over Proxy,PG: Credential Renewal\n\nloop Every 30 minutes\n    Proxy->>Vault: Renew lease<br/>PUT /v1/sys/leases/renew<br/>{lease_id}\n    Vault--\x3e>Proxy: Lease extended\nend\n\nNote over Proxy,PG: Credential Expiry\n\nalt Lease expires\n    Vault->>PG: REVOKE ROLE prism-prod-abc123\n    Proxy->>Vault: Request new credentials\n    Vault--\x3e>Proxy: New {username, password}\n    Proxy->>Proxy: Update connection pool\nend\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n### Kafka Authentication (SASL/SCRAM)\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"sequenceDiagram\nparticipant Proxy as Prism Proxy\nparticipant Vault as HashiCorp Vault\nparticipant Kafka as Kafka Broker"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Note over Proxy,Kafka: Bootstrap\n\nProxy->>Vault: GET /v1/kafka/creds/producer-main\nVault->>Vault: Generate SCRAM credentials<br/>User: prism-kafka-xyz789<br/>Password: <scram-sha-512>\nVault->>Kafka: kafka-configs --alter<br/>--entity-type users<br/>--entity-name prism-kafka-xyz789<br/>--add-config 'SCRAM-SHA-512=[...]'\nVault--\x3e>Proxy: {username, password, mechanism: SCRAM-SHA-512}\n\nProxy->>Kafka: SASL Handshake<br/>Mechanism: SCRAM-SHA-512\nKafka--\x3e>Proxy: SASL Challenge\n\nProxy->>Kafka: SASL Response<br/>{username, scrambled_password}\nKafka->>Kafka: Verify SCRAM\nKafka--\x3e>Proxy: Authenticated\n\nNote over Proxy,Kafka: Produce Messages\n\nProxy->>Kafka: ProduceRequest<br/>Topic: user-events\nKafka->>Kafka: Check ACLs:<br/>Can prism-kafka-xyz789 write to topic?\nKafka--\x3e>Proxy: ProduceResponse\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n### NATS Authentication (JWT)\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"sequenceDiagram\nparticipant Proxy as Prism Proxy\nparticipant Vault as HashiCorp Vault\nparticipant NATS as NATS Server"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'Proxy->>Vault: GET /v1/nats/creds/publisher\nVault->>Vault: Generate JWT + NKey<br/>Claims: {<br/>  pub: ["events.>"],<br/>  sub: ["responses.prism.>"]<br/>}\nVault--\x3e>Proxy: {jwt, seed (nkey)}\n\nProxy->>NATS: CONNECT {<br/>  jwt: "eyJhbG...",<br/>  sig: sign(nonce, nkey)<br/>}\nNATS->>NATS: Verify JWT signature<br/>Check expiry<br/>Validate claims\nNATS--\x3e>Proxy: +OK\n\nProxy->>NATS: PUB events.user.login 42<br/>{user_id: "123", timestamp: ...}\nNATS->>NATS: Check permissions:<br/>Can JWT publish to events.user.login?\nNATS--\x3e>Proxy: +OK\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n### Redis Authentication (ACL)\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"sequenceDiagram\nparticipant Proxy as Prism Proxy\nparticipant Vault as HashiCorp Vault\nparticipant Redis as Redis Server"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'Proxy->>Vault: GET /v1/redis/creds/cache-rw\nVault->>Vault: Generate Redis ACL<br/>User: prism-cache-abc<br/>Password: <random><br/>ACL: ~cache:* +get +set +del\nVault->>Redis: ACL SETUSER prism-cache-abc<br/>on >password ~cache:* +get +set +del\nVault--\x3e>Proxy: {username, password}\n\nProxy->>Redis: AUTH prism-cache-abc <password>\nRedis->>Redis: Verify password<br/>Load ACL rules\nRedis--\x3e>Proxy: OK\n\nProxy->>Redis: GET cache:user:123:profile\nRedis->>Redis: Check ACL:<br/>Pattern match: cache:*<br/>Command allowed: GET\nRedis--\x3e>Proxy: "{"name":"Alice",...}"\n\nProxy->>Redis: SET cache:user:123:session <data>\nRedis--\x3e>Proxy: OK\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n### Credential Management\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"use vaultrs::client::VaultClient;\nuse vaultrs::kv2;"}),"\n",(0,a.jsxs)(n.p,{children:["pub struct BackendCredentials {\npub backend_type: String,\npub username: String,\npub password: String,\npub lease_id: Option",(0,a.jsxs)(n.string,{children:[",\npub expires_at: DateTime",(0,a.jsx)(n.utc,{children:",\n}"})]})]}),"\n",(0,a.jsx)(n.p,{children:"pub struct CredentialManager {\nvault_client: VaultClient,\ncredentials: Arc<RwLock<HashMap<String, BackendCredentials>>>,\n}"}),"\n",(0,a.jsxs)(n.p,{children:["impl CredentialManager {\npub async fn get_credentials(&self, backend_id: &str) -> Result",(0,a.jsx)(n.backendcredentials,{children:" {\n// Check cache\n{\nlet creds = self.credentials.read().await;\nif let Some(cached) = creds.get(backend_id) {\nif cached.expires_at > Utc::now() + Duration::minutes(5) {\nreturn Ok(cached.clone());\n}\n}\n}"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'    // Fetch from Vault\n    let path = format!("database/creds/{}", backend_id);\n    let creds: VaultCredentials = self.vault_client\n        .read(&path)\n        .await?;\n\n    let backend_creds = BackendCredentials {\n        backend_type: creds.backend_type,\n        username: creds.username,\n        password: creds.password,\n        lease_id: Some(creds.lease_id),\n        expires_at: Utc::now() + Duration::hours(1),\n    };\n\n    // Update cache\n    {\n        let mut cache = self.credentials.write().await;\n        cache.insert(backend_id.to_string(), backend_creds.clone());\n    }\n\n    // Schedule renewal\n    self.schedule_renewal(backend_id, &creds.lease_id).await;\n\n    Ok(backend_creds)\n}\n\nasync fn schedule_renewal(&self, backend_id: &str, lease_id: &str) {\n    let vault_client = self.vault_client.clone();\n    let lease_id = lease_id.to_string();\n\n    tokio::spawn(async move {\n        loop {\n            tokio::time::sleep(Duration::minutes(30)).await;\n\n            match vault_client.renew_lease(&lease_id).await {\n                Ok(_) => {\n                    tracing::info!(\n                        backend_id = %backend_id,\n                        lease_id = %lease_id,\n                        "Renewed backend credentials"\n                    );\n                }\n                Err(e) => {\n                    tracing::error!(\n                        backend_id = %backend_id,\n                        error = %e,\n                        "Failed to renew credentials, will fetch new ones"\n                    );\n                    break;\n                }\n            }\n        }\n    });\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"}"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n## End-to-End Authentication Flow\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"sequenceDiagram\nparticipant App as Application\nparticipant Proxy as Prism Proxy\nparticipant Vault as Vault\nparticipant PG as Postgres\nparticipant Audit as Audit Log"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'Note over App,Audit: Complete Request Flow\n\nApp->>Proxy: mTLS Handshake<br/>Present client cert\nProxy->>Proxy: Verify client cert<br/>Extract identity: user-api.prod\n\nApp->>Proxy: Get(namespace="users", id="123", key="profile")\n\nProxy->>Proxy: Authorize:<br/>user-api.prod \u2192 users namespace?\n\nalt Authorized\n    Proxy->>Proxy: Lookup backend:<br/>users \u2192 postgres-main\n\n    Proxy->>Proxy: Get credentials from cache\n\n    alt Credentials expired/missing\n        Proxy->>Vault: GET /database/creds/postgres-main\n        Vault--\x3e>Proxy: {username, password, lease_id}\n        Proxy->>Proxy: Cache credentials\n    end\n\n    Proxy->>PG: Connect with credentials\n    PG--\x3e>Proxy: Connection OK\n\n    Proxy->>PG: SELECT value FROM users<br/>WHERE id=\'123\' AND key=\'profile\'\n    PG--\x3e>Proxy: Row data\n\n    Proxy->>Audit: Log:<br/>{service: user-api.prod,<br/> namespace: users,<br/> operation: get,<br/> backend: postgres-main,<br/> latency_ms: 2.3,<br/> result: success}\n\n    Proxy--\x3e>App: GetResponse{value}\n\nelse Not authorized\n    Proxy->>Audit: Log:<br/>{service: user-api.prod,<br/> namespace: users,<br/> operation: get,<br/> result: denied,<br/> reason: "no permissions"}\n\n    Proxy--\x3e>App: PermissionDenied (7)\nend\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n## Secrets Provider Abstraction\n\nTo support multiple secret management services (Vault, AWS Secrets Manager, Google Secret Manager, Azure Key Vault), Prism implements a pluggable secrets provider architecture.\n\n### Secrets Provider Interface\n\n"})}),"\n",(0,a.jsxs)(n.p,{children:["#[async_trait]\npub trait SecretsProvider: Send + Sync {\n/// Fetch credentials for a backend\nasync fn get_credentials(&self, path: &str) -> Result",(0,a.jsx)(n.credentials,{children:";"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"/// Renew a credential lease (if supported)\nasync fn renew_credentials(&self, lease_id: &str) -> Result<()>;\n\n/// Check if provider supports dynamic credentials\nfn supports_dynamic_credentials(&self) -> bool;\n\n/// Get provider metadata\nfn provider_type(&self) -> &str;\n"})}),"\n",(0,a.jsx)(n.p,{children:"}"}),"\n",(0,a.jsxs)(n.p,{children:["pub struct Credentials {\npub username: Option",(0,a.jsxs)(n.string,{children:[",\npub password: Option",(0,a.jsxs)(n.string,{children:[",\npub api_key: Option",(0,a.jsxs)(n.string,{children:[",\npub certificate: Option",(0,a.jsxs)(n.string,{children:[",\npub private_key: Option",(0,a.jsxs)(n.string,{children:[",\npub jwt_token: Option",(0,a.jsxs)(n.string,{children:[",\npub metadata: HashMap<String, String>,\npub lease_id: Option",(0,a.jsxs)(n.string,{children:[",\npub expires_at: Option<DateTime",(0,a.jsx)(n.utc,{children:">,\n}"})]})]})]})]})]})]})]})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n### Provider Implementations\n\n#### HashiCorp Vault Provider\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"use vaultrs::client::VaultClient;"}),"\n",(0,a.jsxs)(n.p,{children:["pub struct VaultProvider {\nclient: VaultClient,\nnamespace: Option",(0,a.jsx)(n.string,{children:",\n}"})]}),"\n",(0,a.jsxs)(n.p,{children:["#[async_trait]\nimpl SecretsProvider for VaultProvider {\nasync fn get_credentials(&self, path: &str) -> Result",(0,a.jsx)(n.credentials,{children:" {\nlet response: VaultCredResponse = self.client\n.read(path)\n.await?;"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'    Ok(Credentials {\n        username: Some(response.data.username),\n        password: Some(response.data.password),\n        lease_id: Some(response.lease_id),\n        expires_at: Some(Utc::now() + Duration::seconds(response.lease_duration)),\n        metadata: response.metadata,\n        ..Default::default()\n    })\n}\n\nasync fn renew_credentials(&self, lease_id: &str) -> Result<()> {\n    self.client.renew_lease(lease_id).await?;\n    Ok(())\n}\n\nfn supports_dynamic_credentials(&self) -> bool {\n    true  // Vault supports dynamic credential generation\n}\n\nfn provider_type(&self) -> &str {\n    "vault"\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"}"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n#### AWS Secrets Manager Provider\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"use aws_sdk_secretsmanager::Client as SecretsManagerClient;\nuse aws_sdk_secretsmanager::types::SecretString;"}),"\n",(0,a.jsx)(n.p,{children:"pub struct AwsSecretsProvider {\nclient: SecretsManagerClient,\nregion: String,\n}"}),"\n",(0,a.jsxs)(n.p,{children:["#[async_trait]\nimpl SecretsProvider for AwsSecretsProvider {\nasync fn get_credentials(&self, path: &str) -> Result",(0,a.jsx)(n.credentials,{children:' {\n// path format: "arn:aws:secretsmanager:region:account:secret:name"\n// or simple: "prism/postgres-main"\nlet response = self.client\n.get_secret_value()\n.secret_id(path)\n.send()\n.await?;'})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"    let secret_string = response.secret_string()\n        .ok_or(Error::MissingSecretValue)?;\n\n    // Parse JSON secret\n    let secret_data: SecretData = serde_json::from_str(secret_string)?;\n\n    Ok(Credentials {\n        username: secret_data.username,\n        password: secret_data.password,\n        api_key: secret_data.api_key,\n        expires_at: None,  // AWS Secrets Manager doesn't auto-expire\n        metadata: secret_data.metadata.unwrap_or_default(),\n        ..Default::default()\n    })\n}\n\nasync fn renew_credentials(&self, _lease_id: &str) -> Result<()> {\n    // AWS Secrets Manager doesn't support dynamic credential renewal\n    Ok(())\n}\n\nfn supports_dynamic_credentials(&self) -> bool {\n    false  // Static secrets only\n}\n\nfn provider_type(&self) -> &str {\n    \"aws-secrets-manager\"\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"}"}),"\n",(0,a.jsxs)(n.p,{children:["#[derive(Deserialize)]\nstruct SecretData {\nusername: Option",(0,a.jsxs)(n.string,{children:[",\npassword: Option",(0,a.jsxs)(n.string,{children:[",\napi_key: Option",(0,a.jsx)(n.string,{children:",\nmetadata: Option<HashMap<String, String>>,\n}"})]})]})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n#### Google Secret Manager Provider\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"use google_secretmanager::v1::SecretManagerServiceClient;"}),"\n",(0,a.jsx)(n.p,{children:"pub struct GcpSecretsProvider {\nclient: SecretManagerServiceClient,\nproject_id: String,\n}"}),"\n",(0,a.jsxs)(n.p,{children:["#[async_trait]\nimpl SecretsProvider for GcpSecretsProvider {\nasync fn get_credentials(&self, path: &str) -> Result",(0,a.jsx)(n.credentials,{children:' {\n// path format: "projects/{project}/secrets/{secret}/versions/latest"\n// or simple: "prism-postgres-main" (auto-expanded)\nlet name = if path.starts_with("projects/") {\npath.to_string()\n} else {\nformat!("projects/{}/secrets/{}/versions/latest",\nself.project_id, path)\n};'})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'    let response = self.client\n        .access_secret_version(&name)\n        .await?;\n\n    let payload = response.payload\n        .ok_or(Error::MissingPayload)?;\n\n    let secret_string = String::from_utf8(payload.data)?;\n    let secret_data: SecretData = serde_json::from_str(&secret_string)?;\n\n    Ok(Credentials {\n        username: secret_data.username,\n        password: secret_data.password,\n        api_key: secret_data.api_key,\n        expires_at: None,\n        metadata: secret_data.metadata.unwrap_or_default(),\n        ..Default::default()\n    })\n}\n\nasync fn renew_credentials(&self, _lease_id: &str) -> Result<()> {\n    // GCP Secret Manager doesn\'t support dynamic renewal\n    Ok(())\n}\n\nfn supports_dynamic_credentials(&self) -> bool {\n    false\n}\n\nfn provider_type(&self) -> &str {\n    "gcp-secret-manager"\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"}"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n#### Azure Key Vault Provider\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"use azure_security_keyvault::KeyvaultClient;\nuse azure_identity::DefaultAzureCredential;"}),"\n",(0,a.jsx)(n.p,{children:"pub struct AzureKeyVaultProvider {\nclient: KeyvaultClient,\nvault_url: String,\n}"}),"\n",(0,a.jsxs)(n.p,{children:["#[async_trait]\nimpl SecretsProvider for AzureKeyVaultProvider {\nasync fn get_credentials(&self, path: &str) -> Result",(0,a.jsx)(n.credentials,{children:' {\n// path format: "prism-postgres-main"\nlet response = self.client\n.get_secret(&self.vault_url, path)\n.await?;'})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'    let secret_value = response.value()\n        .ok_or(Error::MissingSecretValue)?;\n\n    let secret_data: SecretData = serde_json::from_str(secret_value)?;\n\n    Ok(Credentials {\n        username: secret_data.username,\n        password: secret_data.password,\n        api_key: secret_data.api_key,\n        expires_at: response.attributes().expires_on(),\n        metadata: secret_data.metadata.unwrap_or_default(),\n        ..Default::default()\n    })\n}\n\nasync fn renew_credentials(&self, _lease_id: &str) -> Result<()> {\n    // Azure Key Vault doesn\'t support dynamic renewal\n    Ok(())\n}\n\nfn supports_dynamic_credentials(&self) -> bool {\n    false\n}\n\nfn provider_type(&self) -> &str {\n    "azure-keyvault"\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"}"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n### Provider Comparison\n\n| Feature | Vault | AWS Secrets | GCP Secret | Azure Key Vault |\n|---------|-------|-------------|------------|-----------------|\n| **Dynamic Credentials** | \u2705 Yes | \u274c No | \u274c No | \u274c No |\n| **Auto-Rotation** | \u2705 Yes (TTL) | \u26a0\ufe0f Manual | \u26a0\ufe0f Manual | \u26a0\ufe0f Manual |\n| **Versioning** | \u2705 Yes | \u2705 Yes | \u2705 Yes | \u2705 Yes |\n| **Audit Logging** | \u2705 Yes | \u2705 CloudTrail | \u2705 Cloud Audit | \u2705 Monitor Logs |\n| **IAM Integration** | \u26a0\ufe0f Policies | \u2705 Native IAM | \u2705 Native IAM | \u2705 Native RBAC |\n| **Multi-Cloud** | \u2705 Yes | \u274c AWS Only | \u274c GCP Only | \u274c Azure Only |\n| **Self-Hosted** | \u2705 Yes | \u274c No | \u274c No | \u274c No |\n| **Cost** | Free (OSS) | $0.40/secret/month | $0.06/10k accesses | ~$0.03/10k ops |\n\n### Provider Selection Strategy\n\n"})}),"\n",(0,a.jsxs)(n.p,{children:["pub enum ProviderConfig {\nVault {\naddress: String,\ntoken_path: String,\nnamespace: Option",(0,a.jsxs)(n.string,{children:[",\n},\nAwsSecretsManager {\nregion: String,\nrole_arn: Option",(0,a.jsxs)(n.string,{children:[",\n},\nGcpSecretManager {\nproject_id: String,\nservice_account: Option",(0,a.jsxs)(n.string,{children:[",\n},\nAzureKeyVault {\nvault_url: String,\ntenant_id: String,\nclient_id: Option",(0,a.jsx)(n.string,{children:",\n},\n}"})]})]})]})]}),"\n",(0,a.jsxs)(n.p,{children:["pub fn create_provider(config: &ProviderConfig) -> Result<Arc",(0,a.jsx)(n.dyn,{secretsprovider:"",children:"> {\nmatch config {\nProviderConfig::Vault { address, token_path, namespace } => {\nlet token = std::fs::read_to_string(token_path)?;\nlet client = VaultClient::new(address, &token, namespace.as_deref())?;\nOk(Arc::new(VaultProvider { client, namespace: namespace.clone() }))\n}\nProviderConfig::AwsSecretsManager { region, role_arn } => {\nlet aws_config = aws_config::from_env()\n.region(region)\n.load()\n.await;\nlet client = SecretsManagerClient::new(&aws_config);\nOk(Arc::new(AwsSecretsProvider { client, region: region.clone() }))\n}\nProviderConfig::GcpSecretManager { project_id, service_account } => {\nlet client = SecretManagerServiceClient::new().await?;\nOk(Arc::new(GcpSecretsProvider { client, project_id: project_id.clone() }))\n}\nProviderConfig::AzureKeyVault { vault_url, tenant_id, client_id } => {\nlet credential = DefaultAzureCredential::new()?;\nlet client = KeyvaultClient::new(vault_url, credential)?;\nOk(Arc::new(AzureKeyVaultProvider { client, vault_url: vault_url.clone() }))\n}\n}\n}"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n### Credential Manager with Multiple Providers\n\n"})}),"\n",(0,a.jsxs)(n.p,{children:["pub struct CredentialManager {\nprovider: Arc",(0,a.jsx)(n.dyn,{secretsprovider:"",children:",\ncredentials: Arc<RwLock<HashMap<String, BackendCredentials>>>,\nrefresh_interval: Duration,\n}"})]}),"\n",(0,a.jsxs)(n.p,{children:["impl CredentialManager {\npub fn new(provider: Arc",(0,a.jsx)(n.dyn,{secretsprovider:"",children:") -> Self {\nSelf {\nprovider,\ncredentials: Arc::new(RwLock::new(HashMap::new())),\nrefresh_interval: Duration::minutes(30),\n}\n}"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'pub async fn get_credentials(&self, backend_id: &str, path: &str) -> Result<BackendCredentials> {\n    // Check cache\n    {\n        let cache = self.credentials.read().await;\n        if let Some(cached) = cache.get(backend_id) {\n            // For static providers, use longer cache TTL\n            let cache_valid = if self.provider.supports_dynamic_credentials() {\n                cached.expires_at > Utc::now() + Duration::minutes(5)\n            } else {\n                cached.expires_at > Utc::now()\n            };\n\n            if cache_valid {\n                return Ok(cached.clone());\n            }\n        }\n    }\n\n    // Fetch from provider\n    let creds = self.provider.get_credentials(path).await?;\n\n    let backend_creds = BackendCredentials {\n        backend_type: backend_id.to_string(),\n        username: creds.username.unwrap_or_default(),\n        password: creds.password.unwrap_or_default(),\n        api_key: creds.api_key,\n        certificate: creds.certificate,\n        lease_id: creds.lease_id.clone(),\n        expires_at: creds.expires_at.unwrap_or_else(|| {\n            // For static providers, cache for 24 hours\n            Utc::now() + Duration::hours(24)\n        }),\n    };\n\n    // Update cache\n    {\n        let mut cache = self.credentials.write().await;\n        cache.insert(backend_id.to_string(), backend_creds.clone());\n    }\n\n    // Schedule renewal if provider supports dynamic credentials\n    if self.provider.supports_dynamic_credentials() {\n        if let Some(lease_id) = &creds.lease_id {\n            self.schedule_renewal(backend_id, lease_id).await;\n        }\n    }\n\n    Ok(backend_creds)\n}\n\nasync fn schedule_renewal(&self, backend_id: &str, lease_id: &str) {\n    let provider = self.provider.clone();\n    let lease_id = lease_id.to_string();\n    let backend_id = backend_id.to_string();\n    let interval = self.refresh_interval;\n\n    tokio::spawn(async move {\n        loop {\n            tokio::time::sleep(interval).await;\n\n            match provider.renew_credentials(&lease_id).await {\n                Ok(_) => {\n                    tracing::info!(\n                        backend_id = %backend_id,\n                        lease_id = %lease_id,\n                        provider = %provider.provider_type(),\n                        "Renewed backend credentials"\n                    );\n                }\n                Err(e) => {\n                    tracing::error!(\n                        backend_id = %backend_id,\n                        provider = %provider.provider_type(),\n                        error = %e,\n                        "Failed to renew credentials, will fetch new ones"\n                    );\n                    break;\n                }\n            }\n        }\n    });\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"}"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n## Configuration\n\n### Proxy Configuration with Secrets Providers\n\n#### Option 1: HashiCorp Vault (Recommended for Dynamic Credentials)\n\n"})}),"\n",(0,a.jsx)(n.h1,{id:"prism-proxyyaml",children:"prism-proxy.yaml"}),"\n",(0,a.jsx)(n.p,{children:"data_port: 8980\nadmin_port: 8981"}),"\n",(0,a.jsx)(n.h1,{id:"input-authentication",children:"Input Authentication"}),"\n",(0,a.jsx)(n.p,{children:"input_auth:\ntype: mtls\nca_cert: /etc/prism/certs/ca.crt\nserver_cert: /etc/prism/certs/server.crt\nserver_key: /etc/prism/certs/server.key\nclient_cert_required: true\nverify_depth: 3"}),"\n",(0,a.jsx)(n.h1,{id:"output-authentication-with-vault",children:"Output Authentication with Vault"}),"\n",(0,a.jsxs)(n.p,{children:["output_auth:\ncredential_provider: vault\nvault:\naddress: ",(0,a.jsx)(n.a,{href:"https://vault.internal:8200",children:"https://vault.internal:8200"}),"\ntoken_path: /var/run/secrets/vault-token\nnamespace: prism-prod"]}),"\n",(0,a.jsx)(n.p,{children:"backends:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"name: postgres-main\ntype: postgres\nauth:\ntype: vault-dynamic\npath: database/creds/postgres-main\nconnection:\nhost: postgres.internal\nport: 5432\ndatabase: users\nssl_mode: require"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"name: kafka-events\ntype: kafka\nauth:\ntype: vault-dynamic\npath: kafka/creds/producer-main\nconnection:\nbrokers: [kafka-1:9092, kafka-2:9092, kafka-3:9092]\nsecurity_protocol: SASL_SSL\nsasl_mechanism: SCRAM-SHA-512"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"name: nats-messages\ntype: nats\nauth:\ntype: vault-jwt\npath: nats/creds/publisher\nconnection:\nservers: [nats://nats-1:4222, nats://nats-2:4222]\ntls_required: true"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n#### Option 2: AWS Secrets Manager (AWS Native)\n\n"})}),"\n",(0,a.jsx)(n.h1,{id:"prism-proxyyaml-1",children:"prism-proxy.yaml"}),"\n",(0,a.jsx)(n.p,{children:"data_port: 8980\nadmin_port: 8981"}),"\n",(0,a.jsx)(n.h1,{id:"input-authentication-1",children:"Input Authentication"}),"\n",(0,a.jsx)(n.p,{children:"input_auth:\ntype: mtls\nca_cert: /etc/prism/certs/ca.crt\nserver_cert: /etc/prism/certs/server.crt\nserver_key: /etc/prism/certs/server.key\nclient_cert_required: true"}),"\n",(0,a.jsx)(n.h1,{id:"output-authentication-with-aws-secrets-manager",children:"Output Authentication with AWS Secrets Manager"}),"\n",(0,a.jsx)(n.p,{children:"output_auth:\ncredential_provider: aws-secrets-manager\naws:\nregion: us-east-1\n# Uses IAM role attached to EC2/ECS/EKS for authentication"}),"\n",(0,a.jsx)(n.p,{children:"backends:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"name: postgres-main\ntype: postgres\nauth:\ntype: aws-secret"}),"\n",(0,a.jsx)(n.h1,{id:"can-use-arn-or-friendly-name",children:"Can use ARN or friendly name"}),"\n",(0,a.jsx)(n.p,{children:"path: arn:aws:secretsmanager:us-east-1:123456789012:secret:prism/postgres-main"}),"\n",(0,a.jsx)(n.h1,{id:"or-path-prismpostgres-main",children:"Or: path: prism/postgres-main"}),"\n",(0,a.jsx)(n.p,{children:"connection:\nhost: postgres.internal\nport: 5432\ndatabase: users\nssl_mode: require"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"name: kafka-events\ntype: kafka\nauth:\ntype: aws-secret\npath: prism/kafka-producer\nconnection:\nbrokers: [kafka-1:9092, kafka-2:9092, kafka-3:9092]\nsecurity_protocol: SASL_SSL\nsasl_mechanism: SCRAM-SHA-512"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n**AWS Secrets Manager Secret Format** (JSON):\n"})}),"\n",(0,a.jsx)(n.p,{children:'{\n"username": "prism-postgres-user",\n"password": "securepassword123",\n"metadata": {\n"backend_type": "postgres",\n"environment": "production"\n}\n}'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n#### Option 3: Google Secret Manager (GCP Native)\n\n"})}),"\n",(0,a.jsx)(n.h1,{id:"prism-proxyyaml-2",children:"prism-proxy.yaml"}),"\n",(0,a.jsx)(n.p,{children:"data_port: 8980\nadmin_port: 8981"}),"\n",(0,a.jsx)(n.h1,{id:"input-authentication-2",children:"Input Authentication"}),"\n",(0,a.jsx)(n.p,{children:"input_auth:\ntype: mtls\nca_cert: /etc/prism/certs/ca.crt\nserver_cert: /etc/prism/certs/server.crt\nserver_key: /etc/prism/certs/server.key\nclient_cert_required: true"}),"\n",(0,a.jsx)(n.h1,{id:"output-authentication-with-google-secret-manager",children:"Output Authentication with Google Secret Manager"}),"\n",(0,a.jsx)(n.p,{children:"output_auth:\ncredential_provider: gcp-secret-manager\ngcp:\nproject_id: prism-production-123456\n# Uses Workload Identity or service account for authentication"}),"\n",(0,a.jsx)(n.p,{children:"backends:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"name: postgres-main\ntype: postgres\nauth:\ntype: gcp-secret"}),"\n",(0,a.jsx)(n.h1,{id:"can-use-full-path-or-friendly-name",children:"Can use full path or friendly name"}),"\n",(0,a.jsx)(n.p,{children:"path: projects/prism-production-123456/secrets/prism-postgres-main/versions/latest"}),"\n",(0,a.jsx)(n.h1,{id:"or-path-prism-postgres-main-auto-expanded",children:"Or: path: prism-postgres-main (auto-expanded)"}),"\n",(0,a.jsx)(n.p,{children:"connection:\nhost: postgres.internal\nport: 5432\ndatabase: users\nssl_mode: require"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"name: kafka-events\ntype: kafka\nauth:\ntype: gcp-secret\npath: prism-kafka-producer\nconnection:\nbrokers: [kafka-1:9092, kafka-2:9092, kafka-3:9092]\nsecurity_protocol: SASL_SSL\nsasl_mechanism: SCRAM-SHA-512"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n#### Option 4: Azure Key Vault (Azure Native)\n\n"})}),"\n",(0,a.jsx)(n.h1,{id:"prism-proxyyaml-3",children:"prism-proxy.yaml"}),"\n",(0,a.jsx)(n.p,{children:"data_port: 8980\nadmin_port: 8981"}),"\n",(0,a.jsx)(n.h1,{id:"input-authentication-3",children:"Input Authentication"}),"\n",(0,a.jsx)(n.p,{children:"input_auth:\ntype: mtls\nca_cert: /etc/prism/certs/ca.crt\nserver_cert: /etc/prism/certs/server.crt\nserver_key: /etc/prism/certs/server.key\nclient_cert_required: true"}),"\n",(0,a.jsx)(n.h1,{id:"output-authentication-with-azure-key-vault",children:"Output Authentication with Azure Key Vault"}),"\n",(0,a.jsxs)(n.p,{children:["output_auth:\ncredential_provider: azure-keyvault\nazure:\nvault_url: ",(0,a.jsx)(n.a,{href:"https://prism-prod.vault.azure.net",children:"https://prism-prod.vault.azure.net"}),"\ntenant_id: 12345678-1234-1234-1234-123456789012\n# Uses Managed Identity or Service Principal for authentication"]}),"\n",(0,a.jsx)(n.p,{children:"backends:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"name: postgres-main\ntype: postgres\nauth:\ntype: azure-secret\npath: prism-postgres-main\nconnection:\nhost: postgres.internal\nport: 5432\ndatabase: users\nssl_mode: require"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"name: kafka-events\ntype: kafka\nauth:\ntype: azure-secret\npath: prism-kafka-producer\nconnection:\nbrokers: [kafka-1:9092, kafka-2:9092, kafka-3:9092]\nsecurity_protocol: SASL_SSL\nsasl_mechanism: SCRAM-SHA-512"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n### Multi-Provider Deployment (Hybrid Cloud)\n\nFor hybrid cloud deployments, you can configure different providers per backend:\n\n"})}),"\n",(0,a.jsx)(n.h1,{id:"prism-proxyyaml-4",children:"prism-proxy.yaml"}),"\n",(0,a.jsx)(n.p,{children:"data_port: 8980\nadmin_port: 8981"}),"\n",(0,a.jsx)(n.h1,{id:"input-authentication-4",children:"Input Authentication"}),"\n",(0,a.jsx)(n.p,{children:"input_auth:\ntype: mtls\nca_cert: /etc/prism/certs/ca.crt\nserver_cert: /etc/prism/certs/server.crt\nserver_key: /etc/prism/certs/server.key\nclient_cert_required: true"}),"\n",(0,a.jsx)(n.h1,{id:"output-authentication---multiple-providers",children:"Output Authentication - Multiple Providers"}),"\n",(0,a.jsxs)(n.p,{children:["output_auth:\nproviders:\n# Vault for dynamic credentials (on-prem backends)\n- name: vault-onprem\ntype: vault\nvault:\naddress: ",(0,a.jsx)(n.a,{href:"https://vault.internal:8200",children:"https://vault.internal:8200"}),"\ntoken_path: /var/run/secrets/vault-token\nnamespace: prism-prod"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"# AWS Secrets for AWS backends\n- name: aws-prod\n  type: aws-secrets-manager\n  aws:\n    region: us-east-1\n\n# GCP Secrets for GCP backends\n- name: gcp-prod\n  type: gcp-secret-manager\n  gcp:\n    project_id: prism-production-123456\n"})}),"\n",(0,a.jsx)(n.p,{children:"backends:"}),"\n",(0,a.jsx)(n.h1,{id:"on-prem-postgres-using-vault-dynamic-credentials",children:"On-prem Postgres using Vault dynamic credentials"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"name: postgres-main\ntype: postgres\nauth:\nprovider: vault-onprem\ntype: vault-dynamic\npath: database/creds/postgres-main\nconnection:\nhost: postgres.internal\nport: 5432\ndatabase: users\nssl_mode: require"}),"\n"]}),"\n",(0,a.jsx)(n.h1,{id:"aws-rds-using-aws-secrets-manager",children:"AWS RDS using AWS Secrets Manager"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"name: rds-analytics\ntype: postgres\nauth:\nprovider: aws-prod\ntype: aws-secret\npath: prism/rds-analytics\nconnection:\nhost: analytics.abc123.us-east-1.rds.amazonaws.com\nport: 5432\ndatabase: analytics\nssl_mode: require"}),"\n"]}),"\n",(0,a.jsx)(n.h1,{id:"gcp-cloud-sql-using-gcp-secret-manager",children:"GCP Cloud SQL using GCP Secret Manager"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"name: cloudsql-reports\ntype: postgres\nauth:\nprovider: gcp-prod\ntype: gcp-secret\npath: prism-cloudsql-reports\nconnection:\nhost: /cloudsql/prism-prod:us-central1:reports\nport: 5432\ndatabase: reports\nssl_mode: require"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n## Security Considerations\n\n### Credential Isolation\n\nPrinciple: Clients never see backend credentials\n\n\u2713 Client presents certificate \u2192 Proxy validates\n\u2713 Proxy fetches backend credentials \u2192 From Vault\n\u2713 Proxy connects to backend \u2192 Using fetched credentials\n\u2717 Client NEVER gets backend credentials\n"})}),"\n",(0,a.jsx)(n.h3,{id:"credential-rotation",children:"Credential Rotation"}),"\n",(0,a.jsx)(n.p,{children:"Automatic rotation schedule:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Vault generates new credentials (TTL: 1 hour)"}),"\n",(0,a.jsx)(n.li,{children:"Proxy caches and renews every 30 minutes"}),"\n",(0,a.jsx)(n.li,{children:"On renewal failure, fetch new credentials"}),"\n",(0,a.jsx)(n.li,{children:"Gracefully drain old connections"}),"\n",(0,a.jsx)(n.li,{children:"Old credentials revoked by Vault after TTL"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n### Audit Requirements\n\nEvery data access must log:\n- Client service identity (from mTLS cert)\n- Namespace accessed\n- Operation performed (get, put, delete, scan)\n- Backend used\n- Success/failure\n- Latency\n\n## Testing\n\n### Integration Tests\n\n"})}),"\n",(0,a.jsx)(n.p,{children:'#[tokio::test]\nasync fn test_mtls_authentication() {\nlet ca = generate_test_ca();\nlet client_cert = ca.issue_cert("test-service.prod.us-east-1");'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'let proxy = ProxyServer::new_test()\n    .with_ca(ca.cert())\n    .start()\n    .await;\n\nlet client = Client::new()\n    .with_mtls(client_cert, client_key)\n    .connect(proxy.address())\n    .await\n    .unwrap();\n\n// Should succeed with valid cert\nlet resp = client.get("test-namespace", "key:123", "field").await;\nassert!(resp.is_ok());\n\n// Should fail with expired cert\nlet expired_cert = ca.issue_cert_with_ttl("expired", Duration::seconds(-1));\nlet bad_client = Client::new()\n    .with_mtls(expired_cert, key)\n    .connect(proxy.address())\n    .await;\n\nassert!(bad_client.is_err());\n'})}),"\n",(0,a.jsx)(n.p,{children:"}"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n## Open Questions\n\n1. **Certificate Authority**: Use company CA or service mesh (Linkerd/Istio)?\n   - **Feedback**: Use Vault for certificate management and issuance\n   - Vault PKI can act as an internal CA for mTLS certificates\n   - Integrates with existing credential management workflow\n   - Consider: Vault PKI vs external service mesh CA integration\n\n2. **Credential Caching**: How long to cache backend credentials?\n   - **Feedback**: Make it configurable, default to 24 hours\n   - Cache duration should balance security (shorter = better) with Vault load (longer = fewer requests)\n   - Consider per-backend configuration (e.g., high-security backends use shorter TTL)\n   - Implement proactive renewal before expiry to avoid cache misses\n\n3. **Connection Pooling**: Pool connections per backend or per credential?\n   - **Feedback**: Pool per-credential to avoid leaking data between connections if using multi-tenancy pattern\n   - Per-credential pooling provides isolation when multiple namespaces share a backend\n   - Prevents credential contamination across tenants\n   - Trade-off: More connection pools = higher resource usage\n   - Consider: Connection pool size limits and monitoring\n\n4. **Fallback Auth**: What to do when Vault is unavailable?\n   - **Feedback**: Can we cache auth temporarily? What are the security risks and tradeoffs?\n   - Options to explore:\n     - Cache credentials beyond TTL during Vault outage (security risk: revocation won't work)\n     - Fail closed (deny all requests) vs fail open (use cached credentials)\n     - Emergency static credentials (break-glass scenario)\n   - Security considerations:\n     - Cached credentials can't be rotated during outage\n     - Risk of using revoked credentials\n     - Audit trail gaps if Vault unavailable\n   - Recommended: Fail closed with configurable grace period for cached credentials\n   - Document incident response procedure for Vault outage\n\n5. **Observability**: How to monitor credential rotation and health?\n   - **Feedback**: Use stats for credential events and general usage (no PII)\n   - Report credential TTL in session establishment\n   - Consider refresh tokens and how they fit\n   - Metrics to expose:\n     - `credential.fetch.count` - Number of credential fetches from Vault\n     - `credential.renewal.count` - Successful/failed renewals\n     - `credential.ttl.seconds` - Remaining TTL of cached credentials\n     - `credential.cache.hit_rate` - Cache hit/miss ratio\n     - `connection.pool.size` - Per-credential pool sizes\n     - `session.establishment.duration` - Time to establish authenticated session\n   - Logs (no PII):\n     - Credential fetch/renewal events with backend ID and lease ID\n     - Certificate rotation events\n     - Authentication failures (client identity but not credentials)\n   - Consider: Refresh token pattern for long-lived sessions to reduce Vault load\n\n## References\n\n- [mTLS in Microservices](https://www.cloudflare.com/learning/access-management/what-is-mutual-tls/)\n- [HashiCorp Vault Dynamic Secrets](https://www.vaultproject.io/docs/secrets/databases)\n- [Kafka SASL/SCRAM](https://kafka.apache.org/documentation/#security_sasl_scram)\n- [NATS JWT Authentication](https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/jwt)\n- ADR-007: Authentication and Authorization\n- RFC-010: Admin Protocol with OIDC\n\n## Revision History\n\n- 2025-10-09: Initial draft with mTLS and backend authentication flows\n- 2025-10-09: Expanded open questions with feedback on Vault CA, credential caching (24hr default), per-credential connection pooling, fallback auth strategies, and observability metrics\n- 2025-10-09: Added secrets provider abstraction supporting HashiCorp Vault, AWS Secrets Manager, Google Secret Manager, and Azure Key Vault with pluggable architecture, provider comparison matrix, and multi-provider hybrid cloud deployment patterns\n\n"})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>c});var t=r(96540);const a={},s=t.createContext(a);function i(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);