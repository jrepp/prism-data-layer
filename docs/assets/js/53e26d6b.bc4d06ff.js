"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[9688],{155:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>t,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"go-concurrency-patterns","title":"ADR-014: Go Concurrency Patterns","description":"Context","source":"@site/../docs-cms/adr/014-go-concurrency-patterns.md","sourceDirName":".","slug":"/go-concurrency-patterns","permalink":"/prism-data-layer/adr/go-concurrency-patterns","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/014-go-concurrency-patterns.md","tags":[{"inline":true,"label":"go","permalink":"/prism-data-layer/adr/tags/go"},{"inline":true,"label":"concurrency","permalink":"/prism-data-layer/adr/tags/concurrency"},{"inline":true,"label":"performance","permalink":"/prism-data-layer/adr/tags/performance"},{"inline":true,"label":"patterns","permalink":"/prism-data-layer/adr/tags/patterns"}],"version":"current","sidebarPosition":14,"frontMatter":{"title":"ADR-014: Go Concurrency Patterns","status":"Accepted","date":"2025-10-07T00:00:00.000Z","deciders":"Core Team","tags":["go","concurrency","performance","patterns"]},"sidebar":"adrSidebar","previous":{"title":"ADR-013: Go Error Handling Strategy","permalink":"/prism-data-layer/adr/go-error-handling-strategy"},"next":{"title":"ADR-015: Go Testing Strategy","permalink":"/prism-data-layer/adr/go-testing-strategy"}}');var l=r(4848),i=r(8453);const t={title:"ADR-014: Go Concurrency Patterns",status:"Accepted",date:new Date("2025-10-07T00:00:00.000Z"),deciders:"Core Team",tags:["go","concurrency","performance","patterns"]},o=void 0,c={},a=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Architecture",id:"architecture",level:3},{value:"Implementation Pattern",id:"implementation-pattern",level:3},{value:"Why Fork-Join",id:"why-fork-join",level:3},{value:"Alternative: errgroup Pattern",id:"alternative-errgroup-pattern",level:3},{value:"Alternatives Considered",id:"alternatives-considered",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Implementation Notes",id:"implementation-notes",level:2},{value:"Worker Pool Sizing",id:"worker-pool-sizing",level:3},{value:"Error Propagation",id:"error-propagation",level:3},{value:"Testing Concurrency",id:"testing-concurrency",level:3},{value:"Benchmarking",id:"benchmarking",level:3},{value:"References",id:"references",level:2},{value:"Revision History",id:"revision-history",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,l.jsx)(n.p,{children:"Go tooling may require concurrent operations for:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Data migration across namespaces"}),"\n",(0,l.jsx)(n.li,{children:"Load testing multiple backends"}),"\n",(0,l.jsx)(n.li,{children:"Parallel health checks"}),"\n",(0,l.jsx)(n.li,{children:"Batch processing operations"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"We need established concurrency patterns that:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Utilize goroutines efficiently"}),"\n",(0,l.jsx)(n.li,{children:"Handle errors gracefully"}),"\n",(0,l.jsx)(n.li,{children:"Provide deterministic behavior"}),"\n",(0,l.jsx)(n.li,{children:"Scale with available resources"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,l.jsxs)(n.p,{children:["Use ",(0,l.jsx)(n.strong,{children:"fork-join concurrency model"})," with worker pools:"]}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Fork"}),": Spawn goroutines to process work in parallel"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Join"}),": Collect results and handle errors"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Worker pool"}),": Limit concurrency with configurable pool size"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Error propagation"}),": First error cancels remaining work"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Context-based cancellation"}),": Use ",(0,l.jsx)(n.code,{children:"context.Context"})," for cleanup"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"rationale",children:"Rationale"}),"\n",(0,l.jsx)(n.h3,{id:"architecture",children:"Architecture"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502  Work Queue  \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502 Distribute  \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502                         \u2502\n         FORK PHASE                     \u2502\n              \u2502                         \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n    \u2502   Worker Pool      \u2502              \u2502\n    \u2502  (goroutines)      \u2502              \u2502\n    \u2502                    \u2502              \u2502\n    \u2502  \u250c\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2510   \u2502              \u2502\n    \u2502  \u2502 W1 \u2502  \u2502 W2 \u2502   \u2502              \u2502\n    \u2502  \u2514\u2500\u252c\u2500\u2500\u2518  \u2514\u2500\u252c\u2500\u2500\u2518   \u2502              \u2502\n    \u2502    \u2502       \u2502      \u2502              \u2502\n    \u2502  \u250c\u2500\u25bc\u2500\u2500\u2510  \u250c\u2500\u25bc\u2500\u2500\u2510   \u2502              \u2502\n    \u2502  \u2502 W3 \u2502  \u2502 W4 \u2502   \u2502              \u2502\n    \u2502  \u2514\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2518   \u2502              \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n             \u2502                          \u2502\n       (process work)                   \u2502\n             \u2502                          \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n    \u2502   Results Channel  \u2502              \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n             \u2502                          \u2502\n        JOIN PHASE                      \u2502\n             \u2502                          \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n    \u2502  Collect Results   \u2502              \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n             \u2502                          \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n    \u2502   Return to Caller \u2502              \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n"})}),"\n",(0,l.jsx)(n.h3,{id:"implementation-pattern",children:"Implementation Pattern"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-go",children:'// Fork-join with worker pool\nfunc ProcessParallel(ctx context.Context, items []string, workers int) ([]Result, error) {\n    // FORK: Create channels\n    jobs := make(chan string, len(items))\n    results := make(chan Result, len(items))\n    errs := make(chan error, workers)\n\n    // Context for cancellation\n    ctx, cancel := context.WithCancel(ctx)\n    defer cancel()\n\n    // Launch worker pool\n    var wg sync.WaitGroup\n    for i := 0; i < workers; i++ {\n        wg.Add(1)\n        go worker(ctx, jobs, results, errs, &wg)\n    }\n\n    // Send jobs\n    for _, item := range items {\n        jobs <- item\n    }\n    close(jobs)\n\n    // JOIN: Collect results\n    go func() {\n        wg.Wait()\n        close(results)\n        close(errs)\n    }()\n\n    // Gather results\n    collected := make([]Result, 0, len(items))\n    for result := range results {\n        collected = append(collected, result)\n    }\n\n    // Check for errors\n    if err := <-errs; err != nil {\n        return nil, fmt.Errorf("process parallel: %w", err)\n    }\n\n    return collected, nil\n}\n\nfunc worker(ctx context.Context, jobs <-chan string, results chan<- Result, errs chan<- error, wg *sync.WaitGroup) {\n    defer wg.Done()\n\n    for item := range jobs {\n        select {\n        case <-ctx.Done():\n            return // Cancelled\n        default:\n            result, err := processItem(item)\n            if err != nil {\n                select {\n                case errs <- fmt.Errorf("worker: %w", err):\n                default: // Error already reported\n                }\n                return\n            }\n            results <- result\n        }\n    }\n}\n'})}),"\n",(0,l.jsx)(n.h3,{id:"why-fork-join",children:"Why Fork-Join"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Pros:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Simple mental model (fork work, join results)"}),"\n",(0,l.jsx)(n.li,{children:"Natural fit for embarrassingly parallel problems"}),"\n",(0,l.jsx)(n.li,{children:"Easy to reason about and test"}),"\n",(0,l.jsx)(n.li,{children:"Goroutines are lightweight (can spawn thousands)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Cons:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"May buffer all results before returning"}),"\n",(0,l.jsx)(n.li,{children:"Memory usage proportional to work size"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"alternative-errgroup-pattern",children:"Alternative: errgroup Pattern"}),"\n",(0,l.jsxs)(n.p,{children:["For simpler cases, use ",(0,l.jsx)(n.code,{children:"golang.org/x/sync/errgroup"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-go",children:'import "golang.org/x/sync/errgroup"\n\nfunc MigrateNamespaces(ctx context.Context, namespaces []string) error {\n    g, ctx := errgroup.WithContext(ctx)\n\n    for _, ns := range namespaces {\n        ns := ns // Capture for closure\n        g.Go(func() error {\n            return migrateNamespace(ctx, ns)\n        })\n    }\n\n    // Wait for all migrations, return first error\n    return g.Wait()\n}\n'})}),"\n",(0,l.jsx)(n.h3,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Sequential Processing"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Pros: Simple, deterministic, low memory"}),"\n",(0,l.jsx)(n.li,{children:"Cons: Slow for large workloads"}),"\n",(0,l.jsx)(n.li,{children:"Rejected: Unacceptable performance for batch operations"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Pipeline Pattern (stages)"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Pros: Streaming, lower memory"}),"\n",(0,l.jsx)(n.li,{children:"Cons: Complex for our use cases"}),"\n",(0,l.jsx)(n.li,{children:"Rejected: Fork-join simpler for batch processing"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Unlimited Concurrency"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Pros: Maximum speed"}),"\n",(0,l.jsx)(n.li,{children:"Cons: Resource exhaustion"}),"\n",(0,l.jsx)(n.li,{children:"Rejected: Must bound concurrency"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,l.jsx)(n.h3,{id:"positive",children:"Positive"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"10x-100x speedup"})," for parallel workloads"]}),"\n",(0,l.jsx)(n.li,{children:"Scales naturally with CPU cores"}),"\n",(0,l.jsx)(n.li,{children:"Simple implementation with goroutines and channels"}),"\n",(0,l.jsx)(n.li,{children:"Error handling via context cancellation"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"negative",children:"Negative"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Memory usage: May buffer results"}),"\n",(0,l.jsx)(n.li,{children:"Complexity: Error handling more nuanced than sequential"}),"\n",(0,l.jsx)(n.li,{children:"Requires tuning worker pool size"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"neutral",children:"Neutral"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Worker pool size configurable (default: ",(0,l.jsx)(n.code,{children:"runtime.NumCPU()"}),")"]}),"\n",(0,l.jsx)(n.li,{children:"Works well for batch operations up to 10k items"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,l.jsx)(n.h3,{id:"worker-pool-sizing",children:"Worker Pool Sizing"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-go",children:'// Default: match CPU cores\nfunc DefaultWorkers() int {\n    return runtime.NumCPU()\n}\n\n// Allow override via flag\nvar workers = flag.Int("workers", DefaultWorkers(), "concurrent workers")\n'})}),"\n",(0,l.jsx)(n.h3,{id:"error-propagation",children:"Error Propagation"}),"\n",(0,l.jsxs)(n.p,{children:["First error cancels all workers via ",(0,l.jsx)(n.code,{children:"context.Context"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-go",children:"ctx, cancel := context.WithCancel(ctx)\ndefer cancel()\n\n// First error triggers cancellation\ncase errs <- err:\n    cancel() // Stop all workers\n"})}),"\n",(0,l.jsx)(n.h3,{id:"testing-concurrency",children:"Testing Concurrency"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-go",children:'func TestProcessParallel_Concurrent(t *testing.T) {\n    items := []string{"a", "b", "c", "d", "e"}\n\n    // Test with different worker counts\n    for _, workers := range []int{1, 2, 4, 8} {\n        t.Run(fmt.Sprintf("workers=%d", workers), func(t *testing.T) {\n            results, err := ProcessParallel(context.Background(), items, workers)\n            if err != nil {\n                t.Fatal(err)\n            }\n\n            if len(results) != len(items) {\n                t.Errorf("got %d results, want %d", len(results), len(items))\n            }\n        })\n    }\n}\n'})}),"\n",(0,l.jsx)(n.h3,{id:"benchmarking",children:"Benchmarking"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-go",children:"func BenchmarkProcessSequential(b *testing.B) {\n    items := generateItems(1000)\n    for i := 0; i < b.N; i++ {\n        processSequential(items)\n    }\n}\n\nfunc BenchmarkProcessParallel(b *testing.B) {\n    items := generateItems(1000)\n    for i := 0; i < b.N; i++ {\n        ProcessParallel(context.Background(), items, runtime.NumCPU())\n    }\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"https://go.dev/blog/pipelines",children:"Go Concurrency Patterns: Pipelines and cancellation"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"https://go.dev/doc/effective_go#concurrency",children:"Effective Go: Concurrency"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"https://pkg.go.dev/golang.org/x/sync/errgroup",children:"errgroup documentation"})}),"\n",(0,l.jsx)(n.li,{children:"ADR-012: Go for Tooling"}),"\n",(0,l.jsx)(n.li,{children:"ADR-013: Go Error Handling Strategy"}),"\n",(0,l.jsx)(n.li,{children:"org-stream-producer ADR-006: Concurrency Model"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"2025-10-07: Initial draft and acceptance (adapted from org-stream-producer)"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>o});var s=r(6540);const l={},i=s.createContext(l);function t(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:t(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);