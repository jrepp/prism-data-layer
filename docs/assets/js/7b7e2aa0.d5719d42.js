"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[70320],{28453:(e,t,a)=>{a.d(t,{R:()=>r,x:()=>o});var s=a(96540);const i={},n=s.createContext(i);function r(e){const t=s.useContext(n);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(n.Provider,{value:t},e.children)}},85602:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"netflix-abstractions","title":"Netflix Data Abstractions","description":"Besides Key-Value (KV) and TimeSeries, Netflix has built several other abstractions on its Data Gateway platform, including a Distributed Counter and a Write-Ahead Log (WAL). This highlights the platform\'s versatility, allowing for different data access patterns beyond the two most commonly cited examples.","source":"@site/../docs-cms/netflix/abstractions.md","sourceDirName":".","slug":"/netflix-abstractions","permalink":"/prism-data-layer/netflix/netflix-abstractions","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/netflix/abstractions.md","tags":[{"inline":true,"label":"netflix","permalink":"/prism-data-layer/netflix/tags/netflix"},{"inline":true,"label":"abstractions","permalink":"/prism-data-layer/netflix/tags/abstractions"},{"inline":true,"label":"key-value","permalink":"/prism-data-layer/netflix/tags/key-value"},{"inline":true,"label":"timeseries","permalink":"/prism-data-layer/netflix/tags/timeseries"},{"inline":true,"label":"counter","permalink":"/prism-data-layer/netflix/tags/counter"},{"inline":true,"label":"wal","permalink":"/prism-data-layer/netflix/tags/wal"}],"version":"current","sidebarPosition":3,"frontMatter":{"id":"netflix-abstractions","title":"Netflix Data Abstractions","sidebar_label":"Abstractions","sidebar_position":3,"tags":["netflix","abstractions","key-value","timeseries","counter","wal"]},"sidebar":"netflixSidebar","previous":{"title":"Scale","permalink":"/prism-data-layer/netflix/netflix-scale"},"next":{"title":"Use Cases","permalink":"/prism-data-layer/netflix/netflix-key-use-cases"}}');var i=a(74848),n=a(28453);const r={id:"netflix-abstractions",title:"Netflix Data Abstractions",sidebar_label:"Abstractions",sidebar_position:3,tags:["netflix","abstractions","key-value","timeseries","counter","wal"]},o=void 0,l={},c=[];function d(e){const t={p:"p",...(0,n.R)(),...e.components};return(0,i.jsx)(t.p,{children:'Besides Key-Value (KV) and TimeSeries, Netflix has built several other abstractions on its Data Gateway platform, including a Distributed Counter and a Write-Ahead Log (WAL). This highlights the platform\'s versatility, allowing for different data access patterns beyond the two most commonly cited examples.\nDistributed Counter Abstraction\nThe Distributed Counter Abstraction is a specialized service built on the Data Gateway to handle counting immutable events at a massive scale.\nPurpose: Tracks and measures user interactions and business performance metrics with different trade-offs for speed and accuracy.\nArchitecture: Built on top of the TimeSeries abstraction, it logs each counting event as an immutable record in a durable storage system like Cassandra.\nCounting modes: It offers several modes to meet different use cases, including:\nBest-Effort Regional Counter: Built on EVCache (a distributed caching solution), it provides very low latency but approximate counts and lacks global consistency or durability. It is useful for scenarios like A/B testing where exact numbers are not critical.\nEventually Consistent Global Counter: Provides durability and global consistency at the cost of some latency by using a background rollup process that aggregates events stored in the TimeSeries abstraction.\nAccurate Global Counter: An experimental approach that computes real-time deltas on top of the rolled-up count to provide stronger accuracy guarantees.\nWrite-Ahead Log (WAL) Abstraction\nThe Write-Ahead Log is a crucial abstraction for ensuring the resilience and reliability of other services.\nPurpose: The WAL is designed to provide a reliable way to durably log events before they are processed by a system. This ensures that even if a service crashes, the event stream is not lost and can be reprocessed later.\nArchitecture: The WAL abstraction is deployed as shards, with each use case receiving its own isolated shard to prevent the "noisy neighbor" problem. It uses namespaces to apply the correct configuration for each use case.\nResilience: The WAL, like other abstractions, uses resilience techniques like adaptive load shedding to protect the system from traffic overloads.\nOther potential abstractions\nWhile not as well-documented as the KV, TimeSeries, and Counter abstractions, other types of abstractions can be, and have been, built on the Data Gateway.\nTree Abstraction: An early talk on data abstraction mentioned the concept of a "tree abstraction" used in conjunction with the KV abstraction to solve bigger problems.\nUI Personalization Abstraction: This could be another layer built on top of the KV abstraction to solve specific personalization needs.\nIn essence, the Data Gateway is a foundational platform that provides a standard set of tools for developing, deploying, and managing a variety of data-specific abstractions. The KV and TimeSeries abstractions are just two examples, with the Counter and WAL being other notable services that leverage the same platform principles'})}function u(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);