"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[282],{28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>l});var t=r(96540);const s={},i=t.createContext(s);function a(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(i.Provider,{value:n},e.children)}},47424:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"adr-008","title":"Observability Strategy","description":"Context","source":"@site/../docs-cms/adr/adr-008-observability-strategy.md","sourceDirName":".","slug":"/adr-008","permalink":"/prism-data-layer/adr/adr-008","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/adr-008-observability-strategy.md","tags":[{"inline":true,"label":"operations","permalink":"/prism-data-layer/adr/tags/operations"},{"inline":true,"label":"performance","permalink":"/prism-data-layer/adr/tags/performance"},{"inline":true,"label":"reliability","permalink":"/prism-data-layer/adr/tags/reliability"}],"version":"current","frontMatter":{"date":"2025-10-05T00:00:00.000Z","deciders":"Core Team","doc_uuid":"7bb15ce7-f0c5-4fef-ac53-a5d253411068","id":"adr-008","project_id":"prism-data-layer","status":"Accepted","tags":["operations","performance","reliability"],"title":"Observability Strategy"},"sidebar":"adrSidebar","previous":{"title":"Authentication and Authorization \u2022 ADR-007","permalink":"/prism-data-layer/adr/adr-007"},"next":{"title":"Shadow Traffic for Migrations \u2022 ADR-009","permalink":"/prism-data-layer/adr/adr-009"}}');var s=r(74848),i=r(28453);const a={date:new Date("2025-10-05T00:00:00.000Z"),deciders:"Core Team",doc_uuid:"7bb15ce7-f0c5-4fef-ac53-a5d253411068",id:"adr-008",project_id:"prism-data-layer",status:"Accepted",tags:["operations","performance","reliability"],title:"Observability Strategy"},l=void 0,o={},c=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Why OpenTelemetry?",id:"why-opentelemetry",level:3},{value:"Architecture",id:"architecture",level:3},{value:"Sampling",id:"sampling",level:3},{value:"Alerts",id:"alerts",level:3},{value:"Alternatives Considered",id:"alternatives-considered",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Implementation Notes",id:"implementation-notes",level:2},{value:"OpenTelemetry Setup",id:"opentelemetry-setup",level:3},{value:"Context Propagation",id:"context-propagation",level:3},{value:"References",id:"references",level:2},{value:"Revision History",id:"revision-history",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",response:"response",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,s.jsx)(n.p,{children:"Prism is critical infrastructure sitting in the data path. We must be able to:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Debug issues quickly"}),": When things go wrong, understand why"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Monitor health"}),": Know if Prism is operating correctly"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Track performance"}),": Measure latency, throughput, errors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Capacity planning"}),": Understand resource usage trends"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Compliance"}),": Audit logging for regulatory requirements"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Observability has three pillars:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Metrics"}),": Numerical measurements (latency, RPS, error rate)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Logs"}),": Structured events (request details, errors)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Traces"}),": Request flow through distributed system"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,s.jsxs)(n.p,{children:["Adopt ",(0,s.jsx)(n.strong,{children:"OpenTelemetry"})," from day one for metrics, logs, and traces. Use ",(0,s.jsx)(n.strong,{children:"Prometheus"})," for metrics storage, ",(0,s.jsx)(n.strong,{children:"Loki"})," for logs, and ",(0,s.jsx)(n.strong,{children:"Jaeger/Tempo"})," for traces."]}),"\n",(0,s.jsx)(n.h2,{id:"rationale",children:"Rationale"}),"\n",(0,s.jsx)(n.h3,{id:"why-opentelemetry",children:"Why OpenTelemetry?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Vendor neutral"}),": Not locked into specific backend"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Industry standard"}),": Wide adoption, good tooling"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Unified SDK"}),": One library for metrics, logs, traces"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rust support"}),": Excellent ",(0,s.jsx)(n.code,{children:"opentelemetry-rust"})," crate"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Future-proof"}),": CNCF graduated project"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"architecture",children:"Architecture"}),"\n",(0,s.jsx)(n.p,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Prism Proxy \u2502\n\u2502             \u2502\n\u2502 OpenTelemetry SDK\n\u2502   \u251c\u2500 Metrics \u2500\u2500\u2500\u2500\u2500\u25ba Prometheus\n\u2502   \u251c\u2500 Logs \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba Loki\n\u2502   \u2514\u2500 Traces \u2500\u2500\u2500\u2500\u2500\u2500\u25ba Jaeger/Tempo\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n### Metrics\n\n**Key Metrics** (Prometheus format):\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"use prometheus::{\nregister_histogram_vec, register_counter_vec,\nHistogramVec, CounterVec,\n};"}),"\n",(0,s.jsx)(n.p,{children:'lazy_static! {\n// Request latency\nstatic ref REQUEST_DURATION: HistogramVec = register_histogram_vec!(\n"prism_request_duration_seconds",\n"Request latency in seconds",\n&["namespace", "operation", "backend"],\nvec![0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0]\n).unwrap();'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'// Request count\nstatic ref REQUEST_COUNT: CounterVec = register_counter_vec!(\n    "prism_requests_total",\n    "Total requests",\n    &["namespace", "operation", "status"]\n).unwrap();\n\n// Backend connection pool\nstatic ref POOL_SIZE: GaugeVec = register_gauge_vec!(\n    "prism_backend_pool_size",\n    "Backend connection pool size",\n    &["backend"]\n).unwrap();\n'})}),"\n",(0,s.jsx)(n.p,{children:"}"}),"\n",(0,s.jsx)(n.p,{children:'// Usage\nlet timer = REQUEST_DURATION\n.with_label_values(&[namespace, "get", "postgres"])\n.start_timer();'}),"\n",(0,s.jsx)(n.p,{children:"// ... do work ..."}),"\n",(0,s.jsx)(n.p,{children:"timer.observe_duration();"}),"\n",(0,s.jsx)(n.p,{children:'REQUEST_COUNT\n.with_label_values(&[namespace, "get", "success"])\n.inc();'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n**Dashboards**:\n- **Golden Signals**: Latency, Traffic, Errors, Saturation\n- **Per-Namespace**: Breakdown by namespace\n- **Per-Backend**: Backend-specific metrics\n\n### Structured Logging\n\n**Format**: JSON for machine parsing\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"use tracing::{info, error, instrument};\nuse tracing_subscriber::fmt::format::json;"}),"\n",(0,s.jsxs)(n.p,{children:["#[instrument(\nskip(request),\nfields(\nrequest_id = %request.id,\nnamespace = %request.namespace,\noperation = %request.operation,\n)\n)]\nasync fn handle_request(request: Request) -> Result",(0,s.jsx)(n.response,{children:' {\ninfo!("Processing request");'})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'match process(&request).await {\n    Ok(response) => {\n        info!(\n            latency_ms = response.latency_ms,\n            backend = %response.backend,\n            "Request succeeded"\n        );\n        Ok(response)\n    }\n    Err(e) => {\n        error!(\n            error = %e,\n            error_kind = ?e.kind(),\n            "Request failed"\n        );\n        Err(e)\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"}"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n**Log Output**:\n"})}),"\n",(0,s.jsx)(n.p,{children:'{\n"timestamp": "2025-10-05T12:34:56.789Z",\n"level": "INFO",\n"message": "Request succeeded",\n"request_id": "req-abc-123",\n"namespace": "user-profiles",\n"operation": "get",\n"latency_ms": 2.3,\n"backend": "postgres",\n"span": {\n"name": "handle_request",\n"trace_id": "0af7651916cd43dd8448eb211c80319c"\n}\n}'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n**Log Levels**:\n- `ERROR`: Something failed, needs immediate attention\n- `WARN`: Something unexpected, may need attention\n- `INFO`: Important events (requests, config changes)\n- `DEBUG`: Detailed events (SQL queries, cache hits)\n- `TRACE`: Very verbose (every function call)\n\nProduction: `INFO` level\nDevelopment: `DEBUG` level\n\n### Distributed Tracing\n\n**Trace Example**:\n\nGET /namespaces/user-profiles/items/user123\n\u2502\n\u251c\u2500 [2.5ms] prism.proxy.handle_request\n\u2502  \u2502\n\u2502  \u251c\u2500 [0.1ms] prism.authz.authorize\n\u2502  \u2502\n\u2502  \u251c\u2500 [0.2ms] prism.router.route\n\u2502  \u2502\n\u2502  \u2514\u2500 [2.1ms] prism.backend.postgres.get\n\u2502     \u2502\n\u2502     \u251c\u2500 [0.3ms] postgres.acquire_connection\n\u2502     \u2502\n\u2502     \u2514\u2500 [1.7ms] postgres.execute_query\n\u2502        \u2502\n\u2502        \u2514\u2500 [1.5ms] SELECT FROM user_profiles WHERE id = $1\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Implementation"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use opentelemetry::trace::{Tracer, SpanKind};\nuse tracing_opentelemetry::OpenTelemetryLayer;\n\n#[instrument]\nasync fn handle_request(request: Request) -> Result<Response> {\n    let span = tracing::Span::current();\n\n    // Add attributes\n    span.record("namespace", &request.namespace);\n    span.record("operation", &request.operation);\n\n    // Child span for backend call\n    let response = {\n        let _guard = tracing::info_span!("backend.get",\n            backend = "postgres"\n        ).entered();\n\n        backend.get(&request).await?\n    };\n\n    span.record("latency_ms", response.latency_ms);\n    Ok(response)\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"sampling",children:"Sampling"}),"\n",(0,s.jsx)(n.p,{children:"Full traces are expensive. Sample based on:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use opentelemetry::sdk::trace::{Sampler, SamplingDecision};\n\npub struct AdaptiveSampler {\n    // Always sample errors\n    // Always sample slow requests (> 100ms)\n    // Sample 1% of normal requests\n}\n\nimpl Sampler for AdaptiveSampler {\n    fn should_sample(&self, context: &SamplingContext) -> SamplingDecision {\n        // Error? Always sample\n        if context.has_error {\n            return SamplingDecision::RecordAndSample;\n        }\n\n        // Slow? Always sample\n        if context.duration > Duration::from_millis(100) {\n            return SamplingDecision::RecordAndSample;\n        }\n\n        // Otherwise, 1% sample rate\n        if rand::random::<f64>() < 0.01 {\n            return SamplingDecision::RecordAndSample;\n        }\n\n        SamplingDecision::Drop\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"alerts",children:"Alerts"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Critical Alerts"})," (page on-call):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'- alert: PrismHighErrorRate\n  expr: |\n    (\n      sum(rate(prism_requests_total{status="error"}[5m]))\n      /\n      sum(rate(prism_requests_total[5m]))\n    ) > 0.01\n  for: 2m\n  annotations:\n    summary: "Prism error rate > 1%"\n\n- alert: PrismHighLatency\n  expr: |\n    histogram_quantile(0.99,\n      rate(prism_request_duration_seconds_bucket[5m])\n    ) > 0.1\n  for: 5m\n  annotations:\n    summary: "Prism P99 latency > 100ms"\n\n- alert: PrismDown\n  expr: up{job="prism"} == 0\n  for: 1m\n  annotations:\n    summary: "Prism instance is down"\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Warning Alerts"})," (Slack notification):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'- alert: PrismElevatedLatency\n  expr: |\n    histogram_quantile(0.99,\n      rate(prism_request_duration_seconds_bucket[5m])\n    ) > 0.05\n  for: 10m\n  annotations:\n    summary: "Prism P99 latency > 50ms"\n\n- alert: PrismHighCacheEvictionRate\n  expr: rate(prism_cache_evictions_total[5m]) > 100\n  for: 5m\n  annotations:\n    summary: "High cache eviction rate"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Roll Our Own Metrics"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Pros: Full control"}),"\n",(0,s.jsx)(n.li,{children:"Cons: Reinventing the wheel, no ecosystem"}),"\n",(0,s.jsx)(n.li,{children:"Rejected: Not worth the effort"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Datadog/New Relic (Commercial)"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Pros: Turnkey solution, great UI"}),"\n",(0,s.jsx)(n.li,{children:"Cons: Expensive, vendor lock-in"}),"\n",(0,s.jsx)(n.li,{children:"Rejected: Prefer open source"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Jaeger Only"})," (no Prometheus)"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Pros: Simpler stack"}),"\n",(0,s.jsx)(n.li,{children:"Cons: Traces alone insufficient for monitoring"}),"\n",(0,s.jsx)(n.li,{children:"Rejected: Need metrics for alerts"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"No Structured Logging"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Pros: Simpler"}),"\n",(0,s.jsx)(n.li,{children:"Cons: Hard to query, no context"}),"\n",(0,s.jsx)(n.li,{children:"Rejected: Structured logs essential"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,s.jsx)(n.h3,{id:"positive",children:"Positive"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Comprehensive Visibility"}),": Metrics, logs, traces cover all aspects"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Vendor Neutral"}),": Can switch backends (Tempo, Grafana Cloud, etc.)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Industry Standard"}),": OpenTelemetry is well-supported"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Debugging Power"}),": Distributed traces show exact request flow"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"negative",children:"Negative"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource Overhead"}),": Metrics/traces use CPU/memory\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"Mitigation"}),": Sampling, async export"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Operational Complexity"}),": More services to run (Prometheus, Loki, Jaeger)\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"Mitigation"}),": Use managed services or existing infrastructure"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"neutral",children:"Neutral"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Learning Curve"}),": Team must learn OpenTelemetry\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Good investment; transferable skill"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,s.jsx)(n.h3,{id:"opentelemetry-setup",children:"OpenTelemetry Setup"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use opentelemetry::sdk::trace::{self, Tracer};\nuse opentelemetry::global;\nuse tracing_subscriber::{layer::SubscriberExt, Registry};\nuse tracing_opentelemetry::OpenTelemetryLayer;\n\nfn init_telemetry() -> Result<()> {\n    // Tracer\n    let tracer = opentelemetry_jaeger::new_pipeline()\n        .with_service_name("prism-proxy")\n        .with_agent_endpoint("jaeger:6831")\n        .install_batch(opentelemetry::runtime::Tokio)?;\n\n    // Logging + tracing layer\n    let telemetry_layer = OpenTelemetryLayer::new(tracer);\n\n    let subscriber = Registry::default()\n        .with(tracing_subscriber::fmt::layer().json())\n        .with(telemetry_layer);\n\n    tracing::subscriber::set_global_default(subscriber)?;\n\n    // Metrics\n    let prometheus_exporter = opentelemetry_prometheus::exporter()\n        .with_registry(prometheus::default_registry().clone())\n        .init();\n\n    global::set_meter_provider(prometheus_exporter);\n\n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"context-propagation",children:"Context Propagation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// Extract trace context from gRPC metadata\nuse tonic::metadata::MetadataMap;\nuse opentelemetry::propagation::TextMapPropagator;\n\nfn extract_trace_context(metadata: &MetadataMap) -> Context {\n    let propagator = TraceContextPropagator::new();\n    let extractor = MetadataExtractor(metadata);\n    propagator.extract(&extractor)\n}\n\n// Inject trace context when calling backend\nfn inject_trace_context(context: &Context) -> MetadataMap {\n    let propagator = TraceContextPropagator::new();\n    let mut metadata = MetadataMap::new();\n    let mut injector = MetadataInjector(&mut metadata);\n    propagator.inject_context(context, &mut injector);\n    metadata\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://opentelemetry.io/docs/specs/otel/",children:"OpenTelemetry Specification"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://prometheus.io/docs/practices/naming/",children:"Prometheus Best Practices"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://sre.google/sre-book/monitoring-distributed-systems/",children:"Google SRE - Monitoring Distributed Systems"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://tokio.rs/tokio/topics/tracing",children:"Tracing in Rust"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"2025-10-05: Initial draft and acceptance"}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);