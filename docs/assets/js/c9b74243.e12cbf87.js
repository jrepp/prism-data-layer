"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[5759],{28453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>l});var r=a(96540);const s={},t=r.createContext(s);function i(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(t.Provider,{value:n},e.children)}},39877:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"adr-034","title":"Product/Feature Sharding Strategy","description":"Context","source":"@site/../docs-cms/adr/adr-034-sharding-strategy.md","sourceDirName":".","slug":"/adr-034","permalink":"/prism-data-layer/adr/adr-034","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/adr-034-sharding-strategy.md","tags":[{"inline":true,"label":"architecture","permalink":"/prism-data-layer/adr/tags/architecture"},{"inline":true,"label":"deployment","permalink":"/prism-data-layer/adr/tags/deployment"},{"inline":true,"label":"reliability","permalink":"/prism-data-layer/adr/tags/reliability"},{"inline":true,"label":"operations","permalink":"/prism-data-layer/adr/tags/operations"},{"inline":true,"label":"performance","permalink":"/prism-data-layer/adr/tags/performance"}],"version":"current","frontMatter":{"date":"2025-10-08T00:00:00.000Z","deciders":"System","doc_uuid":"9a33cd32-237a-421f-9646-977f95d91c82","id":"adr-034","project_id":"prism-data-layer","status":"Proposed","tags":["architecture","deployment","reliability","operations","performance"],"title":"Product/Feature Sharding Strategy"},"sidebar":"adrSidebar","previous":{"title":"Capability API for Prism Instance Queries \u2022 ADR-033","permalink":"/prism-data-layer/adr/adr-033"},"next":{"title":"Database Connection Pooling vs Direct Connections \u2022 ADR-035","permalink":"/prism-data-layer/adr/adr-035"}}');var s=a(74848),t=a(28453);const i={date:new Date("2025-10-08T00:00:00.000Z"),deciders:"System",doc_uuid:"9a33cd32-237a-421f-9646-977f95d91c82",id:"adr-034",project_id:"prism-data-layer",status:"Proposed",tags:["architecture","deployment","reliability","operations","performance"],title:"Product/Feature Sharding Strategy"},l=void 0,o={},c=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"1. <strong>Namespace-Level Isolation</strong> (Already Exists)",id:"1-namespace-level-isolation-already-exists",level:3},{value:"2. <strong>Proxy Instance Sharding</strong> (New)",id:"2-proxy-instance-sharding-new",level:3},{value:"3. <strong>Backend Cluster Sharding</strong> (New)",id:"3-backend-cluster-sharding-new",level:3},{value:"Sharding Taxonomy",id:"sharding-taxonomy",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,s.jsx)(n.p,{children:"As Prism scales to support multiple products and features, we need a strategy for isolating workloads to prevent:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Noisy Neighbor Problems"}),": High-traffic feature affecting low-latency feature"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Blast Radius"}),": Incidents in one product affecting others"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource Contention"}),": Shared connection pools, memory, CPU causing unpredictable performance"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Deployment Risk"}),": Changes to support one feature breaking another"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Netflix's Data Gateway experience shows that ",(0,s.jsx)(n.strong,{children:"shared infrastructure leads to operational complexity at scale"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"One team's traffic spike affects unrelated services"}),"\n",(0,s.jsx)(n.li,{children:"Debugging performance issues requires analyzing all tenants"}),"\n",(0,s.jsx)(n.li,{children:"Rolling out backend changes requires coordinating with all affected teams"}),"\n",(0,s.jsx)(n.li,{children:"Capacity planning becomes combinatorially complex"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"From Netflix's scale metrics:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"8 million QPS"})," across key-value abstraction"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"3,500+ use cases"})," sharing infrastructure"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"10 million writes/sec"})," for time-series data"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["At this scale, ",(0,s.jsx)(n.strong,{children:"sharding becomes essential"})," for operational sanity and performance isolation."]}),"\n",(0,s.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Implement multi-level sharding strategy"})," based on product/feature boundaries:"]}),"\n",(0,s.jsxs)(n.h3,{id:"1-namespace-level-isolation-already-exists",children:["1. ",(0,s.jsx)(n.strong,{children:"Namespace-Level Isolation"})," (Already Exists)"]}),"\n",(0,s.jsx)(n.p,{children:"Each namespace gets isolated:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Backend connections"}),"\n",(0,s.jsx)(n.li,{children:"Authentication context"}),"\n",(0,s.jsx)(n.li,{children:"Rate limits"}),"\n",(0,s.jsx)(n.li,{children:"Metrics"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"2-proxy-instance-sharding-new",children:["2. ",(0,s.jsx)(n.strong,{children:"Proxy Instance Sharding"})," (New)"]}),"\n",(0,s.jsx)(n.p,{children:"Deploy separate Prism proxy instances for:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Product Sharding"}),": Different products (recommendation, playback, search)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Feature Sharding"}),": Different features within a product (experimental vs stable)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SLA Tiers"}),": Different latency/availability requirements"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"3-backend-cluster-sharding-new",children:["3. ",(0,s.jsx)(n.strong,{children:"Backend Cluster Sharding"})," (New)"]}),"\n",(0,s.jsx)(n.p,{children:"Dedicated backend clusters per shard:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Prevents cross-product resource contention"}),"\n",(0,s.jsx)(n.li,{children:"Enables independent scaling"}),"\n",(0,s.jsx)(n.li,{children:"Allows backend version divergence"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"sharding-taxonomy",children:"Sharding Taxonomy"}),"\n",(0,s.jsx)(n.p,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Organization                              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  Product: Playback   \u2502  \u2502  Product: Recommendation  \u2502   \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502   \u2502\n\u2502  \u2502  \u2502 Feature: Live  \u2502  \u2502  \u2502  \u2502  Feature: Trending  \u2502  \u2502   \u2502\n\u2502  \u2502  \u2502 SLA: P99<10ms  \u2502  \u2502  \u2502  \u2502  SLA: P99<50ms      \u2502  \u2502   \u2502\n\u2502  \u2502  \u2502                \u2502  \u2502  \u2502  \u2502                     \u2502  \u2502   \u2502\n\u2502  \u2502  \u2502 Prism Instance \u2502  \u2502  \u2502  \u2502  Prism Instance     \u2502  \u2502   \u2502\n\u2502  \u2502  \u2502   prism-play   \u2502  \u2502  \u2502  \u2502    prism-rec        \u2502  \u2502   \u2502\n\u2502  \u2502  \u2502       \u2193        \u2502  \u2502  \u2502  \u2502        \u2193            \u2502  \u2502   \u2502\n\u2502  \u2502  \u2502  Redis Cluster \u2502  \u2502  \u2502  \u2502  Postgres Cluster   \u2502  \u2502   \u2502\n\u2502  \u2502  \u2502   redis-live   \u2502  \u2502  \u2502  \u2502   pg-trending       \u2502  \u2502   \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n## Rationale\n\n### Why Shard by Product/Feature?\n\n**Netflix's Lessons**:\n- **Fault Isolation**: Cassandra cluster failure affects only one product, not all\n- **Performance Predictability**: Each product has dedicated resources, no surprise degradation\n- **Independent Evolution**: Upgrade Kafka version for analytics without affecting playback\n- **Clear Ownership**: Each product team owns their Prism shard and backend\n\n**Specific Examples from Netflix**:\n- Search traffic reduced by 75% with client-side compression \u2192 didn't affect other products\n- Maestro workflow engine \"100x faster\" redesign \u2192 isolated deployment, no cross-product risk\n- Time-series data (10M writes/sec) \u2192 separate clusters from key-value (8M QPS)\n\n### Sharding Dimensions\n\n| Dimension | Rationale | Example |\n|-----------|-----------|---------|\n| **Product** | Different products have different scale/SLAs | Playback (low latency) vs Analytics (high throughput) |\n| **Feature** | Experimental features shouldn't affect stable | Canary testing new cache strategy |\n| **SLA Tier** | Different availability/latency requirements | P99 &lt;10ms vs P99 &lt;100ms |\n| **Region** | Regulatory/latency requirements | US-West vs EU (GDPR) |\n| **Environment** | Dev/staging/prod isolation | Prevents test traffic affecting prod |\n\n### When to Shard\n\n**Shard proactively when**:\n- Traffic exceeds 10K RPS for a single namespace\n- P99 latency SLA is &lt;50ms (needs dedicated resources)\n- Product has distinct backend requirements (different databases)\n- Regulatory isolation required (GDPR, HIPAA)\n\n**Delay sharding when**:\n- Total traffic &lt;1K RPS across all namespaces\n- Products have similar SLAs and resource profiles\n- Operational overhead of managing multiple instances outweighs benefits\n\n## Alternatives Considered\n\n### 1. Single Shared Prism Instance for All\n\n- **Pros**: Simple, minimal operational overhead, efficient resource utilization\n- **Cons**: Noisy neighbor, blast radius, complex capacity planning\n- **Rejected because**: Doesn't scale operationally beyond ~10 products\n\n### 2. One Prism Instance Per Namespace\n\n- **Pros**: Maximum isolation\n- **Cons**: Massive operational overhead (1000s of instances), resource waste\n- **Rejected because**: Operationally infeasible at scale\n\n### 3. Dynamic Auto-Sharding (Like Database Sharding)\n\n- **Pros**: Automatic, adapts to load\n- **Cons**: Complex routing, hard to debug, unclear ownership\n- **Rejected because**: Too complex for initial version, unclear operational model\n\n## Consequences\n\n### Positive\n\n- **Fault Isolation**: Product A's outage doesn't affect Product B\n- **Performance Predictability**: Dedicated resources mean stable latency\n- **Independent Deployment**: Upgrade Prism for one product without risk to others\n- **Clear Ownership**: Each product team owns their shard\n- **Simplified Capacity Planning**: Plan per-product instead of combinatorially\n- **Regulatory Compliance**: Easy to isolate GDPR/HIPAA data\n\n### Negative\n\n- **Operational Overhead**: More instances to deploy, monitor, maintain\n- **Resource Efficiency**: May underutilize resources if shards are too granular\n- **Cross-Product Features**: Harder to implement features that span products\n- **Configuration Management**: Need tooling to manage multiple instances\n\n### Neutral\n\n- **Sharding Decisions**: Need clear criteria for when to create new shard\n- **Routing Layer**: May need service mesh or load balancer to route to shards\n- **Cost**: More instances = higher cost, but may be offset by better resource utilization per shard\n\n## Implementation Notes\n\n### Deployment Topology\n\n**Shared Namespace Proxy (Small Scale)**:\n"})}),"\n",(0,s.jsx)(n.h1,{id:"single-prism-instance-multiple-namespaces",children:"Single Prism instance, multiple namespaces"}),"\n",(0,s.jsx)(n.p,{children:"services:\nprism-shared:\nimage: prism/proxy:latest\nreplicas: 3\nnamespaces:\n- user-profiles\n- session-cache\n- recommendations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n**Product-Sharded Deployment (Medium Scale)**:\n"})}),"\n",(0,s.jsx)(n.h1,{id:"separate-prism-instances-per-product",children:"Separate Prism instances per product"}),"\n",(0,s.jsx)(n.p,{children:"services:\nprism-playback:\nimage: prism/proxy:latest\nreplicas: 5\nnamespaces:\n- playback-events\n- playback-state"}),"\n",(0,s.jsx)(n.p,{children:"prism-search:\nimage: prism/proxy:latest\nreplicas: 3\nnamespaces:\n- search-index\n- search-cache"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n**Feature + SLA Sharded (Large Scale)**:\n"})}),"\n",(0,s.jsx)(n.h1,{id:"sharded-by-product-feature-and-sla-tier",children:"Sharded by product, feature, and SLA tier"}),"\n",(0,s.jsx)(n.p,{children:"services:\nprism-playback-live:  # Low latency tier\nimage: prism/proxy:latest\nreplicas: 10\nsla: p99_10ms\nbackends:\n- redis-live-cluster"}),"\n",(0,s.jsx)(n.p,{children:"prism-playback-vod:  # Standard latency tier\nimage: prism/proxy:latest\nreplicas: 5\nsla: p99_50ms\nbackends:\n- redis-vod-cluster"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n### Routing to Shards\n\n**Service Mesh Approach** (Recommended):\n"})}),"\n",(0,s.jsx)(n.h1,{id:"istio-virtualservice-routes-clients-to-correct-shard",children:"Istio VirtualService routes clients to correct shard"}),"\n",(0,s.jsx)(n.p,{children:"apiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\nname: prism-routing\nspec:\nhosts:\n- prism.example.com\nhttp:\n- match:\n- headers:\nx-product:\nexact: playback\nroute:\n- destination:\nhost: prism-playback\n- match:\n- headers:\nx-product:\nexact: search\nroute:\n- destination:\nhost: prism-search"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n**Client-Side Routing**:\n"})}),"\n",(0,s.jsx)(n.p,{children:'// Client selects shard based on product\nlet prism_endpoint = match product {\nProduct::Playback => "prism-playback.example.com:50051",\nProduct::Search => "prism-search.example.com:50051",\nProduct::Recommendations => "prism-rec.example.com:50051",\n};'}),"\n",(0,s.jsx)(n.p,{children:"let client = PrismClient::connect(prism_endpoint).await?;"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n### Configuration Management\n\nUse Kubernetes ConfigMaps or CRDs to define shards:\n\n"})}),"\n",(0,s.jsx)(n.p,{children:'apiVersion: prism.io/v1alpha1\nkind: PrismShard\nmetadata:\nname: playback-live\nspec:\nproduct: playback\nfeature: live\nslaTier: p99_10ms\nreplicas: 10\nbackends:\n- name: redis-live\ntype: redis\ncluster: redis-live-01\nnamespaces:\n- playback-events\n- playback-state\nresources:\nrequests:\ncpu: "4"\nmemory: "8Gi"'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n(See ADR-037 for Kubernetes Operator details)\n\n### Migration Path\n\n**Phase 1**: Single shared instance (current state)\n**Phase 2**: Shard by product (2-3 products initially)\n**Phase 3**: Shard by product + SLA tier (as traffic grows)\n**Phase 4**: Full product/feature/region sharding (Netflix scale)\n\n## References\n\n- [Netflix Data Gateway Scale](/prism-data-layer/netflix/scale) - 8M QPS, 3500+ use cases\n- [Netflix Multi-Region Deployment](/prism-data-layer/netflix/key-use-cases)\n- ADR-033: Capability API (shard discovery)\n- ADR-037: Kubernetes Operator (shard management automation)\n- RFC-008: Proxy Plugin Architecture (backend isolation per shard)\n\n## Revision History\n\n- 2025-10-08: Initial draft based on Netflix's sharding experience\n\n"})})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);