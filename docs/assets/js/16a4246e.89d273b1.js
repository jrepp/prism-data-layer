"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[31924],{28453:(n,e,i)=>{i.d(e,{R:()=>t,x:()=>o});var r=i(96540);const s={},a=r.createContext(s);function t(n){const e=r.useContext(a);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:t(n.components),r.createElement(a.Provider,{value:e},n.children)}},74470:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>t,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"adr-055","title":"ADR-055: Proxy-Admin Control Plane Protocol","description":"Context","source":"@site/../docs-cms/adr/adr-055-proxy-admin-control-plane.md","sourceDirName":".","slug":"/adr-055","permalink":"/prism-data-layer/adr/adr-055","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/adr-055-proxy-admin-control-plane.md","tags":[{"inline":true,"label":"proxy","permalink":"/prism-data-layer/adr/tags/proxy"},{"inline":true,"label":"admin","permalink":"/prism-data-layer/adr/tags/admin"},{"inline":true,"label":"control-plane","permalink":"/prism-data-layer/adr/tags/control-plane"},{"inline":true,"label":"grpc","permalink":"/prism-data-layer/adr/tags/grpc"},{"inline":true,"label":"namespace","permalink":"/prism-data-layer/adr/tags/namespace"},{"inline":true,"label":"partitioning","permalink":"/prism-data-layer/adr/tags/partitioning"}],"version":"current","frontMatter":{"date":"2025-10-15T00:00:00.000Z","deciders":"Engineering Team","doc_uuid":"9a4e5b3c-7d6f-4e2a-b8c9-1f3e5d7a9b2c","id":"adr-055","project_id":"prism-data-layer","status":"Accepted","tags":["proxy","admin","control-plane","grpc","namespace","partitioning"],"title":"ADR-055: Proxy-Admin Control Plane Protocol"},"sidebar":"adrSidebar","previous":{"title":"Claim Check TTL and Garbage Collection \u2022 ADR-053","permalink":"/prism-data-layer/adr/adr-053"},"next":{"title":"Launcher-Admin Control Plane Protocol \u2022 ADR-056","permalink":"/prism-data-layer/adr/adr-056"}}');var s=i(74848),a=i(28453);const t={date:new Date("2025-10-15T00:00:00.000Z"),deciders:"Engineering Team",doc_uuid:"9a4e5b3c-7d6f-4e2a-b8c9-1f3e5d7a9b2c",id:"adr-055",project_id:"prism-data-layer",status:"Accepted",tags:["proxy","admin","control-plane","grpc","namespace","partitioning"],title:"ADR-055: Proxy-Admin Control Plane Protocol"},o=void 0,l={},c=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Alternatives Considered",id:"alternatives-considered",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Implementation Notes",id:"implementation-notes",level:2},{value:"Proxy-Side Admin Client",id:"proxy-side-admin-client",level:3},{value:"Admin-Side Control Plane Service",id:"admin-side-control-plane-service",level:3},{value:"Partition Manager",id:"partition-manager",level:3},{value:"Proxy Configuration",id:"proxy-configuration",level:3},{value:"Graceful Fallback",id:"graceful-fallback",level:3},{value:"References",id:"references",level:2},{value:"Revision History",id:"revision-history",level:2}];function d(n){const e={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h2,{id:"context",children:"Context"}),"\n",(0,s.jsx)(e.p,{children:"Prism proxy instances currently operate independently without central coordination. This creates several operational challenges:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Namespace Management"}),": No central registry of which namespaces exist across proxy instances"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Client Onboarding"}),": New clients must manually configure namespace settings in each proxy"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Dynamic Configuration"}),": Namespace updates require proxy restarts or manual config reloads"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Capacity Planning"}),": No visibility into which namespaces are active on which proxies"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Partition Distribution"}),": Cannot distribute namespace traffic across multiple proxy instances"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"We need a control plane protocol that enables:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Proxy instances to register with prism-admin on startup"}),"\n",(0,s.jsx)(e.li,{children:"prism-admin to push namespace configurations to proxies"}),"\n",(0,s.jsx)(e.li,{children:"Client-initiated namespace creation flows through admin"}),"\n",(0,s.jsx)(e.li,{children:"Partition-based namespace distribution across proxy instances"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"decision",children:"Decision"}),"\n",(0,s.jsx)(e.p,{children:"Implement bidirectional gRPC control plane protocol between prism-proxy and prism-admin:"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Proxy Startup"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"prism-proxy --admin-endpoint admin.prism.local:8981 --proxy-id proxy-01 --region us-west-2\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Control Plane Flows"}),":"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Proxy Registration"})," (proxy \u2192 admin):"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Proxy connects on startup, sends ProxyRegistration with ID, address, region, capabilities"}),"\n",(0,s.jsx)(e.li,{children:"Admin records proxy in storage (proxies table from ADR-054)"}),"\n",(0,s.jsx)(e.li,{children:"Admin returns assigned namespaces for this proxy"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Namespace Assignment"})," (admin \u2192 proxy):"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Admin pushes namespace configs to proxy via NamespaceAssignment message"}),"\n",(0,s.jsx)(e.li,{children:"Includes partition ID for distributed namespace routing"}),"\n",(0,s.jsx)(e.li,{children:"Proxy validates and activates namespace"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Client Namespace Creation"})," (client \u2192 proxy \u2192 admin \u2192 proxy):"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Client sends CreateNamespace request to proxy"}),"\n",(0,s.jsx)(e.li,{children:"Proxy forwards to admin via control plane"}),"\n",(0,s.jsx)(e.li,{children:"Admin validates, persists, assigns partition"}),"\n",(0,s.jsx)(e.li,{children:"Admin sends NamespaceAssignment back to relevant proxies"}),"\n",(0,s.jsx)(e.li,{children:"Proxy acknowledges and becomes ready for client traffic"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Health & Heartbeat"})," (proxy \u2194 admin):"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Proxy sends heartbeat every 30s with namespace health stats"}),"\n",(0,s.jsx)(e.li,{children:"Admin tracks last_seen timestamp (ADR-054 proxies table)"}),"\n",(0,s.jsx)(e.li,{children:"Admin detects stale proxies and redistributes namespaces"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Partition Distribution"}),":"]}),"\n",(0,s.jsx)(e.p,{children:"Namespaces include partition identifier for horizontal scaling:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Partition Key"}),": Hash of namespace name \u2192 partition ID (0-255)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Proxy Assignment"}),": Admin assigns namespace to proxy based on partition range"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Consistent Hashing"}),": Partition \u2192 proxy mapping survives proxy additions/removals"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Rebalancing"}),": Admin redistributes partitions when proxies join/leave"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Example partition distribution:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-text",children:"proxy-01: partitions [0-63]   \u2192 namespaces: ns-a (hash=12), ns-d (hash=55)\nproxy-02: partitions [64-127] \u2192 namespaces: ns-b (hash=88), ns-e (hash=100)\nproxy-03: partitions [128-191] \u2192 namespaces: ns-c (hash=145)\nproxy-04: partitions [192-255] \u2192 namespaces: ns-f (hash=200)\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Protocol Messages"})," (protobuf):"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-protobuf",children:"service ControlPlane {\n  // Proxy \u2192 Admin: Register proxy on startup\n  rpc RegisterProxy(ProxyRegistration) returns (ProxyRegistrationAck);\n\n  // Admin \u2192 Proxy: Push namespace configuration\n  rpc AssignNamespace(NamespaceAssignment) returns (NamespaceAssignmentAck);\n\n  // Proxy \u2192 Admin: Request namespace creation (client-initiated)\n  rpc CreateNamespace(CreateNamespaceRequest) returns (CreateNamespaceResponse);\n\n  // Proxy \u2192 Admin: Heartbeat with namespace health\n  rpc Heartbeat(ProxyHeartbeat) returns (HeartbeatAck);\n\n  // Admin \u2192 Proxy: Revoke namespace assignment\n  rpc RevokeNamespace(NamespaceRevocation) returns (NamespaceRevocationAck);\n}\n\nmessage ProxyRegistration {\n  string proxy_id = 1;          // Unique proxy identifier (proxy-01)\n  string address = 2;           // Proxy gRPC address (proxy-01.prism.local:8980)\n  string region = 3;            // Deployment region (us-west-2)\n  string version = 4;           // Proxy version (0.1.0)\n  repeated string capabilities = 5; // Supported patterns (keyvalue, pubsub)\n  map<string, string> metadata = 6; // Custom labels\n}\n\nmessage ProxyRegistrationAck {\n  bool success = 1;\n  string message = 2;\n  repeated NamespaceAssignment initial_namespaces = 3; // Pre-assigned namespaces\n  repeated PartitionRange partition_ranges = 4;        // Assigned partition ranges\n}\n\nmessage NamespaceAssignment {\n  string namespace = 1;\n  int32 partition_id = 2;       // Partition ID (0-255)\n  NamespaceConfig config = 3;   // Full namespace configuration\n  int64 version = 4;            // Config version for idempotency\n}\n\nmessage NamespaceConfig {\n  map<string, BackendConfig> backends = 1;\n  map<string, PatternConfig> patterns = 2;\n  AuthConfig auth = 3;\n  map<string, string> metadata = 4;\n}\n\nmessage CreateNamespaceRequest {\n  string namespace = 1;\n  string requesting_proxy = 2;  // Proxy ID handling client request\n  NamespaceConfig config = 3;\n  string principal = 4;         // Authenticated user creating namespace\n}\n\nmessage CreateNamespaceResponse {\n  bool success = 1;\n  string message = 2;\n  int32 assigned_partition = 3;\n  string assigned_proxy = 4;    // Proxy that will handle this namespace\n}\n\nmessage ProxyHeartbeat {\n  string proxy_id = 1;\n  map<string, NamespaceHealth> namespace_health = 2;\n  ResourceUsage resources = 3;\n  int64 timestamp = 4;\n}\n\nmessage NamespaceHealth {\n  int32 active_sessions = 1;\n  int64 requests_per_second = 2;\n  string status = 3;            // healthy, degraded, unhealthy\n}\n\nmessage PartitionRange {\n  int32 start = 1;              // Inclusive\n  int32 end = 2;                // Inclusive\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"rationale",children:"Rationale"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Why Control Plane Protocol:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Centralized namespace management enables operational visibility"}),"\n",(0,s.jsx)(e.li,{children:"Dynamic configuration without proxy restarts"}),"\n",(0,s.jsx)(e.li,{children:"Foundation for multi-proxy namespace distribution"}),"\n",(0,s.jsx)(e.li,{children:"Client onboarding without direct admin access"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Why Partition-Based Distribution:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Consistent hashing enables predictable namespace \u2192 proxy routing"}),"\n",(0,s.jsx)(e.li,{children:"Horizontal scaling by adding proxies (redistribute partitions)"}),"\n",(0,s.jsx)(e.li,{children:"Namespace isolation (each namespace maps to one proxy per partition)"}),"\n",(0,s.jsx)(e.li,{children:"Load balancing via partition rebalancing"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Why gRPC Bidirectional:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Admin can push configs to proxies (admin \u2192 proxy)"}),"\n",(0,s.jsx)(e.li,{children:"Proxies can request namespace creation (proxy \u2192 admin)"}),"\n",(0,s.jsx)(e.li,{children:"Efficient binary protocol with streaming support"}),"\n",(0,s.jsx)(e.li,{children:"Type-safe protobuf contracts"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Why Heartbeat Every 30s:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Reasonable balance between admin load and stale proxy detection"}),"\n",(0,s.jsx)(e.li,{children:"Fast enough for operational alerting (<1min to detect failure)"}),"\n",(0,s.jsx)(e.li,{children:"Includes namespace health stats for capacity planning"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Config File Only (No Control Plane)"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Pros: Simple, no runtime dependencies"}),"\n",(0,s.jsx)(e.li,{children:"Cons: Manual namespace distribution, no dynamic updates, no visibility"}),"\n",(0,s.jsx)(e.li,{children:"Rejected because: Operational burden scales with proxy count"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"HTTP/REST Control Plane"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Pros: Familiar, curl-friendly"}),"\n",(0,s.jsx)(e.li,{children:"Cons: Verbose JSON payloads, no streaming, no bidirectional"}),"\n",(0,s.jsx)(e.li,{children:"Rejected because: gRPC provides better performance and type safety"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Kafka-Based Event Bus"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Pros: Decoupled, events persisted"}),"\n",(0,s.jsx)(e.li,{children:"Cons: Requires Kafka dependency, eventual consistency, complex"}),"\n",(0,s.jsx)(e.li,{children:"Rejected because: gRPC request-response fits control plane semantics"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Service Mesh (Istio/Linkerd)"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Pros: Industry standard, rich features"}),"\n",(0,s.jsx)(e.li,{children:"Cons: Heavy infrastructure, learning curve, overkill for simple control plane"}),"\n",(0,s.jsx)(e.li,{children:"Rejected because: Application-level control plane is simpler"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"consequences",children:"Consequences"}),"\n",(0,s.jsx)(e.h3,{id:"positive",children:"Positive"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Centralized Visibility"}),": Admin has complete view of all proxies and namespaces"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Dynamic Configuration"}),": Namespace changes propagate immediately without restarts"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Client Onboarding"}),": Clients create namespaces via proxy, admin handles distribution"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Horizontal Scaling"}),": Add proxies, admin redistributes partitions automatically"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Operational Metrics"}),": Heartbeat provides namespace health across proxies"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Partition Isolation"}),": Namespace traffic isolated to assigned proxy"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Graceful Degradation"}),": Proxy operates with local config if admin unavailable"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"negative",children:"Negative"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Control Plane Dependency"}),": Proxies require admin connectivity for namespace operations"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Admin as SPOF"}),": If admin down, cannot create namespaces (but existing work)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Partition Rebalancing"}),": Moving partitions requires namespace handoff coordination"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Connection Overhead"}),": Each proxy maintains persistent gRPC connection to admin"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"State Synchronization"}),": Admin and proxy must agree on namespace assignments"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"neutral",children:"Neutral"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Proxies can optionally run without admin (local config file mode)"}),"\n",(0,s.jsx)(e.li,{children:"Admin stores proxy state in SQLite/PostgreSQL (ADR-054)"}),"\n",(0,s.jsx)(e.li,{children:"Partition count (256) fixed for now, can increase in future versions"}),"\n",(0,s.jsx)(e.li,{children:"Control plane protocol versioned independently from data plane"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,s.jsx)(e.h3,{id:"proxy-side-admin-client",children:"Proxy-Side Admin Client"}),"\n",(0,s.jsxs)(e.p,{children:["Rust implementation in ",(0,s.jsx)(e.code,{children:"prism-proxy/src/admin_client.rs"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use tonic::transport::Channel;\nuse tokio::time::{interval, Duration};\n\npub struct AdminClient {\n    client: ControlPlaneClient<Channel>,\n    proxy_id: String,\n    address: String,\n    region: String,\n}\n\nimpl AdminClient {\n    pub async fn new(\n        admin_endpoint: &str,\n        proxy_id: String,\n        address: String,\n        region: String,\n    ) -> Result<Self> {\n        let channel = Channel::from_static(admin_endpoint)\n            .connect()\n            .await?;\n\n        let client = ControlPlaneClient::new(channel);\n\n        Ok(Self { client, proxy_id, address, region })\n    }\n\n    pub async fn register(&mut self) -> Result<ProxyRegistrationAck> {\n        let request = ProxyRegistration {\n            proxy_id: self.proxy_id.clone(),\n            address: self.address.clone(),\n            region: self.region.clone(),\n            version: env!("CARGO_PKG_VERSION").to_string(),\n            capabilities: vec!["keyvalue".to_string(), "pubsub".to_string()],\n            metadata: HashMap::new(),\n        };\n\n        let response = self.client.register_proxy(request).await?;\n        Ok(response.into_inner())\n    }\n\n    pub async fn start_heartbeat_loop(&mut self) {\n        let mut ticker = interval(Duration::from_secs(30));\n\n        loop {\n            ticker.tick().await;\n\n            let heartbeat = ProxyHeartbeat {\n                proxy_id: self.proxy_id.clone(),\n                namespace_health: self.collect_namespace_health(),\n                resources: self.collect_resource_usage(),\n                timestamp: SystemTime::now().duration_since(UNIX_EPOCH)\n                    .unwrap().as_secs() as i64,\n            };\n\n            if let Err(e) = self.client.heartbeat(heartbeat).await {\n                warn!("Heartbeat failed: {}", e);\n            }\n        }\n    }\n\n    pub async fn create_namespace(\n        &mut self,\n        namespace: &str,\n        config: NamespaceConfig,\n        principal: &str,\n    ) -> Result<CreateNamespaceResponse> {\n        let request = CreateNamespaceRequest {\n            namespace: namespace.to_string(),\n            requesting_proxy: self.proxy_id.clone(),\n            config: Some(config),\n            principal: principal.to_string(),\n        };\n\n        let response = self.client.create_namespace(request).await?;\n        Ok(response.into_inner())\n    }\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"admin-side-control-plane-service",children:"Admin-Side Control Plane Service"}),"\n",(0,s.jsxs)(e.p,{children:["Go implementation in ",(0,s.jsx)(e.code,{children:"cmd/prism-admin/control_plane.go"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-go",children:'type ControlPlaneService struct {\n    storage *Storage\n    partitions *PartitionManager\n}\n\nfunc (s *ControlPlaneService) RegisterProxy(\n    ctx context.Context,\n    req *pb.ProxyRegistration,\n) (*pb.ProxyRegistrationAck, error) {\n    // Record proxy in storage\n    proxy := &Proxy{\n        ProxyID: req.ProxyId,\n        Address: req.Address,\n        Version: req.Version,\n        Status: "healthy",\n        LastSeen: time.Now(),\n        Metadata: req.Metadata,\n    }\n\n    if err := s.storage.UpsertProxy(ctx, proxy); err != nil {\n        return nil, err\n    }\n\n    // Assign partition ranges\n    ranges := s.partitions.AssignRanges(req.ProxyId)\n\n    // Get initial namespace assignments\n    namespaces := s.partitions.GetNamespacesForRanges(ranges)\n\n    return &pb.ProxyRegistrationAck{\n        Success: true,\n        Message: "Proxy registered successfully",\n        InitialNamespaces: namespaces,\n        PartitionRanges: ranges,\n    }, nil\n}\n\nfunc (s *ControlPlaneService) CreateNamespace(\n    ctx context.Context,\n    req *pb.CreateNamespaceRequest,\n) (*pb.CreateNamespaceResponse, error) {\n    // Calculate partition ID\n    partitionID := s.partitions.HashNamespace(req.Namespace)\n\n    // Find proxy for partition\n    proxyID, err := s.partitions.GetProxyForPartition(partitionID)\n    if err != nil {\n        return nil, err\n    }\n\n    // Persist namespace\n    ns := &Namespace{\n        Name: req.Namespace,\n        Description: "Created via " + req.RequestingProxy,\n        Metadata: req.Config.Metadata,\n    }\n\n    if err := s.storage.CreateNamespace(ctx, ns); err != nil {\n        return nil, err\n    }\n\n    // Send assignment to proxy\n    assignment := &pb.NamespaceAssignment{\n        Namespace: req.Namespace,\n        PartitionId: partitionID,\n        Config: req.Config,\n        Version: 1,\n    }\n\n    if err := s.sendAssignmentToProxy(proxyID, assignment); err != nil {\n        return nil, err\n    }\n\n    return &pb.CreateNamespaceResponse{\n        Success: true,\n        Message: "Namespace created and assigned",\n        AssignedPartition: partitionID,\n        AssignedProxy: proxyID,\n    }, nil\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"partition-manager",children:"Partition Manager"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-go",children:'type PartitionManager struct {\n    mu sync.RWMutex\n    proxies map[string][]PartitionRange // proxy_id \u2192 partition ranges\n    partitionMap map[int32]string       // partition_id \u2192 proxy_id\n}\n\nfunc (pm *PartitionManager) HashNamespace(namespace string) int32 {\n    hash := crc32.ChecksumIEEE([]byte(namespace))\n    return int32(hash % 256) // 256 partitions\n}\n\nfunc (pm *PartitionManager) AssignRanges(proxyID string) []PartitionRange {\n    pm.mu.Lock()\n    defer pm.mu.Unlock()\n\n    // Simple round-robin distribution\n    proxyCount := len(pm.proxies) + 1 // +1 for new proxy\n    rangeSize := 256 / proxyCount\n\n    proxyIndex := len(pm.proxies)\n    start := proxyIndex * rangeSize\n    end := start + rangeSize - 1\n\n    if end > 255 {\n        end = 255\n    }\n\n    ranges := []PartitionRange{{Start: start, End: end}}\n    pm.proxies[proxyID] = ranges\n\n    // Update partition map\n    for i := start; i <= end; i++ {\n        pm.partitionMap[int32(i)] = proxyID\n    }\n\n    return ranges\n}\n\nfunc (pm *PartitionManager) GetProxyForPartition(partitionID int32) (string, error) {\n    pm.mu.RLock()\n    defer pm.mu.RUnlock()\n\n    proxyID, ok := pm.partitionMap[partitionID]\n    if !ok {\n        return "", fmt.Errorf("no proxy assigned to partition %d", partitionID)\n    }\n\n    return proxyID, nil\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"proxy-configuration",children:"Proxy Configuration"}),"\n",(0,s.jsx)(e.p,{children:"Add admin endpoint to proxy config:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:'admin:\n  endpoint: "admin.prism.local:8981"\n  proxy_id: "proxy-01"\n  region: "us-west-2"\n  heartbeat_interval: "30s"\n  reconnect_backoff: "5s"\n'})}),"\n",(0,s.jsx)(e.h3,{id:"graceful-fallback",children:"Graceful Fallback"}),"\n",(0,s.jsx)(e.p,{children:"If admin unavailable, proxy operates with local config:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'async fn start_proxy(config: ProxyConfig) -> Result<()> {\n    // Try connecting to admin\n    match AdminClient::new(&config.admin.endpoint, ...).await {\n        Ok(mut admin_client) => {\n            info!("Connected to admin, registering proxy");\n\n            match admin_client.register().await {\n                Ok(ack) => {\n                    info!("Registered with admin, received {} namespaces",\n                          ack.initial_namespaces.len());\n\n                    // Apply admin-provided namespaces\n                    for ns in ack.initial_namespaces {\n                        apply_namespace(ns).await?;\n                    }\n\n                    // Start heartbeat loop in background\n                    tokio::spawn(async move {\n                        admin_client.start_heartbeat_loop().await;\n                    });\n                }\n                Err(e) => {\n                    warn!("Registration failed: {}, using local config", e);\n                    load_local_config().await?;\n                }\n            }\n        }\n        Err(e) => {\n            warn!("Admin connection failed: {}, using local config", e);\n            load_local_config().await?;\n        }\n    }\n\n    // Start data plane regardless of admin connectivity\n    start_data_plane().await\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"/adr/adr-027",children:"ADR-027: Admin API gRPC"})," - Admin API definition"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"/adr/adr-040",children:"ADR-040: Go Binary Admin CLI"})," - Admin CLI architecture"]}),"\n",(0,s.jsx)(e.li,{children:"ADR-054: SQLite Storage for prism-admin (planned) - Storage for proxy registry"}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"/rfc/rfc-003",children:"RFC-003: Protobuf Single Source of Truth"})," - Protobuf code generation"]}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://en.wikipedia.org/wiki/Consistent_hashing",children:"Consistent Hashing"})}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"2025-10-15: Initial draft - Proxy-admin control plane with partition distribution"}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}}}]);