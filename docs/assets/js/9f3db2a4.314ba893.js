"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[836],{28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var t=r(96540);const s={},a=t.createContext(s);function i(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(a.Provider,{value:n},e.children)}},63818:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"rfc-020","title":"Streaming HTTP Listener - API-Specific Adapter Pattern","description":"Summary","source":"@site/../docs-cms/rfcs/rfc-020-streaming-http-listener-api-adapter.md","sourceDirName":".","slug":"/rfc-020","permalink":"/prism-data-layer/rfc/rfc-020","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/rfcs/rfc-020-streaming-http-listener-api-adapter.md","tags":[{"inline":true,"label":"http","permalink":"/prism-data-layer/rfc/tags/http"},{"inline":true,"label":"adapter","permalink":"/prism-data-layer/rfc/tags/adapter"},{"inline":true,"label":"mcp","permalink":"/prism-data-layer/rfc/tags/mcp"},{"inline":true,"label":"a2a","permalink":"/prism-data-layer/rfc/tags/a-2-a"},{"inline":true,"label":"streaming","permalink":"/prism-data-layer/rfc/tags/streaming"},{"inline":true,"label":"sse","permalink":"/prism-data-layer/rfc/tags/sse"},{"inline":true,"label":"grpc","permalink":"/prism-data-layer/rfc/tags/grpc"},{"inline":true,"label":"bridge","permalink":"/prism-data-layer/rfc/tags/bridge"}],"version":"current","frontMatter":{"author":"Platform Team","created":"2025-10-09T00:00:00.000Z","doc_uuid":"8235a63b-dca0-4136-b4cf-fa426a391256","id":"rfc-020","project_id":"prism-data-layer","status":"Proposed","tags":["http","adapter","mcp","a2a","streaming","sse","grpc","bridge"],"title":"Streaming HTTP Listener - API-Specific Adapter Pattern","updated":"2025-10-09T00:00:00.000Z"},"sidebar":"rfcSidebar","previous":{"title":"Pattern SDK Authorization Layer - Token Validation and Policy Enforcement \u2022 RFC-019","permalink":"/prism-data-layer/rfc/rfc-019"},"next":{"title":"POC 1 - Three Minimal Plugins Implementation Plan \u2022 RFC-021","permalink":"/prism-data-layer/rfc/rfc-021"}}');var s=r(74848),a=r(28453);const i={author:"Platform Team",created:new Date("2025-10-09T00:00:00.000Z"),doc_uuid:"8235a63b-dca0-4136-b4cf-fa426a391256",id:"rfc-020",project_id:"prism-data-layer",status:"Proposed",tags:["http","adapter","mcp","a2a","streaming","sse","grpc","bridge"],title:"Streaming HTTP Listener - API-Specific Adapter Pattern",updated:new Date("2025-10-09T00:00:00.000Z")},o="RFC-020: Streaming HTTP Listener - API-Specific Adapter Pattern",l={},c=[{value:"Summary",id:"summary",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Problem",id:"problem",level:3},{value:"Use Cases",id:"use-cases",level:3},{value:"Use Case 1: MCP Tool Server",id:"use-case-1-mcp-tool-server",level:4},{value:"Use Case 2: Agent-to-Agent Coordination",id:"use-case-2-agent-to-agent-coordination",level:4},{value:"Use Case 3: SSE Event Streaming",id:"use-case-3-sse-event-streaming",level:4},{value:"Design Principles",id:"design-principles",level:2},{value:"1. API-Specific Adapters (Not Generic HTTP Gateway)",id:"1-api-specific-adapters-not-generic-http-gateway",level:3},{value:"2. Thin Translation Layer (No Business Logic)",id:"2-thin-translation-layer-no-business-logic",level:3},{value:"3. Leverage Existing gRPC Client Libraries",id:"3-leverage-existing-grpc-client-libraries",level:3},{value:"Architecture",id:"architecture",level:2},{value:"Component Diagram",id:"component-diagram",level:3},{value:"Request Flow: MCP Tool Call",id:"request-flow-mcp-tool-call",level:3},{value:"Streaming Flow: SSE Events",id:"streaming-flow-sse-events",level:3},{value:"API Schemas",id:"api-schemas",level:2},{value:"Adapter Configuration Schema",id:"adapter-configuration-schema",level:3},{value:"MCP Protocol Example",id:"mcp-protocol-example",level:3},{value:"Adapter Implementation Guide",id:"adapter-implementation-guide",level:2},{value:"1. Minimal Adapter Structure (Go)",id:"1-minimal-adapter-structure-go",level:3},{value:"2. Translation Helpers",id:"2-translation-helpers",level:3},{value:"3. Deployment Options",id:"3-deployment-options",level:3},{value:"Option A: Sidecar (Same Pod/VM as Proxy)",id:"option-a-sidecar-same-podvm-as-proxy",level:4},{value:"Option B: Separate Service",id:"option-b-separate-service",level:4},{value:"Option C: AWS Lambda / Serverless",id:"option-c-aws-lambda--serverless",level:4},{value:"MCP Backend Interface Decomposition",id:"mcp-backend-interface-decomposition",level:2},{value:"MCP as Backend Plugin",id:"mcp-as-backend-plugin",level:3},{value:"MCP Interface Definitions",id:"mcp-interface-definitions",level:3},{value:"MCP Pattern Configuration",id:"mcp-pattern-configuration",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Latency",id:"latency",level:3},{value:"Throughput",id:"throughput",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"1. Adapter Bypass",id:"1-adapter-bypass",level:3},{value:"2. Schema Validation Gaps",id:"2-schema-validation-gaps",level:3},{value:"3. Authorization Bypass",id:"3-authorization-bypass",level:3},{value:"Migration Path",id:"migration-path",level:2},{value:"Phase 1: MCP Adapter Prototype (Week 1)",id:"phase-1-mcp-adapter-prototype-week-1",level:3},{value:"Phase 2: SSE Streaming Support (Week 2)",id:"phase-2-sse-streaming-support-week-2",level:3},{value:"Phase 3: Agent-to-Agent Adapter (Week 3)",id:"phase-3-agent-to-agent-adapter-week-3",level:3},{value:"Phase 4: Adapter SDK (Week 4)",id:"phase-4-adapter-sdk-week-4",level:3},{value:"Monitoring and Observability",id:"monitoring-and-observability",level:2},{value:"Metrics",id:"metrics",level:3},{value:"Logging",id:"logging",level:3},{value:"Open Questions",id:"open-questions",level:2},{value:"1. Should Adapters Support Backend-Specific Optimizations?",id:"1-should-adapters-support-backend-specific-optimizations",level:3},{value:"2. How to Version Adapters Independently?",id:"2-how-to-version-adapters-independently",level:3},{value:"3. Should Adapters Cache Responses?",id:"3-should-adapters-cache-responses",level:3},{value:"Related Documents",id:"related-documents",level:2},{value:"Revision History",id:"revision-history",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"rfc-020-streaming-http-listener---api-specific-adapter-pattern",children:"RFC-020: Streaming HTTP Listener - API-Specific Adapter Pattern"})}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"Define a streaming HTTP listener architecture that acts as an API-specific adapter between external HTTP/JSON protocols (MCP, Agent-to-Agent, custom APIs) and Prism's internal gRPC/Protobuf proxy layer. These adapters satisfy specific API contracts while transparently mapping to backend plugin proxying."}),"\n",(0,s.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,s.jsx)(n.h3,{id:"problem",children:"Problem"}),"\n",(0,s.jsx)(n.p,{children:"Prism's core uses gRPC/Protobuf for efficient, type-safe communication between proxy and backend plugins. However, many external systems require HTTP-based APIs:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"MCP (Model Context Protocol)"}),": HTTP/JSON with SSE (Server-Sent Events) for tool calling"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Agent-to-Agent Protocol"}),": HTTP/JSON for agent coordination"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Custom APIs"}),": REST/JSON for application-specific integrations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Web Clients"}),": Browser-based applications using fetch/EventSource"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Current Gap"}),": No standardized way to bridge these HTTP-based protocols to Prism's gRPC backend."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Requirements"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Protocol Translation"}),": HTTP \u2194 gRPC bidirectional mapping"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Streaming Support"}),": SSE, WebSocket, HTTP chunked encoding"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"API Specificity"}),": Each adapter satisfies a specific external API contract"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Backend Agnostic"}),": Works with any backend plugin combination"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Easy to Write"}),": Simple adapter authoring (not full proxy rewrite)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performant"}),": Minimal overhead (<5ms P95 translation latency)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"use-cases",children:"Use Cases"}),"\n",(0,s.jsx)(n.h4,{id:"use-case-1-mcp-tool-server",children:"Use Case 1: MCP Tool Server"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"External API"}),": MCP HTTP/JSON protocol for AI tool calling"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-http",children:'POST /mcp/v1/tools/call HTTP/1.1\nContent-Type: application/json\n\n{\n  "tool": "query_device_status",\n  "arguments": {\n    "device_id": "sensor-123"\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Internal Mapping"}),": Maps to Multicast Registry pattern via gRPC"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-protobuf",children:'// Internal gRPC call to pattern coordinator\nMulticastRegistryService.Enumerate({\n  filter: {device_id: "sensor-123"}\n})\n'})}),"\n",(0,s.jsx)(n.h4,{id:"use-case-2-agent-to-agent-coordination",children:"Use Case 2: Agent-to-Agent Coordination"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"External API"}),": HTTP/JSON for agent discovery and messaging"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-http",children:'POST /a2a/agents/discover HTTP/1.1\nContent-Type: application/json\n\n{\n  "capabilities": ["code_review", "testing"],\n  "location": "us-west-2"\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Internal Mapping"}),": Maps to KeyValue + PubSub primitives"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-protobuf",children:'// Internal gRPC calls\nKeyValueService.Scan({prefix: "agent:", filter: capabilities})\nPubSubService.Publish({topic: "agent.discover", message: ...})\n'})}),"\n",(0,s.jsx)(n.h4,{id:"use-case-3-sse-event-streaming",children:"Use Case 3: SSE Event Streaming"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"External API"}),": Server-Sent Events for real-time updates"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-http",children:'GET /sse/device-events HTTP/1.1\nAccept: text/event-stream\n\n# Response stream:\ndata: {"device": "sensor-123", "status": "online"}\n\ndata: {"device": "sensor-456", "status": "offline"}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Internal Mapping"}),": Maps to PubSub subscription"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-protobuf",children:'// Internal gRPC streaming\nPubSubService.Subscribe({topic: "device.status"})\n// \u2192 stream of messages translated to SSE format\n'})}),"\n",(0,s.jsx)(n.h2,{id:"design-principles",children:"Design Principles"}),"\n",(0,s.jsx)(n.h3,{id:"1-api-specific-adapters-not-generic-http-gateway",children:"1. API-Specific Adapters (Not Generic HTTP Gateway)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Goal"}),": Each adapter implements ONE specific external API contract."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Why Not Generic"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"\u274c Generic HTTP-to-gRPC gateways (like grpc-gateway) don't understand domain semantics"}),"\n",(0,s.jsx)(n.li,{children:"\u274c One-size-fits-all mappings produce awkward APIs"}),"\n",(0,s.jsx)(n.li,{children:"\u274c Hard to optimize for specific protocol idioms (SSE, WebSocket, chunked)"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Why API-Specific"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"\u2705 Adapter validates incoming requests against API schema"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Can optimize for API-specific patterns (batching, caching, protocol quirks)"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Clear ownership: MCP team maintains MCP adapter, A2A team maintains A2A adapter"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Easy to version: MCP v1 adapter vs MCP v2 adapter"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"mcp-adapter/         # Implements MCP protocol\n\u251c\u2500\u2500 server.go        # HTTP listener with SSE support\n\u251c\u2500\u2500 mcp_schema.json  # MCP protocol schema\n\u251c\u2500\u2500 translator.go    # HTTP/JSON \u2192 gRPC translation\n\u2514\u2500\u2500 README.md        # MCP-specific docs\n\na2a-adapter/         # Implements Agent-to-Agent protocol\n\u251c\u2500\u2500 server.go        # HTTP listener with WebSocket\n\u251c\u2500\u2500 a2a_schema.json  # A2A protocol schema\n\u251c\u2500\u2500 translator.go    # HTTP/JSON \u2192 gRPC translation\n\u2514\u2500\u2500 README.md        # A2A-specific docs\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-thin-translation-layer-no-business-logic",children:"2. Thin Translation Layer (No Business Logic)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Goal"}),": Adapters ONLY translate protocols, never implement business logic."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What Adapters Do"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"\u2705 Parse HTTP request \u2192 validate \u2192 translate to gRPC \u2192 call proxy"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Receive gRPC response \u2192 translate to JSON \u2192 send HTTP response"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Handle streaming: SSE, WebSocket, HTTP chunked encoding"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Map HTTP errors to gRPC status codes (and vice versa)"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What Adapters DON'T Do"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"\u274c Authorization (proxy handles this via RFC-019)"}),"\n",(0,s.jsx)(n.li,{children:"\u274c Data transformation (backends handle this)"}),"\n",(0,s.jsx)(n.li,{children:"\u274c Caching (proxy/backends handle this)"}),"\n",(0,s.jsx)(n.li,{children:"\u274c Rate limiting (proxy handles this)"}),"\n",(0,s.jsx)(n.li,{children:"\u274c Retry logic (proxy handles this)"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example"})," (MCP tool call):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'// GOOD: Pure translation\nfunc (s *MCPAdapter) HandleToolCall(w http.ResponseWriter, r *http.Request) {\n    // Parse MCP request\n    var req MCPToolCallRequest\n    json.NewDecoder(r.Body).Decode(&req)\n\n    // Translate to gRPC (no business logic!)\n    grpcReq := &pb.EnumerateRequest{\n        Filter: map[string]*pb.Value{\n            "device_id": {StringValue: req.Arguments["device_id"]},\n        },\n    }\n\n    // Call proxy via gRPC\n    grpcResp, err := s.proxyClient.Enumerate(r.Context(), grpcReq)\n\n    // Translate response back to MCP format\n    mcpResp := MCPToolCallResponse{\n        Result: grpcResp.Items,\n    }\n    json.NewEncoder(w).Encode(mcpResp)\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'// BAD: Adapter implementing business logic\nfunc (s *MCPAdapter) HandleToolCall(w http.ResponseWriter, r *http.Request) {\n    // \u274c Adapter should NOT filter results\n    if req.Arguments["device_id"] == "admin" {\n        return errors.New("admin devices hidden")\n    }\n\n    // \u274c Adapter should NOT cache\n    if cached := s.cache.Get(req.Arguments["device_id"]); cached != nil {\n        return cached\n    }\n\n    // Business logic belongs in proxy or backend!\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-leverage-existing-grpc-client-libraries",children:"3. Leverage Existing gRPC Client Libraries"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Goal"}),": Adapters are thin HTTP frontends that call Prism proxy as gRPC clients."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Architecture"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502          External Client (Browser, AI)       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n               \u2502 HTTP/JSON (MCP, A2A, REST)\n               \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502        MCP Adapter (Thin HTTP Server)        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502  1. Parse HTTP request                 \u2502  \u2502\n\u2502  \u2502  2. Validate against MCP schema        \u2502  \u2502\n\u2502  \u2502  3. Translate JSON \u2192 Protobuf          \u2502  \u2502\n\u2502  \u2502  4. Call Prism proxy via gRPC client   \u2502  \u2502\n\u2502  \u2502  5. Translate Protobuf \u2192 JSON          \u2502  \u2502\n\u2502  \u2502  6. Send HTTP response                 \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n               \u2502 gRPC/Protobuf\n               \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502          Prism Proxy (Core)                  \u2502\n\u2502  - Pattern routing                           \u2502\n\u2502  - Authorization (RFC-019)                   \u2502\n\u2502  - Backend plugin proxying                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n               \u2502 gRPC to plugins\n               \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         Backend Plugins                      \u2502\n\u2502  (Redis, Postgres, Kafka, NATS)              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"\u2705 Adapter reuses all proxy features (auth, logging, metrics, tracing)"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 No direct backend access (adapter \u2192 proxy \u2192 plugins)"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Easy deployment: Adapter runs as sidecar or separate container"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Language flexibility: Adapter in Go, Python, Node, Rust (any language with gRPC support)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,s.jsx)(n.h3,{id:"component-diagram",children:"Component Diagram"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    HTTP Adapter Process                    \u2502\n\u2502                                                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502         HTTP Server (API-Specific)                   \u2502 \u2502\n\u2502  \u2502  - Listens on :8080 for HTTP requests               \u2502 \u2502\n\u2502  \u2502  - Handles SSE, WebSocket, chunked encoding         \u2502 \u2502\n\u2502  \u2502  - Validates requests against API schema            \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                       \u2502                                    \u2502\n\u2502                       \u2502 in-process                         \u2502\n\u2502                       \u25bc                                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502         Protocol Translator                          \u2502 \u2502\n\u2502  \u2502  - JSON \u2192 Protobuf encoding                         \u2502 \u2502\n\u2502  \u2502  - HTTP headers \u2192 gRPC metadata                     \u2502 \u2502\n\u2502  \u2502  - SSE events \u2190 gRPC streaming                      \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                       \u2502                                    \u2502\n\u2502                       \u2502 in-process                         \u2502\n\u2502                       \u25bc                                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502         gRPC Client (to Prism Proxy)                 \u2502 \u2502\n\u2502  \u2502  - KeyValueServiceClient                            \u2502 \u2502\n\u2502  \u2502  - PubSubServiceClient                              \u2502 \u2502\n\u2502  \u2502  - MulticastRegistryServiceClient                   \u2502 \u2502\n\u2502  \u2502  - Connection pooling, retries, circuit breaker     \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n                         \u2502 gRPC (localhost:50051 or network)\n                         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Prism Proxy (Core)                      \u2502\n\u2502  - Pattern routing and execution                           \u2502\n\u2502  - Authorization via Topaz (RFC-019)                       \u2502\n\u2502  - Backend plugin proxying                                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsx)(n.h3,{id:"request-flow-mcp-tool-call",children:"Request Flow: MCP Tool Call"}),"\n",(0,s.jsx)(n.mermaid,{value:'sequenceDiagram\n    participant Client as AI Client\n    participant Adapter as MCP Adapter<br/>(HTTP Server)\n    participant Translator as Protocol<br/>Translator\n    participant gRPC as gRPC Client\n    participant Proxy as Prism Proxy\n    participant Backend as Backend Plugin\n\n    Client->>Adapter: POST /mcp/v1/tools/call<br/>{tool: "query", args: {...}}\n    activate Adapter\n\n    Adapter->>Adapter: Validate MCP schema\n    Adapter->>Translator: Translate to Protobuf\n    activate Translator\n\n    Translator->>Translator: Map JSON \u2192 proto fields<br/>Map HTTP headers \u2192 gRPC metadata\n\n    Translator->>gRPC: EnumerateRequest{filter: ...}\n    deactivate Translator\n\n    activate gRPC\n    gRPC->>Proxy: gRPC call<br/>MulticastRegistry.Enumerate()\n    deactivate gRPC\n\n    activate Proxy\n    Proxy->>Proxy: Authorize request (RFC-019)\n    Proxy->>Proxy: Route to pattern coordinator\n    Proxy->>Backend: KeyValue.Scan() [gRPC]\n\n    activate Backend\n    Backend--\x3e>Proxy: ScanResponse (stream)\n    deactivate Backend\n\n    Proxy--\x3e>gRPC: EnumerateResponse\n    deactivate Proxy\n\n    activate gRPC\n    gRPC--\x3e>Translator: Protobuf response\n    deactivate gRPC\n\n    activate Translator\n    Translator->>Translator: Translate Protobuf \u2192 JSON\n    Translator--\x3e>Adapter: MCPToolCallResponse\n    deactivate Translator\n\n    Adapter->>Adapter: Format MCP response\n    Adapter--\x3e>Client: HTTP 200<br/>{result: [...]}\n    deactivate Adapter'}),"\n",(0,s.jsx)(n.h3,{id:"streaming-flow-sse-events",children:"Streaming Flow: SSE Events"}),"\n",(0,s.jsx)(n.mermaid,{value:'sequenceDiagram\n    participant Client as Web Browser\n    participant Adapter as HTTP Adapter<br/>(SSE Handler)\n    participant gRPC as gRPC Client\n    participant Proxy as Prism Proxy\n\n    Client->>Adapter: GET /sse/device-events<br/>Accept: text/event-stream\n    activate Adapter\n\n    Adapter->>Adapter: Setup SSE connection<br/>Set headers: Content-Type: text/event-stream\n\n    Adapter->>gRPC: Subscribe({topic: "device.status"})\n    activate gRPC\n\n    gRPC->>Proxy: gRPC streaming call<br/>PubSub.Subscribe()\n    activate Proxy\n\n    loop Stream events\n        Proxy->>Backend: Poll for new messages\n        activate Backend\n        Backend--\x3e>Proxy: Message\n        deactivate Backend\n\n        Proxy--\x3e>gRPC: stream Message\n        gRPC--\x3e>Adapter: Protobuf message\n\n        Adapter->>Adapter: Translate to SSE format<br/>data: {device: ..., status: ...}\\n\\n\n\n        Adapter--\x3e>Client: SSE event (chunked HTTP)\n    end\n\n    Client->>Adapter: Close connection\n    Adapter->>gRPC: Cancel stream\n    gRPC->>Proxy: Cancel subscription\n    deactivate Proxy\n    deactivate gRPC\n    deactivate Adapter'}),"\n",(0,s.jsx)(n.h2,{id:"api-schemas",children:"API Schemas"}),"\n",(0,s.jsx)(n.h3,{id:"adapter-configuration-schema",children:"Adapter Configuration Schema"}),"\n",(0,s.jsx)(n.p,{children:"Each adapter has a configuration file defining:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"API contract"}),": OpenAPI/JSON Schema for the external HTTP API"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mapping rules"}),": How HTTP requests map to gRPC calls"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Streaming mode"}),": SSE, WebSocket, chunked, or simple request/response"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example"})," (",(0,s.jsx)(n.code,{children:"adapters/mcp/adapter-config.yaml"}),"):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'adapter: mcp-tool-server\nversion: v1\ndescription: "MCP (Model Context Protocol) HTTP/JSON adapter"\n\n# External HTTP API\nexternal_api:\n  protocol: http/1.1\n  base_path: /mcp/v1\n  schema: mcp_schema.json  # OpenAPI schema for MCP protocol\n\n# Internal gRPC target\ninternal_grpc:\n  proxy_endpoint: localhost:50051\n  services:\n    - MulticastRegistryService  # Primary service for tool calls\n    - KeyValueService           # Fallback for simple queries\n\n# Route mappings\nroutes:\n  - http_path: POST /mcp/v1/tools/call\n    http_method: POST\n    grpc_service: MulticastRegistryService\n    grpc_method: Enumerate\n    translation:\n      request:\n        # Map MCP JSON fields to gRPC protobuf fields\n        tool: ignore  # Tool name handled by proxy routing\n        arguments: map_to_filter  # JSON object \u2192 proto map<string, Value>\n      response:\n        # Map gRPC response to MCP JSON format\n        items: map_to_result  # proto repeated Items \u2192 JSON array\n\n  - http_path: GET /mcp/v1/tools/list\n    http_method: GET\n    grpc_service: MulticastRegistryService\n    grpc_method: Enumerate\n    translation:\n      request:\n        # Empty filter for list all\n      response:\n        items: map_to_tools  # Format as MCP tool schema\n\n  - http_path: GET /mcp/v1/events\n    http_method: GET\n    grpc_service: PubSubService\n    grpc_method: Subscribe\n    streaming: sse  # Use Server-Sent Events\n    translation:\n      request:\n        topics: extract_from_query  # ?topics=device.status,device.alerts\n      response:\n        message: map_to_sse_event  # Each message \u2192 SSE data: {...}\n\n# Error mapping\nerror_mapping:\n  NOT_FOUND: 404  # gRPC NotFound \u2192 HTTP 404\n  PERMISSION_DENIED: 403  # gRPC PermissionDenied \u2192 HTTP 403\n  INVALID_ARGUMENT: 400  # gRPC InvalidArgument \u2192 HTTP 400\n  INTERNAL: 500  # gRPC Internal \u2192 HTTP 500\n\n# Adapter settings\nsettings:\n  listen_address: "0.0.0.0:8080"\n  max_request_size: 10MB\n  request_timeout: 30s\n  sse_heartbeat_interval: 15s\n  grpc_connection_pool_size: 10\n'})}),"\n",(0,s.jsx)(n.h3,{id:"mcp-protocol-example",children:"MCP Protocol Example"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"MCP Tool Call Request"})," (HTTP/JSON):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "jsonrpc": "2.0",\n  "method": "tools/call",\n  "params": {\n    "tool": "query_device_status",\n    "arguments": {\n      "device_id": "sensor-123",\n      "include_metadata": true\n    }\n  },\n  "id": 1\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Translated to gRPC"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-protobuf",children:'EnumerateRequest {\n  namespace: "iot-devices"\n  filter: {\n    "device_id": Value { string_value: "sensor-123" }\n    "include_metadata": Value { bool_value: true }\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"gRPC Response"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-protobuf",children:'EnumerateResponse {\n  items: [\n    {\n      identity: "sensor-123"\n      metadata: {\n        "status": Value { string_value: "online" }\n        "temperature": Value { double_value: 72.5 }\n        "last_seen": Value { int64_value: 1696876543 }\n      }\n    }\n  ]\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Translated to MCP Response"})," (HTTP/JSON):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "jsonrpc": "2.0",\n  "result": {\n    "content": [\n      {\n        "type": "text",\n        "text": "Device sensor-123: online, temperature 72.5\xb0F, last seen Oct 9 2025"\n      }\n    ]\n  },\n  "id": 1\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"adapter-implementation-guide",children:"Adapter Implementation Guide"}),"\n",(0,s.jsx)(n.h3,{id:"1-minimal-adapter-structure-go",children:"1. Minimal Adapter Structure (Go)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'// adapters/mcp/main.go\npackage main\n\nimport (\n    "context"\n    "encoding/json"\n    "net/http"\n\n    "google.golang.org/grpc"\n    pb "github.com/prism/proto/patterns"\n)\n\ntype MCPAdapter struct {\n    proxyConn *grpc.ClientConn\n    registry  pb.MulticastRegistryServiceClient\n    config    *AdapterConfig\n}\n\nfunc NewMCPAdapter(proxyEndpoint string, config *AdapterConfig) (*MCPAdapter, error) {\n    // Connect to Prism proxy via gRPC\n    conn, err := grpc.Dial(proxyEndpoint, grpc.WithInsecure())\n    if err != nil {\n        return nil, err\n    }\n\n    return &MCPAdapter{\n        proxyConn: conn,\n        registry:  pb.NewMulticastRegistryServiceClient(conn),\n        config:    config,\n    }, nil\n}\n\nfunc (a *MCPAdapter) HandleToolCall(w http.ResponseWriter, r *http.Request) {\n    ctx := r.Context()\n\n    // 1. Parse MCP request\n    var mcpReq MCPToolCallRequest\n    if err := json.NewDecoder(r.Body).Decode(&mcpReq); err != nil {\n        http.Error(w, "Invalid MCP request", http.StatusBadRequest)\n        return\n    }\n\n    // 2. Validate against MCP schema\n    if err := a.ValidateMCPRequest(&mcpReq); err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n\n    // 3. Translate to gRPC\n    grpcReq := a.TranslateToGRPC(&mcpReq)\n\n    // 4. Call Prism proxy\n    grpcResp, err := a.registry.Enumerate(ctx, grpcReq)\n    if err != nil {\n        a.HandleGRPCError(w, err)\n        return\n    }\n\n    // 5. Translate response back to MCP\n    mcpResp := a.TranslateFromGRPC(grpcResp)\n\n    // 6. Send HTTP response\n    w.Header().Set("Content-Type", "application/json")\n    json.NewEncoder(w).Encode(mcpResp)\n}\n\nfunc (a *MCPAdapter) HandleSSEEvents(w http.ResponseWriter, r *http.Request) {\n    ctx := r.Context()\n\n    // Setup SSE headers\n    w.Header().Set("Content-Type", "text/event-stream")\n    w.Header().Set("Cache-Control", "no-cache")\n    w.Header().Set("Connection", "keep-alive")\n\n    flusher, ok := w.(http.Flusher)\n    if !ok {\n        http.Error(w, "SSE not supported", http.StatusInternalServerError)\n        return\n    }\n\n    // Subscribe via gRPC streaming\n    stream, err := a.pubsub.Subscribe(ctx, &pb.SubscribeRequest{\n        Topic: "device.status",\n    })\n    if err != nil {\n        http.Error(w, "Subscription failed", http.StatusInternalServerError)\n        return\n    }\n\n    // Stream events to client\n    for {\n        msg, err := stream.Recv()\n        if err != nil {\n            return  // Client disconnected or stream closed\n        }\n\n        // Translate to SSE format\n        sseEvent := a.TranslateToSSE(msg)\n        fmt.Fprintf(w, "data: %s\\n\\n", sseEvent)\n        flusher.Flush()\n    }\n}\n\nfunc main() {\n    config := LoadConfig("adapter-config.yaml")\n    adapter, err := NewMCPAdapter("localhost:50051", config)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Register HTTP routes\n    http.HandleFunc("/mcp/v1/tools/call", adapter.HandleToolCall)\n    http.HandleFunc("/mcp/v1/tools/list", adapter.HandleToolList)\n    http.HandleFunc("/mcp/v1/events", adapter.HandleSSEEvents)\n\n    // Start HTTP server\n    log.Printf("MCP adapter listening on %s", config.ListenAddress)\n    http.ListenAndServe(config.ListenAddress, nil)\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-translation-helpers",children:"2. Translation Helpers"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'// adapters/mcp/translator.go\npackage main\n\nimport (\n    pb "github.com/prism/proto/patterns"\n)\n\nfunc (a *MCPAdapter) TranslateToGRPC(mcpReq *MCPToolCallRequest) *pb.EnumerateRequest {\n    filter := make(map[string]*pb.Value)\n\n    // Map MCP arguments to protobuf filter\n    for key, val := range mcpReq.Params.Arguments {\n        switch v := val.(type) {\n        case string:\n            filter[key] = &pb.Value{StringValue: v}\n        case float64:\n            filter[key] = &pb.Value{DoubleValue: v}\n        case bool:\n            filter[key] = &pb.Value{BoolValue: v}\n        }\n    }\n\n    return &pb.EnumerateRequest{\n        Namespace: a.config.Namespace,\n        Filter:    filter,\n    }\n}\n\nfunc (a *MCPAdapter) TranslateFromGRPC(grpcResp *pb.EnumerateResponse) *MCPToolCallResponse {\n    // Format gRPC response as MCP result\n    content := []MCPContent{}\n\n    for _, item := range grpcResp.Items {\n        text := formatAsText(item)  // Format metadata as human-readable text\n        content = append(content, MCPContent{\n            Type: "text",\n            Text: text,\n        })\n    }\n\n    return &MCPToolCallResponse{\n        JSONRPC: "2.0",\n        Result: MCPResult{\n            Content: content,\n        },\n        ID: 1,\n    }\n}\n\nfunc (a *MCPAdapter) TranslateToSSE(msg *pb.Message) string {\n    // Convert protobuf message to JSON for SSE\n    data := map[string]interface{}{\n        "topic":     msg.Topic,\n        "payload":   string(msg.Payload),\n        "timestamp": msg.Timestamp,\n    }\n\n    jsonBytes, _ := json.Marshal(data)\n    return string(jsonBytes)\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-deployment-options",children:"3. Deployment Options"}),"\n",(0,s.jsx)(n.h4,{id:"option-a-sidecar-same-podvm-as-proxy",children:"Option A: Sidecar (Same Pod/VM as Proxy)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'# docker-compose.yml\nservices:\n  prism-proxy:\n    image: prism-proxy:latest\n    ports:\n      - "50051:50051"  # gRPC\n\n  mcp-adapter:\n    image: mcp-adapter:latest\n    ports:\n      - "8080:8080"  # HTTP\n    environment:\n      - PROXY_ENDPOINT=prism-proxy:50051\n    depends_on:\n      - prism-proxy\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"\u2705 Low latency (localhost gRPC calls)"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Same lifecycle as proxy"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Shared network namespace"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"option-b-separate-service",children:"Option B: Separate Service"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'# Kubernetes deployment\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: mcp-adapter\nspec:\n  replicas: 3\n  template:\n    spec:\n      containers:\n        - name: mcp-adapter\n          image: mcp-adapter:v1.0.0\n          env:\n            - name: PROXY_ENDPOINT\n              value: "prism-proxy.default.svc.cluster.local:50051"\n          ports:\n            - containerPort: 8080\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"\u2705 Independent scaling (scale adapter separately from proxy)"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Independent deployment (update adapter without touching proxy)"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Multiple adapters can share one proxy"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"option-c-aws-lambda--serverless",children:"Option C: AWS Lambda / Serverless"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# lambda/mcp_adapter.py\nimport json\nimport grpc\nimport prism_pb2\nimport prism_pb2_grpc\n\ndef lambda_handler(event, context):\n    # Parse API Gateway event\n    mcp_request = json.loads(event['body'])\n\n    # Connect to Prism proxy (via VPC)\n    channel = grpc.insecure_channel('prism-proxy:50051')\n    client = prism_pb2_grpc.MulticastRegistryServiceStub(channel)\n\n    # Translate and call\n    grpc_request = translate_to_grpc(mcp_request)\n    grpc_response = client.Enumerate(grpc_request)\n\n    # Translate back\n    mcp_response = translate_from_grpc(grpc_response)\n\n    return {\n        'statusCode': 200,\n        'body': json.dumps(mcp_response)\n    }\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"\u2705 Serverless (no infrastructure management)"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Auto-scaling"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Pay-per-request"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"mcp-backend-interface-decomposition",children:"MCP Backend Interface Decomposition"}),"\n",(0,s.jsxs)(n.p,{children:["Following MEMO-006 principles, MCP itself can be treated as a ",(0,s.jsx)(n.strong,{children:"backend"})," with decomposed interfaces."]}),"\n",(0,s.jsx)(n.h3,{id:"mcp-as-backend-plugin",children:"MCP as Backend Plugin"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'# registry/backends/mcp.yaml\nbackend: mcp\ndescription: "Model Context Protocol - AI tool calling interface"\nplugin: prism-mcp:v1.0.0\nconnection_string_format: "mcp://host:port"\n\n# MCP implements 5 interfaces across 3 data models\nimplements:\n  # KeyValue (2 of 6) - Tool metadata storage\n  - keyvalue_basic          # Store/retrieve tool definitions\n  - keyvalue_scan           # Enumerate available tools\n\n  # Queue (3 of 5) - Tool call queue for async execution\n  - queue_basic             # Enqueue tool calls\n  - queue_visibility        # Visibility timeout for long-running tools\n  - queue_dead_letter       # Failed tool calls to DLQ\n\n  # Stream (2 of 5) - Event streaming for tool results\n  - stream_basic            # Append tool execution events\n  - stream_consumer_groups  # Multiple consumers for tool results\n'})}),"\n",(0,s.jsx)(n.h3,{id:"mcp-interface-definitions",children:"MCP Interface Definitions"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"New Interfaces"})," (in ",(0,s.jsx)(n.code,{children:"proto/interfaces/mcp_*.proto"}),"):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-protobuf",children:'// proto/interfaces/mcp_tool.proto\nsyntax = "proto3";\npackage prism.interfaces.mcp;\n\n// Tool calling interface (maps to MCP tools/call)\nservice MCPToolInterface {\n  rpc CallTool(CallToolRequest) returns (CallToolResponse);\n  rpc ListTools(ListToolsRequest) returns (ListToolsResponse);\n  rpc GetToolSchema(GetToolSchemaRequest) returns (ToolSchema);\n}\n\nmessage CallToolRequest {\n  string tool_name = 1;\n  map<string, Value> arguments = 2;\n  optional int64 timeout_ms = 3;\n}\n\nmessage CallToolResponse {\n  repeated Content content = 1;\n  optional bool is_error = 2;\n}\n\nmessage Content {\n  string type = 1;  // "text", "image", "resource"\n  oneof data {\n    string text = 2;\n    bytes blob = 3;\n    string resource_uri = 4;\n  }\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-protobuf",children:'// proto/interfaces/mcp_resource.proto\nsyntax = "proto3";\npackage prism.interfaces.mcp;\n\n// Resource interface (maps to MCP resources/*)\nservice MCPResourceInterface {\n  rpc ListResources(ListResourcesRequest) returns (ListResourcesResponse);\n  rpc ReadResource(ReadResourceRequest) returns (ReadResourceResponse);\n  rpc SubscribeToResource(SubscribeRequest) returns (stream ResourceUpdate);\n}\n\nmessage ReadResourceRequest {\n  string resource_uri = 1;  // e.g., "file:///path/to/file"\n}\n\nmessage ReadResourceResponse {\n  repeated Content contents = 1;\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-protobuf",children:'// proto/interfaces/mcp_prompt.proto\nsyntax = "proto3";\npackage prism.interfaces.mcp;\n\n// Prompt interface (maps to MCP prompts/*)\nservice MCPPromptInterface {\n  rpc ListPrompts(ListPromptsRequest) returns (ListPromptsResponse);\n  rpc GetPrompt(GetPromptRequest) returns (GetPromptResponse);\n}\n\nmessage GetPromptRequest {\n  string prompt_name = 1;\n  map<string, string> arguments = 2;\n}\n\nmessage GetPromptResponse {\n  string description = 1;\n  repeated PromptMessage messages = 2;\n}\n\nmessage PromptMessage {\n  string role = 1;  // "user", "assistant", "system"\n  Content content = 2;\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"mcp-pattern-configuration",children:"MCP Pattern Configuration"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Pattern using MCP backend"})," (stored as ",(0,s.jsx)(n.code,{children:"registry/patterns/ai-tool-orchestration.yaml"}),"):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'pattern: ai-tool-orchestration\nversion: v1\ndescription: "Orchestrate AI tool calls via MCP protocol with queue-based execution"\nexecutor: prism-pattern-ai-tool-orchestration:v1.0.0\n\n# Pattern requires MCP backend + queue for async execution\nslots:\n  tool_server:\n    description: "MCP tool server for executing tool calls"\n    required_interfaces:\n      - mcp_tool          # MUST support tool calling\n      - mcp_resource      # MUST support resource access\n    optional_interfaces:\n      - mcp_prompt        # Nice to have: prompt templates\n    recommended_backends:\n      - mcp               # Native MCP server\n\n  execution_queue:\n    description: "Queue for async tool execution with retry"\n    required_interfaces:\n      - queue_basic           # MUST support enqueue/dequeue\n      - queue_visibility      # MUST support visibility timeout\n      - queue_dead_letter     # MUST handle failed tool calls\n    recommended_backends:\n      - postgres        # Queue implementation\n      - sqs             # AWS SQS\n      - rabbitmq        # RabbitMQ\n\n  result_stream:\n    description: "Stream tool execution results to subscribers"\n    required_interfaces:\n      - stream_basic            # MUST support append/read\n      - stream_consumer_groups  # MUST support multiple consumers\n    optional_interfaces:\n      - stream_replay           # Nice to have: replay results\n    recommended_backends:\n      - kafka           # Event streaming\n      - nats            # NATS JetStream\n      - redis           # Redis Streams\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Configuration Example"})," (using the pattern):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'namespaces:\n  - name: ai-agents\n    pattern: ai-tool-orchestration\n    pattern_version: v1\n\n    slots:\n      tool_server:\n        backend: mcp\n        # MCP implements: mcp_tool, mcp_resource, mcp_prompt \u2713\n        interfaces:\n          - mcp_tool\n          - mcp_resource\n          - mcp_prompt\n        config:\n          connection: "mcp://localhost:3000"\n          timeout: 30s\n\n      execution_queue:\n        backend: postgres\n        # Postgres implements: queue_basic, queue_visibility, queue_dead_letter \u2713\n        interfaces:\n          - queue_basic\n          - queue_visibility\n          - queue_dead_letter\n        config:\n          connection: "postgresql://localhost:5432/prism"\n          table: "ai_tool_queue"\n          visibility_timeout: 60\n\n      result_stream:\n        backend: kafka\n        # Kafka implements: stream_basic, stream_consumer_groups, stream_replay \u2713\n        interfaces:\n          - stream_basic\n          - stream_consumer_groups\n          - stream_replay\n        config:\n          connection: "kafka://localhost:9092"\n          topic: "ai-tool-results"\n          retention: 7d\n'})}),"\n",(0,s.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,s.jsx)(n.h3,{id:"latency",children:"Latency"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Adapter overhead per request"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"HTTP parsing + validation: <0.5ms"}),"\n",(0,s.jsx)(n.li,{children:"JSON \u2192 Protobuf translation: <0.5ms"}),"\n",(0,s.jsx)(n.li,{children:"gRPC call to proxy (localhost): <1ms"}),"\n",(0,s.jsx)(n.li,{children:"Protobuf \u2192 JSON translation: <0.5ms"}),"\n",(0,s.jsx)(n.li,{children:"HTTP response formatting: <0.5ms"}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Total adapter overhead: <3ms P95"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Streaming overhead"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"SSE event formatting: <0.1ms per event"}),"\n",(0,s.jsx)(n.li,{children:"WebSocket frame overhead: <0.05ms per message"}),"\n",(0,s.jsx)(n.li,{children:"gRPC streaming: <1ms P95 (already measured)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"throughput",children:"Throughput"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Simple request/response"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Without adapter: 50,000 RPS (direct gRPC)"}),"\n",(0,s.jsx)(n.li,{children:"With adapter: 30,000 RPS (-40% overhead)"}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Bottleneck"}),": JSON encoding/decoding (can be optimized with faster JSON libraries)"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Streaming"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"SSE events: 10,000 events/sec per connection"}),"\n",(0,s.jsx)(n.li,{children:"WebSocket messages: 20,000 messages/sec per connection"}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Bottleneck"}),": Network buffering and flushing"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,s.jsx)(n.h3,{id:"1-adapter-bypass",children:"1. Adapter Bypass"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Risk"}),": Attacker connects directly to proxy, bypassing HTTP adapter validation."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Mitigation"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Proxy should NOT expose gRPC publicly (bind to localhost or internal network)"}),"\n",(0,s.jsx)(n.li,{children:"Use mTLS between adapter and proxy (adapter presents client certificate)"}),"\n",(0,s.jsx)(n.li,{children:"Network policies: Only adapter pods can reach proxy port"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-schema-validation-gaps",children:"2. Schema Validation Gaps"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Risk"}),": Adapter accepts invalid HTTP requests that cause proxy errors."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Mitigation"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Validate ALL incoming requests against API schema (OpenAPI, JSON Schema)"}),"\n",(0,s.jsx)(n.li,{children:"Reject malformed requests at adapter layer (don't forward to proxy)"}),"\n",(0,s.jsx)(n.li,{children:"Log validation failures for monitoring"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-authorization-bypass",children:"3. Authorization Bypass"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Risk"}),": Adapter doesn't pass authentication tokens to proxy."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Mitigation"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ALWAYS"})," forward HTTP Authorization header \u2192 gRPC metadata"]}),"\n",(0,s.jsx)(n.li,{children:"Proxy validates token (RFC-019), adapter never validates itself"}),"\n",(0,s.jsxs)(n.li,{children:["Example:\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'// Extract HTTP Authorization header\nauthHeader := r.Header.Get("Authorization")\n\n// Forward as gRPC metadata\nmd := metadata.New(map[string]string{\n    "authorization": authHeader,\n})\nctx := metadata.NewOutgoingContext(r.Context(), md)\n\n// Call proxy with auth metadata\nresp, err := client.Enumerate(ctx, grpcReq)\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"migration-path",children:"Migration Path"}),"\n",(0,s.jsx)(n.h3,{id:"phase-1-mcp-adapter-prototype-week-1",children:"Phase 1: MCP Adapter Prototype (Week 1)"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Implement minimal MCP adapter (Go)"}),"\n",(0,s.jsxs)(n.li,{children:["Support ",(0,s.jsx)(n.code,{children:"/mcp/v1/tools/call"})," endpoint only"]}),"\n",(0,s.jsx)(n.li,{children:"Translate to Multicast Registry pattern"}),"\n",(0,s.jsx)(n.li,{children:"Test with local MCP server"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"phase-2-sse-streaming-support-week-2",children:"Phase 2: SSE Streaming Support (Week 2)"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Implement ",(0,s.jsx)(n.code,{children:"/mcp/v1/events"})," endpoint with SSE"]}),"\n",(0,s.jsx)(n.li,{children:"Map to PubSub.Subscribe() streaming gRPC"}),"\n",(0,s.jsx)(n.li,{children:"Handle connection management and reconnection"}),"\n",(0,s.jsx)(n.li,{children:"Load test with 1,000 concurrent SSE connections"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"phase-3-agent-to-agent-adapter-week-3",children:"Phase 3: Agent-to-Agent Adapter (Week 3)"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Implement A2A adapter (separate codebase)"}),"\n",(0,s.jsx)(n.li,{children:"Support agent discovery and messaging"}),"\n",(0,s.jsx)(n.li,{children:"Translate to KeyValue + PubSub primitives"}),"\n",(0,s.jsx)(n.li,{children:"Test with multi-agent orchestration"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"phase-4-adapter-sdk-week-4",children:"Phase 4: Adapter SDK (Week 4)"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Extract common adapter logic into reusable SDK"}),"\n",(0,s.jsxs)(n.li,{children:["Provide helpers for:\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"JSON \u2194 Protobuf translation"}),"\n",(0,s.jsx)(n.li,{children:"HTTP \u2194 gRPC metadata mapping"}),"\n",(0,s.jsx)(n.li,{children:"SSE/WebSocket streaming utilities"}),"\n",(0,s.jsx)(n.li,{children:"Error mapping"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Publish adapter templates for common patterns"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"monitoring-and-observability",children:"Monitoring and Observability"}),"\n",(0,s.jsx)(n.h3,{id:"metrics",children:"Metrics"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Adapter-Level Metrics"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:'adapter_http_requests_total{adapter="mcp", endpoint="/tools/call", status="200"}'})," - HTTP requests"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:'adapter_translation_latency_seconds{direction="to_grpc|from_grpc"}'})," - Translation time"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:'adapter_grpc_calls_total{service="MulticastRegistry", method="Enumerate", status="OK"}'})," - gRPC calls"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:'adapter_sse_connections_active{adapter="mcp"}'})," - Active SSE connections"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:'adapter_errors_total{type="validation|translation|grpc"}'})," - Error counts"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Proxy Metrics"})," (from adapter's perspective):"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:'prism_proxy_latency_seconds{source="mcp-adapter"}'})," - Proxy response time"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:'prism_proxy_errors_total{source="mcp-adapter"}'})," - Proxy errors"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"logging",children:"Logging"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Adapter Request Log"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "timestamp": "2025-10-09T16:23:15Z",\n  "level": "info",\n  "message": "http_request",\n  "adapter": "mcp",\n  "http_method": "POST",\n  "http_path": "/mcp/v1/tools/call",\n  "grpc_service": "MulticastRegistryService",\n  "grpc_method": "Enumerate",\n  "translation_ms": 0.3,\n  "grpc_call_ms": 2.1,\n  "total_ms": 2.8,\n  "http_status": 200\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"open-questions",children:"Open Questions"}),"\n",(0,s.jsx)(n.h3,{id:"1-should-adapters-support-backend-specific-optimizations",children:"1. Should Adapters Support Backend-Specific Optimizations?"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Question"}),": Can adapter directly call specific backend if it knows the mapping?"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example"}),": MCP adapter knows namespace uses Redis, can it call Redis directly for better performance?"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Trade-offs"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Direct call"}),": Faster (no proxy hop), but breaks abstraction"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Via proxy"}),": Slower, but maintains separation of concerns"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Recommendation"}),": ",(0,s.jsx)(n.strong,{children:"Always go through proxy"}),". Optimization should happen at proxy level (e.g., proxy can optimize Redis-specific calls), not adapter level."]}),"\n",(0,s.jsx)(n.h3,{id:"2-how-to-version-adapters-independently",children:"2. How to Version Adapters Independently?"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Question"}),": How to handle MCP v1 \u2192 MCP v2 protocol upgrade?"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Options"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Separate adapters"}),": mcp-v1-adapter and mcp-v2-adapter run side-by-side"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Versioned endpoints"}),": Same adapter handles both ",(0,s.jsx)(n.code,{children:"/mcp/v1/"})," and ",(0,s.jsx)(n.code,{children:"/mcp/v2/"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Recommendation"}),": ",(0,s.jsx)(n.strong,{children:"Separate adapters"})," for major versions, ",(0,s.jsx)(n.strong,{children:"versioned endpoints"})," for minor versions."]}),"\n",(0,s.jsx)(n.h3,{id:"3-should-adapters-cache-responses",children:"3. Should Adapters Cache Responses?"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Question"}),": Can adapter cache HTTP responses to reduce proxy load?"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Pros"}),": Lower latency, less load on proxy\n",(0,s.jsx)(n.strong,{children:"Cons"}),": Stale data, cache invalidation complexity"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Recommendation"}),": ",(0,s.jsx)(n.strong,{children:"No caching in adapter"}),". If caching is needed, implement at proxy level where it can be coordinated across all clients."]}),"\n",(0,s.jsx)(n.h2,{id:"related-documents",children:"Related Documents"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/rfc/rfc-019-plugin-sdk-authorization-layer",children:"RFC-019: Plugin SDK Authorization Layer"})," - Authorization in plugins"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/memos/memo-006-backend-interface-decomposition-schema-registry",children:"MEMO-006: Backend Interface Decomposition"})," - Interface decomposition approach"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/rfc/rfc-014-layered-data-access-patterns",children:"RFC-014: Layered Data Access Patterns"})," - Layer 1 primitives"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/rfc/rfc-017-multicast-registry-pattern",children:"RFC-017: Multicast Registry Pattern"})," - Pattern coordinator example"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"2025-10-09: Initial RFC proposing streaming HTTP listener architecture and MCP as decomposed backend"}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);