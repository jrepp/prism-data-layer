"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[2676],{28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var t=i(96540);const r={},a=t.createContext(r);function s(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(a.Provider,{value:n},e.children)}},66836:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"rfc-019","title":"Pattern SDK Authorization Layer - Token Validation and Policy Enforcement","description":"Summary","source":"@site/../docs-cms/rfcs/rfc-019-plugin-sdk-authorization-layer.md","sourceDirName":".","slug":"/rfc-019","permalink":"/prism-data-layer/rfc/rfc-019","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/rfcs/rfc-019-plugin-sdk-authorization-layer.md","tags":[{"inline":true,"label":"authorization","permalink":"/prism-data-layer/rfc/tags/authorization"},{"inline":true,"label":"pattern","permalink":"/prism-data-layer/rfc/tags/pattern"},{"inline":true,"label":"sdk","permalink":"/prism-data-layer/rfc/tags/sdk"},{"inline":true,"label":"security","permalink":"/prism-data-layer/rfc/tags/security"},{"inline":true,"label":"tokens","permalink":"/prism-data-layer/rfc/tags/tokens"},{"inline":true,"label":"policy","permalink":"/prism-data-layer/rfc/tags/policy"},{"inline":true,"label":"go","permalink":"/prism-data-layer/rfc/tags/go"},{"inline":true,"label":"vault","permalink":"/prism-data-layer/rfc/tags/vault"},{"inline":true,"label":"credentials","permalink":"/prism-data-layer/rfc/tags/credentials"}],"version":"current","frontMatter":{"author":"Platform Team","created":"2025-10-09T00:00:00.000Z","doc_uuid":"8db689ab-37a4-42b5-8c47-8a9703e52f83","id":"rfc-019","project_id":"prism-data-layer","status":"Proposed","tags":["authorization","pattern","sdk","security","tokens","policy","go","vault","credentials"],"title":"Pattern SDK Authorization Layer - Token Validation and Policy Enforcement","updated":"2025-10-11T00:00:00.000Z"},"sidebar":"rfcSidebar","previous":{"title":"POC Implementation Strategy \u2022 RFC-018","permalink":"/prism-data-layer/rfc/rfc-018"},"next":{"title":"Streaming HTTP Listener - API-Specific Adapter Pattern \u2022 RFC-020","permalink":"/prism-data-layer/rfc/rfc-020"}}');var r=i(74848),a=i(28453);const s={author:"Platform Team",created:new Date("2025-10-09T00:00:00.000Z"),doc_uuid:"8db689ab-37a4-42b5-8c47-8a9703e52f83",id:"rfc-019",project_id:"prism-data-layer",status:"Proposed",tags:["authorization","pattern","sdk","security","tokens","policy","go","vault","credentials"],title:"Pattern SDK Authorization Layer - Token Validation and Policy Enforcement",updated:new Date("2025-10-11T00:00:00.000Z")},o="RFC-019: Pattern SDK Authorization Layer",l={},c=[{value:"Summary",id:"summary",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Architectural Decision: Token Validation at Plugin Layer",id:"architectural-decision-token-validation-at-plugin-layer",level:3},{value:"Current Gap",id:"current-gap",level:3},{value:"Desired State",id:"desired-state",level:3},{value:"Design Principles",id:"design-principles",level:2},{value:"1. Secure by Default",id:"1-secure-by-default",level:3},{value:"2. SDK Provides Authorization Primitives",id:"2-sdk-provides-authorization-primitives",level:3},{value:"3. Fail-Closed by Default",id:"3-fail-closed-by-default",level:3},{value:"4. Audit Everything",id:"4-audit-everything",level:3},{value:"5. Token Exchange and Credential Management",id:"5-token-exchange-and-credential-management",level:3},{value:"Why Token Exchange?",id:"why-token-exchange",level:4},{value:"Vault Integration Architecture",id:"vault-integration-architecture",level:4},{value:"Per-Session Credential Benefits",id:"per-session-credential-benefits",level:4},{value:"Implementation in Pattern SDK",id:"implementation-in-pattern-sdk",level:4},{value:"Configuration Example",id:"configuration-example",level:4},{value:"Vault Policy for Plugin",id:"vault-policy-for-plugin",level:4},{value:"Credential Lifecycle",id:"credential-lifecycle",level:4},{value:"Architecture",id:"architecture",level:2},{value:"Component Diagram",id:"component-diagram",level:3},{value:"Request Flow with Authorization",id:"request-flow-with-authorization",level:3},{value:"API Design",id:"api-design",level:2},{value:"Core Authorizer Interface",id:"core-authorizer-interface",level:3},{value:"Configuration",id:"configuration",level:3},{value:"Token Validator",id:"token-validator",level:3},{value:"Topaz Client",id:"topaz-client",level:3},{value:"Audit Logger",id:"audit-logger",level:3},{value:"Complete Authorizer Implementation",id:"complete-authorizer-implementation",level:3},{value:"Plugin Integration",id:"plugin-integration",level:2},{value:"gRPC Interceptor (Recommended)",id:"grpc-interceptor-recommended",level:3},{value:"Manual Authorization (Fine-Grained Control)",id:"manual-authorization-fine-grained-control",level:3},{value:"Configuration Examples",id:"configuration-examples",level:2},{value:"Production Configuration",id:"production-configuration",level:3},{value:"Local Development Configuration",id:"local-development-configuration",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"1. Token Theft",id:"1-token-theft",level:3},{value:"2. Token Replay",id:"2-token-replay",level:3},{value:"3. Plugin Bypass",id:"3-plugin-bypass",level:3},{value:"4. Policy Tampering",id:"4-policy-tampering",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Latency",id:"latency",level:3},{value:"Throughput",id:"throughput",level:3},{value:"Migration Path",id:"migration-path",level:2},{value:"Phase 1: SDK Implementation (Week 1)",id:"phase-1-sdk-implementation-week-1",level:3},{value:"Phase 2: Reference Plugin (Week 2)",id:"phase-2-reference-plugin-week-2",level:3},{value:"Phase 3: Documentation and Examples (Week 3)",id:"phase-3-documentation-and-examples-week-3",level:3},{value:"Phase 4: Rollout (Week 4)",id:"phase-4-rollout-week-4",level:3},{value:"Monitoring and Observability",id:"monitoring-and-observability",level:2},{value:"Metrics",id:"metrics",level:3},{value:"Logging",id:"logging",level:3},{value:"Alerts",id:"alerts",level:3},{value:"Open Questions",id:"open-questions",level:2},{value:"1. Should Plugins Trust Proxy Token Validation?",id:"1-should-plugins-trust-proxy-token-validation",level:3},{value:"2. How to Handle Token Expiration During Long-Running Operations?",id:"2-how-to-handle-token-expiration-during-long-running-operations",level:3},{value:"3. Should Audit Logs Include Request Payloads?",id:"3-should-audit-logs-include-request-payloads",level:3},{value:"Related Documents",id:"related-documents",level:2},{value:"Revision History",id:"revision-history",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"rfc-019-pattern-sdk-authorization-layer",children:"RFC-019: Pattern SDK Authorization Layer"})}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"Define a standardized authorization layer in the Prism core pattern SDK that enables backend patterns to:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Validate bearer tokens passed from the proxy"}),"\n",(0,r.jsx)(n.li,{children:"Enforce namespace-scoped access control"}),"\n",(0,r.jsx)(n.li,{children:"Query Topaz for fine-grained authorization decisions"}),"\n",(0,r.jsx)(n.li,{children:"Emit authorization audit events"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This ensures patterns respect the same authorization policies as the proxy, creating defense-in-depth security."}),"\n",(0,r.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,r.jsx)(n.h3,{id:"architectural-decision-token-validation-at-plugin-layer",children:"Architectural Decision: Token Validation at Plugin Layer"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"CRITICAL"}),": Token validation and exchange are ",(0,r.jsx)(n.strong,{children:"intentionally pushed to plugins"})," (not the proxy) because:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Per-Session Operation"}),": Token validation and credential exchange happen once per session, not per request"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"High-Latency Operation"}),": Token validation (JWT verification, OIDC discovery) adds latency (~10-50ms)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Secret Management Integration"}),": Plugins use validated tokens to fetch backend credentials from Vault"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Defense-in-Depth"}),": Plugins must validate independently even if proxy validates (zero-trust)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"current-gap",children:"Current Gap"}),"\n",(0,r.jsxs)(n.p,{children:["Currently, ",(0,r.jsx)(n.strong,{children:"plugins receive all requests without authorization checks"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Prism Proxy       \u2502\n\u2502   \u274c No token check  \u2502  \u2190 Proxy passes token through\n\u2502   \u27a1\ufe0f  Forwards token  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502\n           \u2502 gRPC (token in metadata)\n           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Plugin (Redis)    \u2502\n\u2502   \u274c No token check  \u2502\n\u2502   \u274c No authz check  \u2502\n\u2502   \u27a1\ufe0f  Direct access   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502\n           \u25bc\n      [Redis Backend]\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problems"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No defense-in-depth"}),": If proxy is bypassed, plugins have no authorization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Plugin-level vulnerabilities"}),": Compromised plugin can access all data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Inconsistent enforcement"}),": Plugins may implement different (or no) authorization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Audit gaps"}),": Authorization events not tracked at plugin layer"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No credential isolation"}),": All plugins share same backend credentials"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"desired-state",children:"Desired State"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Plugins validate tokens, exchange for credentials, and enforce policies"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Prism Proxy       \u2502\n\u2502   \u27a1\ufe0f  Forwards token  \u2502  \u2190 Proxy is stateless, passes token\n\u2502   \u274c No validation   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502\n           \u2502 gRPC (token in metadata)\n           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Plugin (Redis)                                \u2502\n\u2502   \u2705 Validates token per session \u2190 NEW          \u2502\n\u2502   \u2705 Exchanges token for credentials (Vault) \u2190  \u2502\n\u2502   \u2705 Checks authz via Topaz                     \u2502\n\u2502   \u2705 Audits access                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502\n           \u25bc (per-session credentials from Vault)\n      [Redis Backend]\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Per-session credential isolation"}),": Each user session gets unique backend credentials from Vault"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"High-latency operations amortized"}),": Token validation once per session, not per request"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Defense-in-depth"}),": Plugin-side validation even if proxy bypassed"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Consistent policies"}),": All plugins use same Topaz policies"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Audit completeness"}),": All data access logged at plugin layer"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Zero-trust architecture"}),": Never trust upstream components (proxy)"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Secret rotation"}),": Vault manages credential lifecycle, plugins fetch fresh credentials"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"design-principles",children:"Design Principles"}),"\n",(0,r.jsx)(n.h3,{id:"1-secure-by-default",children:"1. Secure by Default"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Plugins MUST validate tokens"})," unless explicitly configured for local-only testing."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// BAD: No authorization (insecure)\nfunc (s *RedisPlugin) Get(ctx context.Context, req *GetRequest) (*GetResponse, error) {\n    return s.redis.Get(req.Key)\n}\n\n// GOOD: Authorization required\nfunc (s *RedisPlugin) Get(ctx context.Context, req *GetRequest) (*GetResponse, error) {\n    // Validate token and check authorization\n    claims, err := s.authz.ValidateRequest(ctx, "read", req.Namespace)\n    if err != nil {\n        return nil, status.Error(codes.PermissionDenied, "Unauthorized")\n    }\n\n    return s.redis.Get(req.Key)\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-sdk-provides-authorization-primitives",children:"2. SDK Provides Authorization Primitives"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Core SDK provides reusable components"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Token validation (JWT, OIDC)"}),"\n",(0,r.jsx)(n.li,{children:"Topaz client (policy queries)"}),"\n",(0,r.jsx)(n.li,{children:"Audit logger (structured logs)"}),"\n",(0,r.jsx)(n.li,{children:"Authorization middleware (gRPC interceptors)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Patterns just call SDK"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'import "github.com/prism/pattern-sdk/authz"\n\n// Pattern uses SDK authorization\nfunc NewRedisPattern(config *Config) *RedisPattern {\n    return &RedisPattern{\n        redis: connectRedis(config),\n        authz: authz.NewAuthorizer(config.Topaz),  // SDK handles complexity\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"3-fail-closed-by-default",children:"3. Fail-Closed by Default"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Authorization failures block requests"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// Token validation fails \u2192 request denied\nclaims, err := authz.ValidateToken(token)\nif err != nil {\n    return status.Error(codes.Unauthenticated, "Invalid token")\n}\n\n// Policy check fails \u2192 request denied\nallowed, err := authz.CheckPolicy(ctx, claims.UserID, "read", namespace)\nif err != nil || !allowed {\n    return status.Error(codes.PermissionDenied, "Access denied")\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Exceptions"})," (opt-in for local testing):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"# config.yaml - local testing mode\nplugins:\n  redis:\n    authz:\n      enabled: false  # Disable for local development only\n      enforce: false  # Log violations but don't block\n"})}),"\n",(0,r.jsx)(n.h3,{id:"4-audit-everything",children:"4. Audit Everything"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"All authorization decisions logged"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// SDK automatically logs authorization events\nauthz.Audit(ctx, AuditEvent{\n    Timestamp:  time.Now(),\n    User:       claims.UserID,\n    Permission: "read",\n    Resource:   "namespace:iot-devices",\n    Decision:   "allowed",\n    Plugin:     "redis-plugin",\n    Backend:    "redis://localhost:6379",\n})\n'})}),"\n",(0,r.jsx)(n.h3,{id:"5-token-exchange-and-credential-management",children:"5. Token Exchange and Credential Management"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Plugins exchange validated tokens for per-session backend credentials from Vault"}),":"]}),"\n",(0,r.jsx)(n.h4,{id:"why-token-exchange",children:"Why Token Exchange?"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Shared backend credentials (same Redis password for all users) prevent:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Per-user audit trails in backend logs"}),"\n",(0,r.jsx)(n.li,{children:"Fine-grained access control at backend level"}),"\n",(0,r.jsx)(n.li,{children:"Credential rotation without downtime"}),"\n",(0,r.jsx)(n.li,{children:"User-specific rate limiting"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),": After validating the token, plugins use it to fetch ",(0,r.jsx)(n.strong,{children:"per-session backend credentials"})," from Vault:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// After token validation\nclaims, err := authz.ValidateToken(ctx, token)\n\n// Exchange token for backend credentials from Vault\ncredentials, err := vault.GetCredentials(claims.UserID, "redis", namespace)\n// credentials = { username: "user-alice-session-abc123", password: "..." }\n\n// Use per-session credentials for backend connection\nredisClient := redis.NewClient(&redis.Options{\n    Addr:     "localhost:6379",\n    Username: credentials.Username,  // Per-user username\n    Password: credentials.Password,  // Short-lived password from Vault\n})\n'})}),"\n",(0,r.jsx)(n.h4,{id:"vault-integration-architecture",children:"Vault Integration Architecture"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:'\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Plugin Session Lifecycle                 \u2502\n\u2502                                                             \u2502\n\u2502  1. Validate Token                                          \u2502\n\u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                        \u2502\n\u2502     \u2502 Token        \u2502  Verify JWT signature, expiry,        \u2502\n\u2502     \u2502 Validator    \u2502  claims (sub, exp, aud)               \u2502\n\u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                        \u2502\n\u2502           \u2502                                                  \u2502\n\u2502           \u25bc                                                  \u2502\n\u2502  2. Exchange Token for Credentials                          \u2502\n\u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502\n\u2502     \u2502 Vault Token Exchange                     \u2502            \u2502\n\u2502     \u2502                                          \u2502            \u2502\n\u2502     \u2502 POST /v1/auth/jwt/login                  \u2502            \u2502\n\u2502     \u2502 {                                        \u2502            \u2502\n\u2502     \u2502   "jwt": "<user-token>",                 \u2502            \u2502\n\u2502     \u2502   "role": "prism-redis-plugin"           \u2502            \u2502\n\u2502     \u2502 }                                        \u2502            \u2502\n\u2502     \u2502                                          \u2502            \u2502\n\u2502     \u2502 Response:                                \u2502            \u2502\n\u2502     \u2502 {                                        \u2502            \u2502\n\u2502     \u2502   "auth": {                              \u2502            \u2502\n\u2502     \u2502     "client_token": "<vault-token>",     \u2502            \u2502\n\u2502     \u2502     "lease_duration": 3600               \u2502            \u2502\n\u2502     \u2502   }                                      \u2502            \u2502\n\u2502     \u2502 }                                        \u2502            \u2502\n\u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502\n\u2502           \u2502                                                  \u2502\n\u2502           \u25bc                                                  \u2502\n\u2502  3. Fetch Backend Credentials                               \u2502\n\u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502\n\u2502     \u2502 GET /v1/database/creds/redis-role        \u2502            \u2502\n\u2502     \u2502 Header: X-Vault-Token: <vault-token>     \u2502            \u2502\n\u2502     \u2502                                          \u2502            \u2502\n\u2502     \u2502 Response:                                \u2502            \u2502\n\u2502     \u2502 {                                        \u2502            \u2502\n\u2502     \u2502   "data": {                              \u2502            \u2502\n\u2502     \u2502     "username": "v-jwt-alice-abc123",    \u2502            \u2502\n\u2502     \u2502     "password": "A1b2C3d4...",           \u2502            \u2502\n\u2502     \u2502   },                                     \u2502            \u2502\n\u2502     \u2502   "lease_duration": 3600,                \u2502            \u2502\n\u2502     \u2502   "renewable": true                      \u2502            \u2502\n\u2502     \u2502 }                                        \u2502            \u2502\n\u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502\n\u2502           \u2502                                                  \u2502\n\u2502           \u25bc                                                  \u2502\n\u2502  4. Connect to Backend with Session Credentials             \u2502\n\u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502\n\u2502     \u2502 Redis Connection                         \u2502            \u2502\n\u2502     \u2502 AUTH v-jwt-alice-abc123 A1b2C3d4...      \u2502            \u2502\n\u2502     \u2502                                          \u2502            \u2502\n\u2502     \u2502 Redis ACL: User-specific permissions     \u2502            \u2502\n\u2502     \u2502 - READ keys matching "user:alice:*"      \u2502            \u2502\n\u2502     \u2502 - No DELETE permission                   \u2502            \u2502\n\u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502\n\u2502                                                             \u2502\n\u2502  5. Credential Renewal (Background)                         \u2502\n\u2502     Every lease_duration/2:                                 \u2502\n\u2502     - Renew Vault token                                     \u2502\n\u2502     - Renew backend credentials                             \u2502\n\u2502     - Update Redis connection pool                          \u2502\n\u2502                                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n'})}),"\n",(0,r.jsx)(n.h4,{id:"per-session-credential-benefits",children:"Per-Session Credential Benefits"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Audit Trail"}),": Backend logs show which user accessed what data"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:'Redis log: [AUTH] v-jwt-alice-abc123 authenticated\nRedis log: [GET] v-jwt-alice-abc123 accessed key "user:alice:profile"\n'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Fine-Grained Access Control"}),": Vault generates credentials with user-specific ACLs"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"-- Vault generates PostgreSQL user with row-level security\nCREATE USER \"v-jwt-alice-abc123\" WITH PASSWORD '...';\nGRANT SELECT ON orders WHERE user_id = 'alice' TO \"v-jwt-alice-abc123\";\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Automatic Credential Rotation"}),": Vault rotates credentials every session/hour"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Plugin fetches new credentials before expiry"}),"\n",(0,r.jsx)(n.li,{children:"No shared long-lived credentials"}),"\n",(0,r.jsx)(n.li,{children:"Breach of one session doesn't compromise others"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Rate Limiting"}),": Backend can rate-limit per user, not per plugin"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Redis: LIMIT USER v-jwt-alice-abc123 TO 1000 ops/second\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"implementation-in-pattern-sdk",children:"Implementation in Pattern SDK"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// pkg/authz/vault_client.go\npackage authz\n\nimport (\n    vault "github.com/hashicorp/vault/api"\n)\n\n// VaultClient fetches per-session backend credentials\ntype VaultClient struct {\n    client *vault.Client\n    config VaultConfig\n}\n\ntype VaultConfig struct {\n    Address    string        // Vault address (https://vault:8200)\n    Namespace  string        // Vault namespace (optional)\n    Role       string        // JWT auth role (prism-redis-plugin)\n    AuthPath   string        // JWT auth mount path (auth/jwt)\n    SecretPath string        // Secret mount path (database/creds/redis-role)\n    RenewInterval time.Duration // Renew credentials every X seconds\n}\n\n// ExchangeTokenForCredentials exchanges user JWT for backend credentials\nfunc (v *VaultClient) ExchangeTokenForCredentials(ctx context.Context, userToken string) (*BackendCredentials, error) {\n    // Step 1: Authenticate to Vault using user\'s JWT\n    secret, err := v.client.Logical().Write(v.config.AuthPath+"/login", map[string]interface{}{\n        "jwt":  userToken,\n        "role": v.config.Role,\n    })\n    if err != nil {\n        return nil, fmt.Errorf("vault JWT login failed: %w", err)\n    }\n\n    vaultToken := secret.Auth.ClientToken\n    leaseDuration := time.Duration(secret.Auth.LeaseDuration) * time.Second\n\n    // Step 2: Fetch backend credentials using Vault token\n    v.client.SetToken(vaultToken)\n    secret, err = v.client.Logical().Read(v.config.SecretPath)\n    if err != nil {\n        return nil, fmt.Errorf("failed to fetch backend credentials: %w", err)\n    }\n\n    creds := &BackendCredentials{\n        Username:      secret.Data["username"].(string),\n        Password:      secret.Data["password"].(string),\n        LeaseDuration: time.Duration(secret.LeaseDuration) * time.Second,\n        LeaseID:       secret.LeaseID,\n        VaultToken:    vaultToken,\n    }\n\n    // Step 3: Start background renewal goroutine\n    go v.renewCredentials(ctx, creds)\n\n    return creds, nil\n}\n\n// renewCredentials renews credentials before expiry\nfunc (v *VaultClient) renewCredentials(ctx context.Context, creds *BackendCredentials) {\n    ticker := time.NewTicker(creds.LeaseDuration / 2)\n    defer ticker.Stop()\n\n    for {\n        select {\n        case <-ctx.Done():\n            return\n        case <-ticker.C:\n            // Renew Vault token\n            _, err := v.client.Auth().Token().RenewSelf(int(creds.LeaseDuration.Seconds()))\n            if err != nil {\n                log.Error("failed to renew vault token", err)\n                return\n            }\n\n            // Renew backend credentials\n            _, err = v.client.Logical().Write("/sys/leases/renew", map[string]interface{}{\n                "lease_id": creds.LeaseID,\n            })\n            if err != nil {\n                log.Error("failed to renew backend credentials", err)\n                return\n            }\n\n            log.Info("renewed backend credentials", "lease_id", creds.LeaseID)\n        }\n    }\n}\n\ntype BackendCredentials struct {\n    Username      string\n    Password      string\n    LeaseDuration time.Duration\n    LeaseID       string\n    VaultToken    string\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"configuration-example",children:"Configuration Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'# plugins/redis/config.yaml\nauthz:\n  token:\n    enabled: true\n    issuer: "https://auth.prism.io"\n    audience: "prism-plugins"\n\n  vault:\n    enabled: true\n    address: "https://vault:8200"\n    role: "prism-redis-plugin"\n    auth_path: "auth/jwt"\n    secret_path: "database/creds/redis-role"\n    renew_interval: 1800s  # Renew every 30 minutes\n    tls:\n      ca_cert: "/etc/prism/vault-ca.pem"\n\n  topaz:\n    enabled: true\n    endpoint: "localhost:8282"\n'})}),"\n",(0,r.jsx)(n.h4,{id:"vault-policy-for-plugin",children:"Vault Policy for Plugin"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",children:'# Vault policy for Redis plugin\npath "database/creds/redis-role" {\n  capabilities = ["read"]\n}\n\npath "auth/token/renew-self" {\n  capabilities = ["update"]\n}\n\npath "sys/leases/renew" {\n  capabilities = ["update"]\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"credential-lifecycle",children:"Credential Lifecycle"}),"\n",(0,r.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant Client\n    participant Proxy\n    participant Plugin\n    participant Vault\n    participant Redis\n\n    Client->>Proxy: Request (JWT token)\n    Proxy->>Plugin: Forward (JWT in metadata)\n\n    activate Plugin\n    Note over Plugin: Per-Session Setup (once)\n\n    Plugin->>Plugin: Validate JWT token\n    Plugin->>Vault: POST /auth/jwt/login<br/>(user JWT + role)\n    Vault--\x3e>Plugin: Vault token (1h TTL)\n\n    Plugin->>Vault: GET /database/creds/redis-role<br/>(Vault token)\n    Vault--\x3e>Plugin: { username, password } (1h lease)\n\n    Plugin->>Redis: AUTH username password\n    Redis--\x3e>Plugin: OK\n\n    Note over Plugin: Session Active\n\n    loop Every 30 minutes\n        Plugin->>Vault: Renew token\n        Plugin->>Vault: Renew credentials lease\n    end\n\n    Note over Plugin: Session End\n\n    Plugin->>Vault: Revoke lease\n    Vault--\x3e>Redis: DROP USER username\n    deactivate Plugin"}),"\n",(0,r.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,r.jsx)(n.h3,{id:"component-diagram",children:"Component Diagram"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                       Pattern SDK (Go)                        \u2502\n\u2502                                                               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502           authz Package (New)                           \u2502 \u2502\n\u2502  \u2502                                                         \u2502 \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502\n\u2502  \u2502  \u2502 TokenValidator\u2502  \u2502 TopazClient  \u2502  \u2502 AuditLogger  \u2502 \u2502 \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502\n\u2502  \u2502                                                         \u2502 \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502 \u2502\n\u2502  \u2502  \u2502   Authorizer (Orchestrates All Components)        \u2502  \u2502 \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502 \u2502\n\u2502  \u2502                                                         \u2502 \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502 \u2502\n\u2502  \u2502  \u2502   gRPC Interceptors (Middleware)                  \u2502  \u2502 \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                                                               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502           core Package (Existing)                       \u2502 \u2502\n\u2502  \u2502   - Plugin interface                                    \u2502 \u2502\n\u2502  \u2502   - Config structs                                      \u2502 \u2502\n\u2502  \u2502   - Health checks                                       \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(n.h3,{id:"request-flow-with-authorization",children:"Request Flow with Authorization"}),"\n",(0,r.jsx)(n.mermaid,{value:'sequenceDiagram\n    participant Proxy as Prism Proxy\n    participant Plugin as Backend Plugin\n    participant TokenVal as Token Validator\n    participant Topaz as Topaz Sidecar\n    participant Audit as Audit Logger\n    participant Backend as Backend (Redis)\n\n    Proxy->>Plugin: gRPC Request<br/>(token in metadata)\n\n    activate Plugin\n    Plugin->>TokenVal: ValidateToken(token)\n    activate TokenVal\n    TokenVal--\x3e>Plugin: Claims (user_id, exp, ...)\n    deactivate TokenVal\n\n    Plugin->>Topaz: Is(user, "read", namespace)?\n    activate Topaz\n    Topaz--\x3e>Plugin: { allowed: true }\n    deactivate Topaz\n\n    Plugin->>Audit: LogAuthzDecision(user, read, namespace, allowed)\n\n    Plugin->>Backend: GET key\n    activate Backend\n    Backend--\x3e>Plugin: value\n    deactivate Backend\n\n    Plugin--\x3e>Proxy: Response\n    deactivate Plugin'}),"\n",(0,r.jsx)(n.h2,{id:"api-design",children:"API Design"}),"\n",(0,r.jsx)(n.h3,{id:"core-authorizer-interface",children:"Core Authorizer Interface"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// pkg/authz/authorizer.go\npackage authz\n\nimport (\n    "context"\n    "github.com/prism/pattern-sdk/core"\n)\n\n// Authorizer validates tokens and enforces policies\ntype Authorizer interface {\n    // ValidateRequest validates token and checks authorization in one call\n    ValidateRequest(ctx context.Context, permission string, resource string) (*Claims, error)\n\n    // ValidateToken validates JWT token and returns claims\n    ValidateToken(ctx context.Context) (*Claims, error)\n\n    // CheckPolicy queries Topaz for authorization decision\n    CheckPolicy(ctx context.Context, userID string, permission string, resource string) (bool, error)\n\n    // Audit logs authorization decision\n    Audit(ctx context.Context, event AuditEvent)\n}\n\n// Claims represents validated token claims\ntype Claims struct {\n    UserID    string            // Subject (user ID)\n    Email     string            // User email\n    Groups    []string          // User groups\n    ExpiresAt time.Time         // Token expiration\n    IssuedAt  time.Time         // Token issue time\n    Issuer    string            // OIDC issuer\n    Custom    map[string]any    // Custom claims\n}\n\n// AuditEvent represents an authorization decision\ntype AuditEvent struct {\n    Timestamp  time.Time\n    User       string\n    Permission string\n    Resource   string\n    Decision   string  // "allowed" or "denied"\n    Plugin     string\n    Backend    string\n    Reason     string  // Why was decision made?\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"configuration",children:"Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// pkg/authz/config.go\npackage authz\n\n// Config configures the authorization layer\ntype Config struct {\n    // Token validation settings\n    Token TokenConfig `yaml:"token"`\n\n    // Topaz policy engine settings\n    Topaz TopazConfig `yaml:"topaz"`\n\n    // Audit logging settings\n    Audit AuditConfig `yaml:"audit"`\n\n    // Enforcement mode\n    Enforce bool `yaml:"enforce"` // If false, log violations but don\'t block\n}\n\ntype TokenConfig struct {\n    // Enabled enables token validation (default: true)\n    Enabled bool `yaml:"enabled"`\n\n    // Issuer is the OIDC issuer URL\n    Issuer string `yaml:"issuer"`\n\n    // Audience is the expected token audience\n    Audience string `yaml:"audience"`\n\n    // JWKS URL for fetching public keys\n    JWKSURL string `yaml:"jwks_url"`\n\n    // CacheTTL for JWKS keys (default: 1 hour)\n    CacheTTL time.Duration `yaml:"cache_ttl"`\n\n    // AllowExpired allows expired tokens (local testing only)\n    AllowExpired bool `yaml:"allow_expired"`\n}\n\ntype TopazConfig struct {\n    // Endpoint is the Topaz gRPC endpoint (e.g., localhost:8282)\n    Endpoint string `yaml:"endpoint"`\n\n    // TLS settings for Topaz connection\n    TLS TLSConfig `yaml:"tls"`\n\n    // Timeout for authorization checks (default: 5s)\n    Timeout time.Duration `yaml:"timeout"`\n\n    // CacheTTL for authorization decisions (default: 5s)\n    CacheTTL time.Duration `yaml:"cache_ttl"`\n\n    // Enabled enables Topaz policy checks (default: true)\n    Enabled bool `yaml:"enabled"`\n}\n\ntype AuditConfig struct {\n    // Enabled enables audit logging (default: true)\n    Enabled bool `yaml:"enabled"`\n\n    // Destination for audit logs (stdout, file, syslog, grpc)\n    Destination string `yaml:"destination"`\n\n    // File path for file destination\n    FilePath string `yaml:"file_path"`\n\n    // Format (json, text)\n    Format string `yaml:"format"`\n\n    // Buffer size for async logging\n    BufferSize int `yaml:"buffer_size"`\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"token-validator",children:"Token Validator"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// pkg/authz/token_validator.go\npackage authz\n\nimport (\n    "context"\n    "fmt"\n    "github.com/coreos/go-oidc/v3/oidc"\n    "github.com/golang-jwt/jwt/v5"\n    "google.golang.org/grpc/metadata"\n)\n\n// TokenValidator validates JWT tokens from gRPC metadata\ntype TokenValidator struct {\n    config   TokenConfig\n    verifier *oidc.IDTokenVerifier\n    jwks     *jwk.Set  // Cached JWKS keys\n}\n\n// NewTokenValidator creates a token validator\nfunc NewTokenValidator(config TokenConfig) (*TokenValidator, error) {\n    provider, err := oidc.NewProvider(context.Background(), config.Issuer)\n    if err != nil {\n        return nil, fmt.Errorf("failed to create OIDC provider: %w", err)\n    }\n\n    verifier := provider.Verifier(&oidc.Config{\n        ClientID: config.Audience,\n    })\n\n    return &TokenValidator{\n        config:   config,\n        verifier: verifier,\n    }, nil\n}\n\n// ValidateFromContext extracts and validates token from gRPC context\nfunc (v *TokenValidator) ValidateFromContext(ctx context.Context) (*Claims, error) {\n    // Extract token from gRPC metadata\n    md, ok := metadata.FromIncomingContext(ctx)\n    if !ok {\n        return nil, ErrNoMetadata\n    }\n\n    tokens := md.Get("authorization")\n    if len(tokens) == 0 {\n        return nil, ErrNoToken\n    }\n\n    // Remove "Bearer " prefix\n    token := strings.TrimPrefix(tokens[0], "Bearer ")\n\n    // Validate token\n    return v.Validate(ctx, token)\n}\n\n// Validate validates a JWT token and returns claims\nfunc (v *TokenValidator) Validate(ctx context.Context, tokenString string) (*Claims, error) {\n    // Verify token signature and claims\n    idToken, err := v.verifier.Verify(ctx, tokenString)\n    if err != nil {\n        if v.config.AllowExpired && strings.Contains(err.Error(), "expired") {\n            // Local testing mode: allow expired tokens\n            return v.parseUnverifiedToken(tokenString)\n        }\n        return nil, fmt.Errorf("token validation failed: %w", err)\n    }\n\n    // Extract standard claims\n    var claims Claims\n    if err := idToken.Claims(&claims); err != nil {\n        return nil, fmt.Errorf("failed to parse claims: %w", err)\n    }\n\n    return &claims, nil\n}\n\n// parseUnverifiedToken parses token without verification (local testing only)\nfunc (v *TokenValidator) parseUnverifiedToken(tokenString string) (*Claims, error) {\n    parser := jwt.NewParser(jwt.WithoutClaimsValidation())\n    token, _, err := parser.ParseUnverified(tokenString, jwt.MapClaims{})\n    if err != nil {\n        return nil, err\n    }\n\n    mapClaims := token.Claims.(jwt.MapClaims)\n    return claimsFromMap(mapClaims), nil\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"topaz-client",children:"Topaz Client"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// pkg/authz/topaz_client.go\npackage authz\n\nimport (\n    "context"\n    "fmt"\n    "time"\n\n    topaz "github.com/aserto-dev/go-grpc/aserto/authorizer/v2"\n    "google.golang.org/grpc"\n    "google.golang.org/grpc/credentials/insecure"\n)\n\n// TopazClient queries Topaz for authorization decisions\ntype TopazClient struct {\n    client topaz.AuthorizerClient\n    cache  *DecisionCache\n    config TopazConfig\n}\n\n// NewTopazClient creates a Topaz client\nfunc NewTopazClient(config TopazConfig) (*TopazClient, error) {\n    opts := []grpc.DialOption{\n        grpc.WithTransportCredentials(insecure.NewCredentials()),\n    }\n\n    if config.TLS.Enabled {\n        // Add TLS credentials\n        creds, err := loadTLSCredentials(config.TLS)\n        if err != nil {\n            return nil, err\n        }\n        opts = []grpc.DialOption{grpc.WithTransportCredentials(creds)}\n    }\n\n    conn, err := grpc.Dial(config.Endpoint, opts...)\n    if err != nil {\n        return nil, fmt.Errorf("failed to connect to Topaz: %w", err)\n    }\n\n    client := topaz.NewAuthorizerClient(conn)\n\n    return &TopazClient{\n        client: client,\n        cache:  NewDecisionCache(config.CacheTTL),\n        config: config,\n    }, nil\n}\n\n// Is checks if subject has permission on object\nfunc (c *TopazClient) Is(ctx context.Context, subject, permission, object string) (bool, error) {\n    // Check cache first\n    if decision, ok := c.cache.Get(subject, permission, object); ok {\n        return decision, nil\n    }\n\n    // Query Topaz\n    ctx, cancel := context.WithTimeout(ctx, c.config.Timeout)\n    defer cancel()\n\n    resp, err := c.client.Is(ctx, &topaz.IsRequest{\n        PolicyContext: &topaz.PolicyContext{\n            Path:      "prism.authz",\n            Decisions: []string{"allowed"},\n        },\n        IdentityContext: &topaz.IdentityContext{\n            Type:     topaz.IdentityType_IDENTITY_TYPE_SUB,\n            Identity: subject,\n        },\n        ResourceContext: &topaz.ResourceContext{\n            ObjectType: extractResourceType(object),\n            ObjectId:   extractResourceID(object),\n        },\n    })\n\n    if err != nil {\n        return false, fmt.Errorf("Topaz query failed: %w", err)\n    }\n\n    allowed := resp.Decisions["allowed"]\n\n    // Cache decision\n    c.cache.Set(subject, permission, object, allowed)\n\n    return allowed, nil\n}\n\n// DecisionCache caches authorization decisions\ntype DecisionCache struct {\n    entries map[string]cacheEntry\n    ttl     time.Duration\n    mu      sync.RWMutex\n}\n\ntype cacheEntry struct {\n    decision  bool\n    expiresAt time.Time\n}\n\nfunc (c *DecisionCache) Get(subject, permission, object string) (bool, bool) {\n    key := fmt.Sprintf("%s:%s:%s", subject, permission, object)\n\n    c.mu.RLock()\n    defer c.mu.RUnlock()\n\n    entry, ok := c.entries[key]\n    if !ok || time.Now().After(entry.expiresAt) {\n        return false, false\n    }\n\n    return entry.decision, true\n}\n\nfunc (c *DecisionCache) Set(subject, permission, object string, decision bool) {\n    key := fmt.Sprintf("%s:%s:%s", subject, permission, object)\n\n    c.mu.Lock()\n    defer c.mu.Unlock()\n\n    c.entries[key] = cacheEntry{\n        decision:  decision,\n        expiresAt: time.Now().Add(c.ttl),\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"audit-logger",children:"Audit Logger"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// pkg/authz/audit_logger.go\npackage authz\n\nimport (\n    "context"\n    "encoding/json"\n    "log/slog"\n    "os"\n)\n\n// AuditLogger logs authorization events\ntype AuditLogger struct {\n    logger *slog.Logger\n    config AuditConfig\n    buffer chan AuditEvent\n}\n\n// NewAuditLogger creates an audit logger\nfunc NewAuditLogger(config AuditConfig) *AuditLogger {\n    var handler slog.Handler\n\n    switch config.Destination {\n    case "stdout":\n        handler = slog.NewJSONHandler(os.Stdout, nil)\n    case "file":\n        file, _ := os.OpenFile(config.FilePath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)\n        handler = slog.NewJSONHandler(file, nil)\n    default:\n        handler = slog.NewJSONHandler(os.Stdout, nil)\n    }\n\n    logger := slog.New(handler)\n\n    al := &AuditLogger{\n        logger: logger,\n        config: config,\n        buffer: make(chan AuditEvent, config.BufferSize),\n    }\n\n    // Start async logger\n    go al.processEvents()\n\n    return al\n}\n\n// Log logs an authorization event\nfunc (l *AuditLogger) Log(event AuditEvent) {\n    if !l.config.Enabled {\n        return\n    }\n\n    select {\n    case l.buffer <- event:\n        // Event buffered successfully\n    default:\n        // Buffer full, log synchronously\n        l.logEvent(event)\n    }\n}\n\n// processEvents processes buffered audit events asynchronously\nfunc (l *AuditLogger) processEvents() {\n    for event := range l.buffer {\n        l.logEvent(event)\n    }\n}\n\n// logEvent writes audit event to configured destination\nfunc (l *AuditLogger) logEvent(event AuditEvent) {\n    l.logger.Info("authorization_decision",\n        slog.Time("timestamp", event.Timestamp),\n        slog.String("user", event.User),\n        slog.String("permission", event.Permission),\n        slog.String("resource", event.Resource),\n        slog.String("decision", event.Decision),\n        slog.String("plugin", event.Plugin),\n        slog.String("backend", event.Backend),\n        slog.String("reason", event.Reason),\n    )\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"complete-authorizer-implementation",children:"Complete Authorizer Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// pkg/authz/authorizer.go\npackage authz\n\nimport (\n    "context"\n    "fmt"\n    "time"\n)\n\n// authorizer implements the Authorizer interface\ntype authorizer struct {\n    config    Config\n    validator *TokenValidator\n    topaz     *TopazClient\n    audit     *AuditLogger\n}\n\n// NewAuthorizer creates a new authorizer\nfunc NewAuthorizer(config Config) (Authorizer, error) {\n    var validator *TokenValidator\n    var topaz *TopazClient\n    var audit *AuditLogger\n    var err error\n\n    // Initialize token validator\n    if config.Token.Enabled {\n        validator, err = NewTokenValidator(config.Token)\n        if err != nil {\n            return nil, fmt.Errorf("failed to create token validator: %w", err)\n        }\n    }\n\n    // Initialize Topaz client\n    if config.Topaz.Enabled {\n        topaz, err = NewTopazClient(config.Topaz)\n        if err != nil {\n            return nil, fmt.Errorf("failed to create Topaz client: %w", err)\n        }\n    }\n\n    // Initialize audit logger\n    if config.Audit.Enabled {\n        audit = NewAuditLogger(config.Audit)\n    }\n\n    return &authorizer{\n        config:    config,\n        validator: validator,\n        topaz:     topaz,\n        audit:     audit,\n    }, nil\n}\n\n// ValidateRequest validates token and checks authorization\nfunc (a *authorizer) ValidateRequest(ctx context.Context, permission, resource string) (*Claims, error) {\n    start := time.Now()\n\n    // Step 1: Validate token\n    claims, err := a.ValidateToken(ctx)\n    if err != nil {\n        a.auditDenial(ctx, "", permission, resource, "token_validation_failed", err.Error())\n        return nil, err\n    }\n\n    // Step 2: Check policy\n    allowed, err := a.CheckPolicy(ctx, claims.UserID, permission, resource)\n    if err != nil {\n        a.auditDenial(ctx, claims.UserID, permission, resource, "policy_check_failed", err.Error())\n        return nil, fmt.Errorf("authorization check failed: %w", err)\n    }\n\n    if !allowed {\n        a.auditDenial(ctx, claims.UserID, permission, resource, "policy_denied", "User does not have permission")\n\n        if a.config.Enforce {\n            return nil, ErrPermissionDenied\n        }\n        // Enforce=false: log but allow (local testing)\n    }\n\n    // Success\n    a.auditAllow(ctx, claims.UserID, permission, resource, time.Since(start))\n\n    return claims, nil\n}\n\n// ValidateToken validates JWT token from context\nfunc (a *authorizer) ValidateToken(ctx context.Context) (*Claims, error) {\n    if a.validator == nil {\n        // Token validation disabled (local testing)\n        return &Claims{UserID: "local-user"}, nil\n    }\n\n    return a.validator.ValidateFromContext(ctx)\n}\n\n// CheckPolicy queries Topaz for authorization decision\nfunc (a *authorizer) CheckPolicy(ctx context.Context, userID, permission, resource string) (bool, error) {\n    if a.topaz == nil {\n        // Policy checks disabled (local testing)\n        return true, nil\n    }\n\n    return a.topaz.Is(ctx, userID, permission, resource)\n}\n\n// Audit logs authorization decision\nfunc (a *authorizer) Audit(ctx context.Context, event AuditEvent) {\n    if a.audit == nil {\n        return\n    }\n\n    a.audit.Log(event)\n}\n\nfunc (a *authorizer) auditAllow(ctx context.Context, user, permission, resource string, latency time.Duration) {\n    a.Audit(ctx, AuditEvent{\n        Timestamp:  time.Now(),\n        User:       user,\n        Permission: permission,\n        Resource:   resource,\n        Decision:   "allowed",\n        Reason:     fmt.Sprintf("authorized in %v", latency),\n    })\n}\n\nfunc (a *authorizer) auditDenial(ctx context.Context, user, permission, resource, reason, details string) {\n    a.Audit(ctx, AuditEvent{\n        Timestamp:  time.Now(),\n        User:       user,\n        Permission: permission,\n        Resource:   resource,\n        Decision:   "denied",\n        Reason:     fmt.Sprintf("%s: %s", reason, details),\n    })\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"plugin-integration",children:"Plugin Integration"}),"\n",(0,r.jsx)(n.h3,{id:"grpc-interceptor-recommended",children:"gRPC Interceptor (Recommended)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Automatically enforce authorization on all gRPC methods"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// patterns/redis/main.go\npackage main\n\nimport (\n    "context"\n    "github.com/prism/pattern-sdk/authz"\n    "github.com/prism/pattern-sdk/core"\n    "google.golang.org/grpc"\n)\n\nfunc main() {\n    // Initialize authorizer\n    authzConfig := authz.Config{\n        Token: authz.TokenConfig{\n            Enabled:  true,\n            Issuer:   "https://auth.prism.io",\n            Audience: "prism-plugins",\n        },\n        Topaz: authz.TopazConfig{\n            Enabled:  true,\n            Endpoint: "localhost:8282",\n        },\n        Enforce: true,\n    }\n\n    authorizer, err := authz.NewAuthorizer(authzConfig)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Create gRPC server with authorization interceptor\n    server := grpc.NewServer(\n        grpc.UnaryInterceptor(authz.UnaryServerInterceptor(authorizer)),\n        grpc.StreamInterceptor(authz.StreamServerInterceptor(authorizer)),\n    )\n\n    // Register plugin service\n    plugin := &RedisPlugin{\n        redis: connectRedis(),\n        authz: authorizer,\n    }\n\n    pb.RegisterKeyValueServiceServer(server, plugin)\n\n    // Start server\n    lis, _ := net.Listen("tcp", ":50051")\n    server.Serve(lis)\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"gRPC Interceptor Implementation"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// pkg/authz/interceptor.go\npackage authz\n\nimport (\n    "context"\n    "google.golang.org/grpc"\n    "google.golang.org/grpc/codes"\n    "google.golang.org/grpc/status"\n)\n\n// UnaryServerInterceptor creates a gRPC unary interceptor for authorization\nfunc UnaryServerInterceptor(authz Authorizer) grpc.UnaryServerInterceptor {\n    return func(\n        ctx context.Context,\n        req interface{},\n        info *grpc.UnaryServerInfo,\n        handler grpc.UnaryHandler,\n    ) (interface{}, error) {\n        // Extract resource and permission from request\n        resource, permission := extractResourceAndPermission(req, info.FullMethod)\n\n        // Validate token and check authorization\n        claims, err := authz.ValidateRequest(ctx, permission, resource)\n        if err != nil {\n            return nil, status.Error(codes.PermissionDenied, err.Error())\n        }\n\n        // Inject claims into context for handler\n        ctx = ContextWithClaims(ctx, claims)\n\n        // Call handler\n        return handler(ctx, req)\n    }\n}\n\n// StreamServerInterceptor creates a gRPC stream interceptor for authorization\nfunc StreamServerInterceptor(authz Authorizer) grpc.StreamServerInterceptor {\n    return func(\n        srv interface{},\n        stream grpc.ServerStream,\n        info *grpc.StreamServerInfo,\n        handler grpc.StreamHandler,\n    ) error {\n        ctx := stream.Context()\n\n        // Extract resource and permission\n        resource, permission := extractResourceAndPermission(nil, info.FullMethod)\n\n        // Validate token and check authorization\n        claims, err := authz.ValidateRequest(ctx, permission, resource)\n        if err != nil {\n            return status.Error(codes.PermissionDenied, err.Error())\n        }\n\n        // Wrap stream with claims\n        wrappedStream := &authorizedStream{\n            ServerStream: stream,\n            ctx:          ContextWithClaims(ctx, claims),\n        }\n\n        // Call handler\n        return handler(srv, wrappedStream)\n    }\n}\n\n// extractResourceAndPermission infers resource and permission from request\nfunc extractResourceAndPermission(req interface{}, method string) (string, string) {\n    // Extract namespace from request (if present)\n    var resource string\n    if r, ok := req.(interface{ GetNamespace() string }); ok {\n        resource = "namespace:" + r.GetNamespace()\n    } else {\n        resource = "unknown"\n    }\n\n    // Infer permission from gRPC method\n    permission := "read" // default\n    if strings.Contains(method, "Set") || strings.Contains(method, "Delete") || strings.Contains(method, "Write") {\n        permission = "write"\n    }\n\n    return resource, permission\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"manual-authorization-fine-grained-control",children:"Manual Authorization (Fine-Grained Control)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"For methods requiring custom authorization logic"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// patterns/redis/service.go\npackage main\n\nimport (\n    "context"\n    "github.com/prism/pattern-sdk/authz"\n    pb "github.com/prism/proto/keyvalue"\n)\n\ntype RedisPlugin struct {\n    pb.UnimplementedKeyValueServiceServer\n    redis *redis.Client\n    authz authz.Authorizer\n}\n\n// Get retrieves a value (requires read permission)\nfunc (s *RedisPlugin) Get(ctx context.Context, req *pb.GetRequest) (*pb.GetResponse, error) {\n    // Validate authorization\n    claims, err := s.authz.ValidateRequest(ctx, "read", "namespace:"+req.Namespace)\n    if err != nil {\n        return nil, err\n    }\n\n    // Perform operation\n    value, err := s.redis.Get(ctx, req.Key).Result()\n    if err != nil {\n        return nil, err\n    }\n\n    return &pb.GetResponse{Value: value}, nil\n}\n\n// BatchDelete deletes multiple keys (requires admin permission)\nfunc (s *RedisPlugin) BatchDelete(ctx context.Context, req *pb.BatchDeleteRequest) (*pb.BatchDeleteResponse, error) {\n    // Require admin permission for batch operations\n    claims, err := s.authz.ValidateRequest(ctx, "admin", "namespace:"+req.Namespace)\n    if err != nil {\n        return nil, status.Error(codes.PermissionDenied, "Batch delete requires admin permission")\n    }\n\n    // Perform operation\n    deleted, err := s.redis.Del(ctx, req.Keys...).Result()\n    if err != nil {\n        return nil, err\n    }\n\n    return &pb.BatchDeleteResponse{Count: deleted}, nil\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"configuration-examples",children:"Configuration Examples"}),"\n",(0,r.jsx)(n.h3,{id:"production-configuration",children:"Production Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'# plugins/redis/config.yaml\nplugin:\n  name: redis\n  version: v1.0.0\n\nredis:\n  address: redis://localhost:6379\n  db: 0\n\n# Authorization settings\nauthz:\n  # Token validation\n  token:\n    enabled: true\n    issuer: "https://auth.prism.io"\n    audience: "prism-plugins"\n    jwks_url: "https://auth.prism.io/.well-known/jwks.json"\n    cache_ttl: 1h\n    allow_expired: false\n\n  # Topaz policy engine\n  topaz:\n    enabled: true\n    endpoint: "localhost:8282"\n    timeout: 5s\n    cache_ttl: 5s\n    tls:\n      enabled: false\n\n  # Audit logging\n  audit:\n    enabled: true\n    destination: "stdout"\n    format: "json"\n    buffer_size: 1000\n\n  # Enforcement mode\n  enforce: true  # Fail-closed (block unauthorized requests)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"local-development-configuration",children:"Local Development Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'# plugins/redis/config.local.yaml\nplugin:\n  name: redis\n  version: v1.0.0-local\n\nredis:\n  address: redis://localhost:6379\n  db: 0\n\n# Authorization settings (relaxed for local dev)\nauthz:\n  # Token validation (disabled for local testing)\n  token:\n    enabled: false\n    allow_expired: true\n\n  # Topaz policy engine (disabled for local testing)\n  topaz:\n    enabled: false\n\n  # Audit logging (still enabled for visibility)\n  audit:\n    enabled: true\n    destination: "stdout"\n    format: "json"\n\n  # Enforcement mode (log violations but don\'t block)\n  enforce: false\n'})}),"\n",(0,r.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"1-token-theft",children:"1. Token Theft"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Risk"}),": Attacker steals JWT token and replays it to plugin."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Mitigation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Short token TTL (15 minutes)"}),"\n",(0,r.jsx)(n.li,{children:"Token binding to client IP (via custom claim)"}),"\n",(0,r.jsx)(n.li,{children:"Refresh token rotation"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-token-replay",children:"2. Token Replay"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Risk"}),": Attacker intercepts token and replays it after user logs out."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Mitigation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Token revocation list (check against Topaz)"}),"\n",(0,r.jsx)(n.li,{children:"Nonce-based replay protection"}),"\n",(0,r.jsx)(n.li,{children:"mTLS between proxy and plugin"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-plugin-bypass",children:"3. Plugin Bypass"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Risk"}),": Attacker connects directly to plugin, bypassing proxy."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Mitigation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Network isolation (plugins only accessible from proxy)"}),"\n",(0,r.jsx)(n.li,{children:"Mutual TLS (plugin requires proxy certificate)"}),"\n",(0,r.jsx)(n.li,{children:"Firewall rules (block external access to plugin ports)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"4-policy-tampering",children:"4. Policy Tampering"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Risk"}),": Attacker modifies Topaz policies to grant unauthorized access."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Mitigation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Git-based policy versioning (audit trail)"}),"\n",(0,r.jsx)(n.li,{children:"CI/CD-only policy deployment (no manual changes)"}),"\n",(0,r.jsx)(n.li,{children:"Policy signing (verify integrity before loading)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,r.jsx)(n.h3,{id:"latency",children:"Latency"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Authorization overhead per request"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Token validation (cached JWKS): <1ms"}),"\n",(0,r.jsx)(n.li,{children:"Topaz policy check (local sidecar): <2ms"}),"\n",(0,r.jsx)(n.li,{children:"Audit logging (async): <0.1ms"}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Total overhead: <3ms P99"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Caching impact"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"With 5s decision cache: <1ms P99 (cache hit rate >90%)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"throughput",children:"Throughput"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Plugin throughput with authorization"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Without authz: 50,000 RPS"}),"\n",(0,r.jsx)(n.li,{children:"With authz (cached): 48,000 RPS (-4%)"}),"\n",(0,r.jsx)(n.li,{children:"With authz (uncached): 35,000 RPS (-30%)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Recommendation"}),": Enable decision caching (5s TTL) for production."]}),"\n",(0,r.jsx)(n.h2,{id:"migration-path",children:"Migration Path"}),"\n",(0,r.jsx)(n.h3,{id:"phase-1-sdk-implementation-week-1",children:"Phase 1: SDK Implementation (Week 1)"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Implement authz package in plugin SDK"}),"\n",(0,r.jsx)(n.li,{children:"Add token validator, Topaz client, audit logger"}),"\n",(0,r.jsx)(n.li,{children:"Create gRPC interceptors"}),"\n",(0,r.jsx)(n.li,{children:"Write unit tests"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"phase-2-reference-plugin-week-2",children:"Phase 2: Reference Plugin (Week 2)"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Integrate authz into Redis plugin"}),"\n",(0,r.jsx)(n.li,{children:"Test with local Topaz instance"}),"\n",(0,r.jsx)(n.li,{children:"Validate token validation and policy enforcement"}),"\n",(0,r.jsx)(n.li,{children:"Measure performance impact"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"phase-3-documentation-and-examples-week-3",children:"Phase 3: Documentation and Examples (Week 3)"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Write plugin integration guide"}),"\n",(0,r.jsx)(n.li,{children:"Create example plugins (Postgres, Kafka)"}),"\n",(0,r.jsx)(n.li,{children:"Document configuration options"}),"\n",(0,r.jsx)(n.li,{children:"Add troubleshooting guide"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"phase-4-rollout-week-4",children:"Phase 4: Rollout (Week 4)"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Enable authz in staging environment"}),"\n",(0,r.jsx)(n.li,{children:"Load test with authorization enabled"}),"\n",(0,r.jsx)(n.li,{children:"Gradual rollout to production plugins"}),"\n",(0,r.jsx)(n.li,{children:"Monitor authorization latency and errors"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"monitoring-and-observability",children:"Monitoring and Observability"}),"\n",(0,r.jsx)(n.h3,{id:"metrics",children:"Metrics"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Authorization Metrics"})," (per plugin):"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'plugin_authz_requests_total{decision="allowed|denied"}'})," - Total authz checks"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"plugin_authz_latency_seconds"})," - Authz check latency histogram"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"plugin_authz_errors_total"})," - Failed authz checks"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"plugin_authz_cache_hits_total"})," - Decision cache hits"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Token Validation Metrics"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'plugin_token_validations_total{result="success|failed"}'})," - Token validation results"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"plugin_token_validation_latency_seconds"})," - Token validation latency"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Topaz Query Metrics"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'plugin_topaz_queries_total{result="allowed|denied|error"}'})," - Topaz query results"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"plugin_topaz_query_latency_seconds"})," - Topaz query latency"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"logging",children:"Logging"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Authorization Audit Log"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "timestamp": "2025-10-09T15:45:23Z",\n  "level": "info",\n  "message": "authorization_decision",\n  "user": "alice@example.com",\n  "permission": "read",\n  "resource": "namespace:iot-devices",\n  "decision": "allowed",\n  "plugin": "redis-plugin",\n  "backend": "redis://localhost:6379",\n  "reason": "authorized in 1.2ms",\n  "token_claims": {\n    "sub": "alice@example.com",\n    "groups": ["platform-engineering"],\n    "exp": "2025-10-09T16:00:00Z"\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"alerts",children:"Alerts"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Authorization Failures"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Alert if plugin authz error rate > 1%"}),"\n",(0,r.jsx)(n.li,{children:"Alert if plugin authz latency P99 > 10ms"}),"\n",(0,r.jsx)(n.li,{children:"Alert if token validation failures > 5%"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Unusual Patterns"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Alert if denied requests spike (possible attack)"}),"\n",(0,r.jsx)(n.li,{children:"Alert if user accesses new resources (anomaly detection)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"open-questions",children:"Open Questions"}),"\n",(0,r.jsx)(n.h3,{id:"1-should-plugins-trust-proxy-token-validation",children:"1. Should Plugins Trust Proxy Token Validation?"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Question"}),": Can plugins skip token validation if proxy already validated?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Trade-offs"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Skip validation"}),": Faster (<1ms saved), but breaks defense-in-depth"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Validate again"}),": Slower, but more secure"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Recommendation"}),": ",(0,r.jsx)(n.strong,{children:"Always validate"})," (defense-in-depth). Optimize with token caching."]}),"\n",(0,r.jsx)(n.h3,{id:"2-how-to-handle-token-expiration-during-long-running-operations",children:"2. How to Handle Token Expiration During Long-Running Operations?"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Question"}),": What if token expires mid-operation (e.g., long scan)?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Options"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fail operation"}),": Secure but poor UX"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Allow completion"}),": Better UX but security risk"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Token refresh"}),": Complex but best of both"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Recommendation"}),": ",(0,r.jsx)(n.strong,{children:"Allow completion"})," if token was valid at operation start. Add TTL margin (e.g., 5 minutes)."]}),"\n",(0,r.jsx)(n.h3,{id:"3-should-audit-logs-include-request-payloads",children:"3. Should Audit Logs Include Request Payloads?"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Question"}),": Should we log request data (keys, values) in audit trail?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pros"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Complete audit trail (what data was accessed)"}),"\n",(0,r.jsx)(n.li,{children:"Forensic investigation support"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cons"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Privacy risk (PII in logs)"}),"\n",(0,r.jsx)(n.li,{children:"Large log volume"}),"\n",(0,r.jsx)(n.li,{children:"Performance impact"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Recommendation"}),": ",(0,r.jsx)(n.strong,{children:"Log metadata only"})," (namespace, operation, user). Add opt-in payload logging for high-security namespaces."]}),"\n",(0,r.jsx)(n.h2,{id:"related-documents",children:"Related Documents"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/adr/adr-050-topaz-policy-authorization",children:"ADR-050: Topaz for Policy Authorization"})," - Topaz selection and architecture"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/rfc/rfc-010-admin-protocol-oidc",children:"RFC-010: Admin Protocol with OIDC"})," - OIDC authentication"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/rfc/rfc-011-data-proxy-authentication",children:"RFC-011: Data Proxy Authentication"})," - Secrets provider abstraction"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/rfc/rfc-008-proxy-plugin-architecture",children:"RFC-008: Proxy Plugin Architecture"})," - Plugin system"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/rfc/rfc-022",children:"RFC-022: Core Pattern SDK Code Layout"})," - Pattern SDK structure"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'2025-10-11: Updated terminology from "Plugin SDK" to "Pattern SDK" for consistency with RFC-022'}),"\n",(0,r.jsx)(n.li,{children:"2025-10-09: Updated to reflect architectural decision: token validation and exchange pushed to patterns (not proxy) with Vault integration for per-session credentials"}),"\n",(0,r.jsx)(n.li,{children:"2025-10-09: Initial RFC proposing authorization layer in pattern SDK"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);