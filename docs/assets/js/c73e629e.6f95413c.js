"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[9348],{10808:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"memo-014","title":"Pattern SDK Shared Complexity Analysis","description":"Summary","source":"@site/../docs-cms/memos/MEMO-014-pattern-sdk-shared-complexity.md","sourceDirName":".","slug":"/memo-014","permalink":"/prism-data-layer/memos/memo-014","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/memos/MEMO-014-pattern-sdk-shared-complexity.md","tags":[{"inline":true,"label":"pattern-sdk","permalink":"/prism-data-layer/memos/tags/pattern-sdk"},{"inline":true,"label":"refactoring","permalink":"/prism-data-layer/memos/tags/refactoring"},{"inline":true,"label":"code-reuse","permalink":"/prism-data-layer/memos/tags/code-reuse"},{"inline":true,"label":"poc1","permalink":"/prism-data-layer/memos/tags/poc-1"}],"version":"current","frontMatter":{"author":"Platform Team","created":"2025-10-11T00:00:00.000Z","doc_uuid":"a643bb33-4294-4cd6-a688-57d8ba4b108d","id":"memo-014","project_id":"prism-data-layer","tags":["pattern-sdk","refactoring","code-reuse","poc1"],"title":"Pattern SDK Shared Complexity Analysis","updated":"2025-10-12T00:00:00.000Z"},"sidebar":"memosSidebar","previous":{"title":"POC 1 Infrastructure Analysis - SDK and Load Testing \u2022 MEMO-013","permalink":"/prism-data-layer/memos/memo-013"},"next":{"title":"Cross-Backend Acceptance Test Framework \u2022 MEMO-015","permalink":"/prism-data-layer/memos/memo-015"}}');var i=r(74848),s=r(28453);const l={author:"Platform Team",created:new Date("2025-10-11T00:00:00.000Z"),doc_uuid:"a643bb33-4294-4cd6-a688-57d8ba4b108d",id:"memo-014",project_id:"prism-data-layer",tags:["pattern-sdk","refactoring","code-reuse","poc1"],title:"Pattern SDK Shared Complexity Analysis",updated:new Date("2025-10-12T00:00:00.000Z")},c="MEMO-014: Pattern SDK Shared Complexity Analysis",a={},o=[{value:"Summary",id:"summary",level:2},{value:"Context",id:"context",level:2},{value:"Analysis",id:"analysis",level:2},{value:"Plugin Implementation Breakdown",id:"plugin-implementation-breakdown",level:3},{value:"Recommended SDK Enhancements",id:"recommended-sdk-enhancements",level:2},{value:"Priority 1: High-Impact, Low-Risk",id:"priority-1-high-impact-low-risk",level:3},{value:"1. Connection Pool Manager",id:"1-connection-pool-manager",level:4},{value:"2. TTL Management Library",id:"2-ttl-management-library",level:4},{value:"3. Backend Health Check Framework",id:"3-backend-health-check-framework",level:4},{value:"Priority 2: Medium-Impact",id:"priority-2-medium-impact",level:3},{value:"4. gRPC Service Registration Helpers",id:"4-grpc-service-registration-helpers",level:4},{value:"5. Configuration Management",id:"5-configuration-management",level:4},{value:"6. Error Classification and Circuit Breaker",id:"6-error-classification-and-circuit-breaker",level:4},{value:"Priority 3: Lower-Impact (Future Work)",id:"priority-3-lower-impact-future-work",level:3},{value:"7. Buffer and Batch Manager",id:"7-buffer-and-batch-manager",level:4},{value:"8. Testcontainer Helpers",id:"8-testcontainer-helpers",level:4},{value:"9. Metrics Collection",id:"9-metrics-collection",level:4},{value:"10. Concurrency Patterns (Worker Pools)",id:"10-concurrency-patterns-worker-pools",level:4},{value:"Implementation Plan",id:"implementation-plan",level:2},{value:"Phase 1: Foundation (Week 1)",id:"phase-1-foundation-week-1",level:3},{value:"Phase 2: Convenience (Week 1)",id:"phase-2-convenience-week-1",level:3},{value:"Phase 3: Plugin Refactoring (Week 2)",id:"phase-3-plugin-refactoring-week-2",level:3},{value:"Testing Strategy",id:"testing-strategy",level:2},{value:"Unit Tests",id:"unit-tests",level:3},{value:"Integration Tests",id:"integration-tests",level:3},{value:"Coverage Enforcement",id:"coverage-enforcement",level:3},{value:"Benefits",id:"benefits",level:2},{value:"Developer Experience",id:"developer-experience",level:3},{value:"Maintainability",id:"maintainability",level:3},{value:"Performance",id:"performance",level:3},{value:"Quality",id:"quality",level:3},{value:"Risks and Mitigations",id:"risks-and-mitigations",level:2},{value:"Risk 1: SDK Complexity",id:"risk-1-sdk-complexity",level:3},{value:"Risk 2: Breaking Changes",id:"risk-2-breaking-changes",level:3},{value:"Risk 3: Performance Regression",id:"risk-3-performance-regression",level:3},{value:"Risk 4: Over-Engineering",id:"risk-4-over-engineering",level:3},{value:"Alternatives Considered",id:"alternatives-considered",level:2},{value:"Alternative 1: Keep Custom Implementations",id:"alternative-1-keep-custom-implementations",level:3},{value:"Alternative 2: Third-Party Libraries",id:"alternative-2-third-party-libraries",level:3},{value:"Alternative 3: Code Generation",id:"alternative-3-code-generation",level:3},{value:"Success Metrics",id:"success-metrics",level:2},{value:"Next Steps",id:"next-steps",level:2},{value:"Related Documents",id:"related-documents",level:2},{value:"Revision History",id:"revision-history",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"memo-014-pattern-sdk-shared-complexity-analysis",children:"MEMO-014: Pattern SDK Shared Complexity Analysis"})}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"Analysis of RFC-021 reveals significant shared complexity across the three POC 1 plugins (MemStore, Redis, Kafka) that should be extracted into the Pattern SDK. This memo identifies 12 areas of duplication and proposes SDK enhancements to reduce plugin implementation burden by ~40%."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Finding"}),": Each plugin currently re-implements connection management, TTL handling, health checks, and concurrency patterns. Moving these to the SDK would reduce plugin code by an estimated 300-500 lines per plugin."]}),"\n",(0,i.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,i.jsx)(n.p,{children:"RFC-021 defines three minimal plugins for POC 1:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"MemStore"}),": In-memory storage with TTL support"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Redis"}),": External backend with connection pooling"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Kafka"}),": Streaming with async buffering"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Current Pattern SDK provides:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"auth/"})," - Authentication stub"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"observability/"})," - Structured logging"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"lifecycle/"})," - Startup/shutdown hooks"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"server/"})," - gRPC server setup"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"storage/"})," - Basic retry logic"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"analysis",children:"Analysis"}),"\n",(0,i.jsx)(n.h3,{id:"plugin-implementation-breakdown",children:"Plugin Implementation Breakdown"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Feature"}),(0,i.jsx)(n.th,{children:"MemStore"}),(0,i.jsx)(n.th,{children:"Redis"}),(0,i.jsx)(n.th,{children:"Kafka"}),(0,i.jsx)(n.th,{children:"SDK Support"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"TTL Management"}),(0,i.jsx)(n.td,{children:"\u2705 sync.Map + timers"}),(0,i.jsx)(n.td,{children:"\u2705 Redis EXPIRE"}),(0,i.jsx)(n.td,{children:"\u274c N/A"}),(0,i.jsx)(n.td,{children:"\u274c None"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Connection Pooling"}),(0,i.jsx)(n.td,{children:"\u274c N/A"}),(0,i.jsx)(n.td,{children:"\u2705 Custom pool"}),(0,i.jsx)(n.td,{children:"\u2705 Custom pool"}),(0,i.jsx)(n.td,{children:"\u274c None"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Health Checks"}),(0,i.jsx)(n.td,{children:"\u2705 Custom"}),(0,i.jsx)(n.td,{children:"\u2705 Custom"}),(0,i.jsx)(n.td,{children:"\u2705 Custom"}),(0,i.jsx)(n.td,{children:"\u274c None"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Retry Logic"}),(0,i.jsx)(n.td,{children:"\u274c N/A"}),(0,i.jsx)(n.td,{children:"\u2705 Custom"}),(0,i.jsx)(n.td,{children:"\u2705 Custom"}),(0,i.jsx)(n.td,{children:"\u2705 Basic only"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Error Handling"}),(0,i.jsx)(n.td,{children:"\u2705 Custom"}),(0,i.jsx)(n.td,{children:"\u2705 Custom"}),(0,i.jsx)(n.td,{children:"\u2705 Custom"}),(0,i.jsx)(n.td,{children:"\u274c None"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Async Buffering"}),(0,i.jsx)(n.td,{children:"\u274c N/A"}),(0,i.jsx)(n.td,{children:"\u274c N/A"}),(0,i.jsx)(n.td,{children:"\u2705 Custom"}),(0,i.jsx)(n.td,{children:"\u274c None"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"gRPC Registration"}),(0,i.jsx)(n.td,{children:"\u2705 Boilerplate"}),(0,i.jsx)(n.td,{children:"\u2705 Boilerplate"}),(0,i.jsx)(n.td,{children:"\u2705 Boilerplate"}),(0,i.jsx)(n.td,{children:"\u2705 Partial"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Config Loading"}),(0,i.jsx)(n.td,{children:"\u2705 Custom"}),(0,i.jsx)(n.td,{children:"\u2705 Custom"}),(0,i.jsx)(n.td,{children:"\u2705 Custom"}),(0,i.jsx)(n.td,{children:"\u274c None"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Metrics"}),(0,i.jsx)(n.td,{children:"\u2705 Manual"}),(0,i.jsx)(n.td,{children:"\u2705 Manual"}),(0,i.jsx)(n.td,{children:"\u2705 Manual"}),(0,i.jsx)(n.td,{children:"\u274c None"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Testcontainers"}),(0,i.jsx)(n.td,{children:"\u274c N/A"}),(0,i.jsx)(n.td,{children:"\u2705 Custom"}),(0,i.jsx)(n.td,{children:"\u2705 Custom"}),(0,i.jsx)(n.td,{children:"\u274c None"})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Finding"}),": 10 of 10 features have duplication across plugins."]}),"\n",(0,i.jsx)(n.h2,{id:"recommended-sdk-enhancements",children:"Recommended SDK Enhancements"}),"\n",(0,i.jsx)(n.h3,{id:"priority-1-high-impact-low-risk",children:"Priority 1: High-Impact, Low-Risk"}),"\n",(0,i.jsx)(n.h4,{id:"1-connection-pool-manager",children:"1. Connection Pool Manager"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Problem"}),": Redis and Kafka both need connection pools with health checking."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Current State"}),": Each plugin implements custom pooling."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Proposed SDK Package"}),": ",(0,i.jsx)(n.code,{children:"plugins/core/pool/"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// plugins/core/pool/pool.go\npackage pool\n\nimport (\n    "context"\n    "sync"\n    "time"\n)\n\n// Connection represents a generic backend connection\ntype Connection interface {\n    // Health checks if connection is healthy\n    Health(context.Context) error\n    // Close closes the connection\n    Close() error\n}\n\n// Factory creates new connections\ntype Factory func(context.Context) (Connection, error)\n\n// Config configures the connection pool\ntype Config struct {\n    MinIdle        int           // Minimum idle connections\n    MaxOpen        int           // Maximum open connections\n    MaxIdleTime    time.Duration // Max time connection can be idle\n    HealthInterval time.Duration // Health check interval\n}\n\n// Pool manages a pool of connections\ntype Pool struct {\n    factory Factory\n    config  Config\n\n    mu       sync.Mutex\n    conns    []Connection\n    idle     []Connection\n    health   map[Connection]time.Time\n}\n\n// NewPool creates a new connection pool\nfunc NewPool(factory Factory, config Config) *Pool {\n    p := &Pool{\n        factory: factory,\n        config:  config,\n        conns:   make([]Connection, 0),\n        idle:    make([]Connection, 0),\n        health:  make(map[Connection]time.Time),\n    }\n\n    go p.healthChecker()\n\n    return p\n}\n\n// Acquire gets a connection from the pool\nfunc (p *Pool) Acquire(ctx context.Context) (Connection, error) {\n    p.mu.Lock()\n    defer p.mu.Unlock()\n\n    // Try to reuse idle connection\n    if len(p.idle) > 0 {\n        conn := p.idle[len(p.idle)-1]\n        p.idle = p.idle[:len(p.idle)-1]\n        return conn, nil\n    }\n\n    // Create new connection if under max\n    if len(p.conns) < p.config.MaxOpen {\n        conn, err := p.factory(ctx)\n        if err != nil {\n            return nil, err\n        }\n        p.conns = append(p.conns, conn)\n        p.health[conn] = time.Now()\n        return conn, nil\n    }\n\n    // Wait for connection to become available\n    // (simplified - production would use channel)\n    return nil, ErrPoolExhausted\n}\n\n// Release returns a connection to the pool\nfunc (p *Pool) Release(conn Connection) {\n    p.mu.Lock()\n    defer p.mu.Unlock()\n\n    p.idle = append(p.idle, conn)\n}\n\n// Close closes all connections in the pool\nfunc (p *Pool) Close() error {\n    p.mu.Lock()\n    defer p.mu.Unlock()\n\n    for _, conn := range p.conns {\n        conn.Close()\n    }\n\n    p.conns = nil\n    p.idle = nil\n    p.health = nil\n\n    return nil\n}\n\nfunc (p *Pool) healthChecker() {\n    ticker := time.NewTicker(p.config.HealthInterval)\n    defer ticker.Stop()\n\n    for range ticker.C {\n        p.checkHealth()\n    }\n}\n\nfunc (p *Pool) checkHealth() {\n    p.mu.Lock()\n    defer p.mu.Unlock()\n\n    ctx := context.Background()\n    healthy := make([]Connection, 0, len(p.conns))\n\n    for _, conn := range p.conns {\n        if err := conn.Health(ctx); err == nil {\n            healthy = append(healthy, conn)\n            p.health[conn] = time.Now()\n        } else {\n            // Remove unhealthy connection\n            conn.Close()\n            delete(p.health, conn)\n        }\n    }\n\n    p.conns = healthy\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Usage in Redis Plugin"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// plugins/redis/client/pool.go\npackage client\n\nimport (\n    "context"\n    "github.com/prism/plugins/core/pool"\n    "github.com/redis/go-redis/v9"\n)\n\ntype RedisConnection struct {\n    client *redis.Client\n}\n\nfunc (rc *RedisConnection) Health(ctx context.Context) error {\n    return rc.client.Ping(ctx).Err()\n}\n\nfunc (rc *RedisConnection) Close() error {\n    return rc.client.Close()\n}\n\nfunc NewRedisPool(addr string) (*pool.Pool, error) {\n    factory := func(ctx context.Context) (pool.Connection, error) {\n        client := redis.NewClient(&redis.Options{\n            Addr: addr,\n        })\n        return &RedisConnection{client: client}, nil\n    }\n\n    config := pool.Config{\n        MinIdle:        5,\n        MaxOpen:        50,\n        MaxIdleTime:    5 * time.Minute,\n        HealthInterval: 30 * time.Second,\n    }\n\n    return pool.NewPool(factory, config), nil\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Impact"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Reduces Redis plugin code by ~150 lines"}),"\n",(0,i.jsx)(n.li,{children:"Reduces Kafka plugin code by ~120 lines"}),"\n",(0,i.jsx)(n.li,{children:"Standardizes connection management across all plugins"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Test Coverage Target"}),": 90%+ (critical infrastructure)"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h4,{id:"2-ttl-management-library",children:"2. TTL Management Library"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Problem"}),": MemStore implements per-key timers; Redis uses EXPIRE. Both need TTL support."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Current State"}),": MemStore uses ",(0,i.jsx)(n.code,{children:"sync.Map"})," + ",(0,i.jsx)(n.code,{children:"time.AfterFunc"})," per key (inefficient for many keys)."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Proposed SDK Package"}),": ",(0,i.jsx)(n.code,{children:"plugins/core/ttl/"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// plugins/core/ttl/manager.go\npackage ttl\n\nimport (\n    "container/heap"\n    "sync"\n    "time"\n)\n\n// ExpiryCallback is called when a key expires\ntype ExpiryCallback func(key string)\n\n// Manager manages TTLs for keys efficiently\ntype Manager struct {\n    mu       sync.Mutex\n    expiries *expiryHeap\n    index    map[string]*expiryItem\n    callback ExpiryCallback\n    stopCh   chan struct{}\n}\n\ntype expiryItem struct {\n    key       string\n    expiresAt time.Time\n    index     int\n}\n\ntype expiryHeap []*expiryItem\n\n// Standard heap interface implementation\nfunc (h expiryHeap) Len() int           { return len(h) }\nfunc (h expiryHeap) Less(i, j int) bool { return h[i].expiresAt.Before(h[j].expiresAt) }\nfunc (h expiryHeap) Swap(i, j int) {\n    h[i], h[j] = h[j], h[i]\n    h[i].index = i\n    h[j].index = j\n}\n\nfunc (h *expiryHeap) Push(x interface{}) {\n    item := x.(*expiryItem)\n    item.index = len(*h)\n    *h = append(*h, item)\n}\n\nfunc (h *expiryHeap) Pop() interface{} {\n    old := *h\n    n := len(old)\n    item := old[n-1]\n    item.index = -1\n    *h = old[0 : n-1]\n    return item\n}\n\n// NewManager creates a new TTL manager\nfunc NewManager(callback ExpiryCallback) *Manager {\n    m := &Manager{\n        expiries: &expiryHeap{},\n        index:    make(map[string]*expiryItem),\n        callback: callback,\n        stopCh:   make(chan struct{}),\n    }\n    heap.Init(m.expiries)\n    go m.expiryWorker()\n    return m\n}\n\n// Set sets a TTL for a key\nfunc (m *Manager) Set(key string, ttl time.Duration) {\n    m.mu.Lock()\n    defer m.mu.Unlock()\n\n    expiresAt := time.Now().Add(ttl)\n\n    // Update existing entry\n    if item, exists := m.index[key]; exists {\n        item.expiresAt = expiresAt\n        heap.Fix(m.expiries, item.index)\n        return\n    }\n\n    // Create new entry\n    item := &expiryItem{\n        key:       key,\n        expiresAt: expiresAt,\n    }\n    heap.Push(m.expiries, item)\n    m.index[key] = item\n}\n\n// Remove removes a key from TTL tracking\nfunc (m *Manager) Remove(key string) {\n    m.mu.Lock()\n    defer m.mu.Unlock()\n\n    if item, exists := m.index[key]; exists {\n        heap.Remove(m.expiries, item.index)\n        delete(m.index, key)\n    }\n}\n\n// Persist removes TTL for a key (makes it permanent)\nfunc (m *Manager) Persist(key string) {\n    m.Remove(key)\n}\n\n// GetTTL returns remaining TTL for a key\nfunc (m *Manager) GetTTL(key string) (time.Duration, bool) {\n    m.mu.Lock()\n    defer m.mu.Unlock()\n\n    if item, exists := m.index[key]; exists {\n        remaining := time.Until(item.expiresAt)\n        if remaining < 0 {\n            return 0, false\n        }\n        return remaining, true\n    }\n\n    return 0, false\n}\n\n// Close stops the TTL manager\nfunc (m *Manager) Close() {\n    close(m.stopCh)\n}\n\nfunc (m *Manager) expiryWorker() {\n    ticker := time.NewTicker(100 * time.Millisecond)\n    defer ticker.Stop()\n\n    for {\n        select {\n        case <-m.stopCh:\n            return\n        case <-ticker.C:\n            m.processExpiries()\n        }\n    }\n}\n\nfunc (m *Manager) processExpiries() {\n    m.mu.Lock()\n    defer m.mu.Unlock()\n\n    now := time.Now()\n\n    for m.expiries.Len() > 0 {\n        item := (*m.expiries)[0]\n\n        // Stop if next item not expired yet\n        if item.expiresAt.After(now) {\n            break\n        }\n\n        // Remove expired item\n        heap.Pop(m.expiries)\n        delete(m.index, item.key)\n\n        // Call expiry callback\n        if m.callback != nil {\n            go m.callback(item.key) // Async to avoid blocking\n        }\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Usage in MemStore Plugin"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// plugins/memstore/storage/keyvalue.go\npackage storage\n\nimport (\n    "github.com/prism/plugins/core/ttl"\n    "sync"\n)\n\ntype KeyValueStore struct {\n    data    sync.Map\n    ttlMgr  *ttl.Manager\n}\n\nfunc NewKeyValueStore() *KeyValueStore {\n    kv := &KeyValueStore{}\n\n    // TTL callback deletes expired keys\n    kv.ttlMgr = ttl.NewManager(func(key string) {\n        kv.data.Delete(key)\n    })\n\n    return kv\n}\n\nfunc (kv *KeyValueStore) Set(key string, value []byte, ttlSeconds int64) error {\n    kv.data.Store(key, value)\n\n    if ttlSeconds > 0 {\n        kv.ttlMgr.Set(key, time.Duration(ttlSeconds)*time.Second)\n    }\n\n    return nil\n}\n\nfunc (kv *KeyValueStore) Expire(key string, ttlSeconds int64) bool {\n    if _, exists := kv.data.Load(key); !exists {\n        return false\n    }\n\n    kv.ttlMgr.Set(key, time.Duration(ttlSeconds)*time.Second)\n    return true\n}\n\nfunc (kv *KeyValueStore) GetTTL(key string) (int64, bool) {\n    ttl, exists := kv.ttlMgr.GetTTL(key)\n    if !exists {\n        return -1, false\n    }\n    return int64(ttl.Seconds()), true\n}\n\nfunc (kv *KeyValueStore) Persist(key string) bool {\n    if _, exists := kv.data.Load(key); !exists {\n        return false\n    }\n\n    kv.ttlMgr.Persist(key)\n    return true\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Impact"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Reduces MemStore plugin code by ~80 lines"}),"\n",(0,i.jsx)(n.li,{children:"More efficient: O(log n) heap vs O(1) per-key timers"}),"\n",(0,i.jsx)(n.li,{children:"Scales to 100K+ keys with TTLs"}),"\n",(0,i.jsx)(n.li,{children:"Single goroutine for all expirations"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Test Coverage Target"}),": 95%+ (data structure complexity)"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h4,{id:"3-backend-health-check-framework",children:"3. Backend Health Check Framework"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Problem"}),": All three plugins implement custom health checks."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Current State"}),": Each plugin has custom health check logic."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Proposed SDK Package"}),": ",(0,i.jsx)(n.code,{children:"plugins/core/health/"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// plugins/core/health/checker.go\npackage health\n\nimport (\n    "context"\n    "sync"\n    "time"\n)\n\n// Status represents health status\ntype Status int\n\nconst (\n    StatusUnknown Status = iota\n    StatusHealthy\n    StatusDegraded\n    StatusUnhealthy\n)\n\nfunc (s Status) String() string {\n    switch s {\n    case StatusHealthy:\n        return "healthy"\n    case StatusDegraded:\n        return "degraded"\n    case StatusUnhealthy:\n        return "unhealthy"\n    default:\n        return "unknown"\n    }\n}\n\n// Check performs a health check\ntype Check func(context.Context) error\n\n// Checker manages multiple health checks\ntype Checker struct {\n    mu      sync.RWMutex\n    checks  map[string]Check\n    status  map[string]Status\n    errors  map[string]error\n\n    interval time.Duration\n    timeout  time.Duration\n    stopCh   chan struct{}\n}\n\n// Config configures health checking\ntype Config struct {\n    Interval time.Duration // How often to run checks\n    Timeout  time.Duration // Timeout per check\n}\n\n// NewChecker creates a new health checker\nfunc NewChecker(config Config) *Checker {\n    c := &Checker{\n        checks:   make(map[string]Check),\n        status:   make(map[string]Status),\n        errors:   make(map[string]error),\n        interval: config.Interval,\n        timeout:  config.Timeout,\n        stopCh:   make(chan struct{}),\n    }\n\n    go c.worker()\n\n    return c\n}\n\n// Register adds a health check\nfunc (c *Checker) Register(name string, check Check) {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n\n    c.checks[name] = check\n    c.status[name] = StatusUnknown\n}\n\n// Status returns overall health status\nfunc (c *Checker) Status() Status {\n    c.mu.RLock()\n    defer c.mu.RUnlock()\n\n    hasUnhealthy := false\n    hasDegraded := false\n\n    for _, status := range c.status {\n        switch status {\n        case StatusUnhealthy:\n            hasUnhealthy = true\n        case StatusDegraded:\n            hasDegraded = true\n        }\n    }\n\n    if hasUnhealthy {\n        return StatusUnhealthy\n    }\n    if hasDegraded {\n        return StatusDegraded\n    }\n\n    return StatusHealthy\n}\n\n// CheckStatus returns status for a specific check\nfunc (c *Checker) CheckStatus(name string) (Status, error) {\n    c.mu.RLock()\n    defer c.mu.RUnlock()\n\n    return c.status[name], c.errors[name]\n}\n\n// Close stops the health checker\nfunc (c *Checker) Close() {\n    close(c.stopCh)\n}\n\nfunc (c *Checker) worker() {\n    ticker := time.NewTicker(c.interval)\n    defer ticker.Stop()\n\n    for {\n        select {\n        case <-c.stopCh:\n            return\n        case <-ticker.C:\n            c.runChecks()\n        }\n    }\n}\n\nfunc (c *Checker) runChecks() {\n    c.mu.RLock()\n    checks := make(map[string]Check, len(c.checks))\n    for name, check := range c.checks {\n        checks[name] = check\n    }\n    c.mu.RUnlock()\n\n    for name, check := range checks {\n        ctx, cancel := context.WithTimeout(context.Background(), c.timeout)\n        err := check(ctx)\n        cancel()\n\n        status := StatusHealthy\n        if err != nil {\n            status = StatusUnhealthy\n        }\n\n        c.mu.Lock()\n        c.status[name] = status\n        c.errors[name] = err\n        c.mu.Unlock()\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Usage in Redis Plugin"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// plugins/redis/main.go\npackage main\n\nimport (\n    "context"\n    "github.com/prism/plugins/core/health"\n)\n\nfunc setupHealth(client *redis.Client) *health.Checker {\n    checker := health.NewChecker(health.Config{\n        Interval: 30 * time.Second,\n        Timeout:  5 * time.Second,\n    })\n\n    // Register Redis connectivity check\n    checker.Register("redis", func(ctx context.Context) error {\n        return client.Ping(ctx).Err()\n    })\n\n    // Register memory check\n    checker.Register("memory", func(ctx context.Context) error {\n        info := client.Info(ctx, "memory").Val()\n        // Parse memory usage and return error if > 90%\n        return nil\n    })\n\n    return checker\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Impact"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Reduces all plugins by ~50 lines each"}),"\n",(0,i.jsx)(n.li,{children:"Standardizes health check reporting"}),"\n",(0,i.jsx)(n.li,{children:"Enables composite health status"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Test Coverage Target"}),": 90%+"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"priority-2-medium-impact",children:"Priority 2: Medium-Impact"}),"\n",(0,i.jsx)(n.h4,{id:"4-grpc-service-registration-helpers",children:"4. gRPC Service Registration Helpers"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Problem"}),": All plugins have boilerplate gRPC service registration."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Current State"}),": ",(0,i.jsx)(n.code,{children:"plugins/core/server/grpc.go"})," exists but incomplete."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Enhancement"}),": Add middleware and registration helpers."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// plugins/core/server/middleware.go\npackage server\n\nimport (\n    "context"\n    "time"\n\n    "go.uber.org/zap"\n    "google.golang.org/grpc"\n)\n\n// LoggingInterceptor logs all gRPC requests\nfunc LoggingInterceptor(logger *zap.Logger) grpc.UnaryServerInterceptor {\n    return func(\n        ctx context.Context,\n        req interface{},\n        info *grpc.UnaryServerInfo,\n        handler grpc.UnaryHandler,\n    ) (interface{}, error) {\n        start := time.Now()\n\n        logger.Info("request started",\n            zap.String("method", info.FullMethod),\n        )\n\n        resp, err := handler(ctx, req)\n\n        duration := time.Since(start)\n\n        if err != nil {\n            logger.Error("request failed",\n                zap.String("method", info.FullMethod),\n                zap.Duration("duration", duration),\n                zap.Error(err),\n            )\n        } else {\n            logger.Info("request completed",\n                zap.String("method", info.FullMethod),\n                zap.Duration("duration", duration),\n            )\n        }\n\n        return resp, err\n    }\n}\n\n// ErrorInterceptor standardizes error responses\nfunc ErrorInterceptor() grpc.UnaryServerInterceptor {\n    return func(\n        ctx context.Context,\n        req interface{},\n        info *grpc.UnaryServerInfo,\n        handler grpc.UnaryHandler,\n    ) (interface{}, error) {\n        resp, err := handler(ctx, req)\n\n        if err != nil {\n            // Convert internal errors to gRPC status codes\n            return nil, toGRPCError(err)\n        }\n\n        return resp, nil\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Impact"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Reduces all plugins by ~30 lines each"}),"\n",(0,i.jsx)(n.li,{children:"Standardizes logging format"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Test Coverage Target"}),": 85%+"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h4,{id:"5-configuration-management",children:"5. Configuration Management"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Problem"}),": All plugins load config from environment variables with custom parsing."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Proposed SDK Package"}),": ",(0,i.jsx)(n.code,{children:"plugins/core/config/"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// plugins/core/config/loader.go\npackage config\n\nimport (\n    "fmt"\n    "os"\n    "strconv"\n    "time"\n)\n\n// Loader loads configuration from environment\ntype Loader struct {\n    prefix string\n}\n\n// NewLoader creates a config loader with prefix\nfunc NewLoader(prefix string) *Loader {\n    return &Loader{prefix: prefix}\n}\n\n// String loads a string value\nfunc (l *Loader) String(key, defaultVal string) string {\n    envKey := l.prefix + "_" + key\n    if val := os.Getenv(envKey); val != "" {\n        return val\n    }\n    return defaultVal\n}\n\n// Int loads an int value\nfunc (l *Loader) Int(key string, defaultVal int) int {\n    envKey := l.prefix + "_" + key\n    if val := os.Getenv(envKey); val != "" {\n        if i, err := strconv.Atoi(val); err == nil {\n            return i\n        }\n    }\n    return defaultVal\n}\n\n// Duration loads a duration value\nfunc (l *Loader) Duration(key string, defaultVal time.Duration) time.Duration {\n    envKey := l.prefix + "_" + key\n    if val := os.Getenv(envKey); val != "" {\n        if d, err := time.ParseDuration(val); err == nil {\n            return d\n        }\n    }\n    return defaultVal\n}\n\n// Required loads a required string value (panics if missing)\nfunc (l *Loader) Required(key string) string {\n    envKey := l.prefix + "_" + key\n    val := os.Getenv(envKey)\n    if val == "" {\n        panic(fmt.Sprintf("required config %s not set", envKey))\n    }\n    return val\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Usage"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// plugins/redis/main.go\nfunc loadConfig() RedisConfig {\n    cfg := config.NewLoader("REDIS")\n\n    return RedisConfig{\n        Addr:        cfg.Required("ADDR"),\n        MaxRetries:  cfg.Int("MAX_RETRIES", 3),\n        PoolSize:    cfg.Int("POOL_SIZE", 10),\n        IdleTimeout: cfg.Duration("IDLE_TIMEOUT", 5*time.Minute),\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Impact"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Reduces all plugins by ~20 lines each"}),"\n",(0,i.jsx)(n.li,{children:"Type-safe config loading"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Test Coverage Target"}),": 95%+"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h4,{id:"6-error-classification-and-circuit-breaker",children:"6. Error Classification and Circuit Breaker"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Problem"}),": Redis and Kafka need sophisticated retry logic beyond basic backoff."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Enhancement to"}),": ",(0,i.jsx)(n.code,{children:"plugins/core/storage/retry.go"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// plugins/core/storage/errors.go\npackage storage\n\nimport "errors"\n\n// Error types for classification\nvar (\n    ErrRetryable   = errors.New("retryable error")\n    ErrPermanent   = errors.New("permanent error")\n    ErrTimeout     = errors.New("timeout")\n    ErrRateLimit   = errors.New("rate limited")\n)\n\n// Classify determines if an error is retryable\nfunc Classify(err error) error {\n    if err == nil {\n        return nil\n    }\n\n    // Check for known retryable errors\n    switch {\n    case errors.Is(err, ErrTimeout):\n        return ErrRetryable\n    case errors.Is(err, ErrRateLimit):\n        return ErrRetryable\n    default:\n        return ErrPermanent\n    }\n}\n\n// CircuitBreaker prevents cascading failures\ntype CircuitBreaker struct {\n    maxFailures int\n    timeout     time.Duration\n\n    mu           sync.Mutex\n    failures     int\n    lastFailure  time.Time\n    state        CircuitState\n}\n\ntype CircuitState int\n\nconst (\n    StateClosed CircuitState = iota\n    StateOpen\n    StateHalfOpen\n)\n\nfunc NewCircuitBreaker(maxFailures int, timeout time.Duration) *CircuitBreaker {\n    return &CircuitBreaker{\n        maxFailures: maxFailures,\n        timeout:     timeout,\n        state:       StateClosed,\n    }\n}\n\nfunc (cb *CircuitBreaker) Call(fn func() error) error {\n    if !cb.canProceed() {\n        return errors.New("circuit breaker open")\n    }\n\n    err := fn()\n    cb.recordResult(err)\n\n    return err\n}\n\nfunc (cb *CircuitBreaker) canProceed() bool {\n    cb.mu.Lock()\n    defer cb.mu.Unlock()\n\n    switch cb.state {\n    case StateClosed:\n        return true\n    case StateOpen:\n        // Check if timeout elapsed\n        if time.Since(cb.lastFailure) > cb.timeout {\n            cb.state = StateHalfOpen\n            return true\n        }\n        return false\n    case StateHalfOpen:\n        return true\n    default:\n        return false\n    }\n}\n\nfunc (cb *CircuitBreaker) recordResult(err error) {\n    cb.mu.Lock()\n    defer cb.mu.Unlock()\n\n    if err != nil {\n        cb.failures++\n        cb.lastFailure = time.Now()\n\n        if cb.failures >= cb.maxFailures {\n            cb.state = StateOpen\n        }\n    } else {\n        cb.failures = 0\n        cb.state = StateClosed\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Impact"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Prevents cascading failures in Redis/Kafka"}),"\n",(0,i.jsx)(n.li,{children:"Standardizes error handling"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Test Coverage Target"}),": 90%+"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"priority-3-lower-impact-future-work",children:"Priority 3: Lower-Impact (Future Work)"}),"\n",(0,i.jsx)(n.h4,{id:"7-buffer-and-batch-manager",children:"7. Buffer and Batch Manager"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Case"}),": Kafka async buffering"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Status"}),": Defer to POC 2 (too specific to Kafka for POC 1)"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h4,{id:"8-testcontainer-helpers",children:"8. Testcontainer Helpers"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Case"}),": Redis and Kafka integration tests"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Status"}),": Defer to POC 2 (testcontainers already easy to use)"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h4,{id:"9-metrics-collection",children:"9. Metrics Collection"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Case"}),": All plugins need request duration tracking"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Status"}),": Defer to POC 3 (observability POC)"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h4,{id:"10-concurrency-patterns-worker-pools",children:"10. Concurrency Patterns (Worker Pools)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Case"}),": All plugins handle concurrent requests"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Status"}),": Defer (gRPC handles concurrency already)"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"implementation-plan",children:"Implementation Plan"}),"\n",(0,i.jsx)(n.h3,{id:"phase-1-foundation-week-1",children:"Phase 1: Foundation (Week 1)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Estimated Effort"}),": 3 days"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Package"}),(0,i.jsx)(n.th,{children:"Lines"}),(0,i.jsx)(n.th,{children:"Tests"}),(0,i.jsx)(n.th,{children:"Coverage Target"}),(0,i.jsx)(n.th,{children:"Owner"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"pool/"})}),(0,i.jsx)(n.td,{children:"~300"}),(0,i.jsx)(n.td,{children:"~200"}),(0,i.jsx)(n.td,{children:"90%+"}),(0,i.jsx)(n.td,{children:"Go Expert"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ttl/"})}),(0,i.jsx)(n.td,{children:"~250"}),(0,i.jsx)(n.td,{children:"~150"}),(0,i.jsx)(n.td,{children:"95%+"}),(0,i.jsx)(n.td,{children:"Go Expert"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"health/"})}),(0,i.jsx)(n.td,{children:"~200"}),(0,i.jsx)(n.td,{children:"~100"}),(0,i.jsx)(n.td,{children:"90%+"}),(0,i.jsx)(n.td,{children:"Go Expert"})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Deliverables"}),":"]}),"\n",(0,i.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," Connection pool manager with health checking"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," TTL manager with heap-based expiration"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," Health check framework"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," All tests passing with coverage targets met"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," Documentation with usage examples"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"phase-2-convenience-week-1",children:"Phase 2: Convenience (Week 1)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Estimated Effort"}),": 2 days"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Package"}),(0,i.jsx)(n.th,{children:"Lines"}),(0,i.jsx)(n.th,{children:"Tests"}),(0,i.jsx)(n.th,{children:"Coverage Target"}),(0,i.jsx)(n.th,{children:"Owner"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"server/middleware.go"})}),(0,i.jsx)(n.td,{children:"~150"}),(0,i.jsx)(n.td,{children:"~80"}),(0,i.jsx)(n.td,{children:"85%+"}),(0,i.jsx)(n.td,{children:"Any Engineer"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"config/"})}),(0,i.jsx)(n.td,{children:"~100"}),(0,i.jsx)(n.td,{children:"~60"}),(0,i.jsx)(n.td,{children:"95%+"}),(0,i.jsx)(n.td,{children:"Any Engineer"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"storage/errors.go"})}),(0,i.jsx)(n.td,{children:"~200"}),(0,i.jsx)(n.td,{children:"~100"}),(0,i.jsx)(n.td,{children:"90%+"}),(0,i.jsx)(n.td,{children:"Go Expert"})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Deliverables"}),":"]}),"\n",(0,i.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," gRPC middleware (logging, error standardization)"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," Configuration loader"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," Error classification and circuit breaker"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," All tests passing with coverage targets met"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"phase-3-plugin-refactoring-week-2",children:"Phase 3: Plugin Refactoring (Week 2)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Estimated Effort"}),": 2 days"]}),"\n",(0,i.jsx)(n.p,{children:"Refactor existing plugins to use new SDK packages:"}),"\n",(0,i.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," MemStore: Use ",(0,i.jsx)(n.code,{children:"ttl.Manager"})," instead of per-key timers"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," Redis: Use ",(0,i.jsx)(n.code,{children:"pool.Pool"})," for connection management"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," Kafka: Use ",(0,i.jsx)(n.code,{children:"pool.Pool"})," for connection management"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," All plugins: Use ",(0,i.jsx)(n.code,{children:"health.Checker"})," for health checks"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," All plugins: Use ",(0,i.jsx)(n.code,{children:"config.Loader"})," for configuration"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," Verify all tests still pass"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," Measure code reduction"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Expected Code Reduction"}),":"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Plugin"}),(0,i.jsx)(n.th,{children:"Before (LOC)"}),(0,i.jsx)(n.th,{children:"After (LOC)"}),(0,i.jsx)(n.th,{children:"Reduction"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"MemStore"}),(0,i.jsx)(n.td,{children:"~600"}),(0,i.jsx)(n.td,{children:"~350"}),(0,i.jsx)(n.td,{children:"~42%"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Redis"}),(0,i.jsx)(n.td,{children:"~700"}),(0,i.jsx)(n.td,{children:"~450"}),(0,i.jsx)(n.td,{children:"~36%"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Kafka"}),(0,i.jsx)(n.td,{children:"~800"}),(0,i.jsx)(n.td,{children:"~500"}),(0,i.jsx)(n.td,{children:"~38%"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Total"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"2100"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"1300"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"38%"})})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"testing-strategy",children:"Testing Strategy"}),"\n",(0,i.jsx)(n.h3,{id:"unit-tests",children:"Unit Tests"}),"\n",(0,i.jsx)(n.p,{children:"Each SDK package must have comprehensive unit tests:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// plugins/core/pool/pool_test.go\nfunc TestPool_AcquireRelease(t *testing.T) { /* ... */ }\nfunc TestPool_HealthChecking(t *testing.T) { /* ... */ }\nfunc TestPool_MaxConnections(t *testing.T) { /* ... */ }\nfunc TestPool_ConcurrentAccess(t *testing.T) { /* ... */ }\n"})}),"\n",(0,i.jsx)(n.h3,{id:"integration-tests",children:"Integration Tests"}),"\n",(0,i.jsx)(n.p,{children:"Plugins using SDK packages must have integration tests:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// plugins/redis/client/pool_test.go\nfunc TestRedisPool_WithRealRedis(t *testing.T) {\n    // Use testcontainer\n    redis := startRedisContainer(t)\n    defer redis.Terminate()\n\n    pool := NewRedisPool(redis.Endpoint())\n    defer pool.Close()\n\n    // Test pool functionality\n    conn, err := pool.Acquire(context.Background())\n    // ...\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"coverage-enforcement",children:"Coverage Enforcement"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-makefile",children:'# Makefile (root)\ncoverage-sdk:\n\t@echo "=== Connection Pool ==="\n\tcd plugins/core/pool && go test -coverprofile=coverage.out ./...\n\t@cd plugins/core/pool && go tool cover -func=coverage.out | grep total\n\n\t@echo "=== TTL Manager ==="\n\tcd plugins/core/ttl && go test -coverprofile=coverage.out ./...\n\t@cd plugins/core/ttl && go tool cover -func=coverage.out | grep total\n\n\t@echo "=== Health Checker ==="\n\tcd plugins/core/health && go test -coverprofile=coverage.out ./...\n\t@cd plugins/core/health && go tool cover -func=coverage.out | grep total\n\n# Fail if any SDK package < 85%\ncoverage-sdk-enforce:\n\t@for pkg in pool ttl health; do \\\n\t\tcd plugins/core/$$pkg && \\\n\t\tCOVERAGE=$$(go test -coverprofile=coverage.out ./... && \\\n\t\t\tgo tool cover -func=coverage.out | grep total | awk \'{print $$3}\' | sed \'s/%//\'); \\\n\t\tif (( $$(echo "$$COVERAGE < 85" | bc -l) )); then \\\n\t\t\techo "\u274c SDK package $$pkg coverage $$COVERAGE% < 85%"; \\\n\t\t\texit 1; \\\n\t\tfi; \\\n\t\techo "\u2705 SDK package $$pkg coverage $$COVERAGE% >= 85%"; \\\n\tdone\n'})}),"\n",(0,i.jsx)(n.h2,{id:"benefits",children:"Benefits"}),"\n",(0,i.jsx)(n.h3,{id:"developer-experience",children:"Developer Experience"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Before"})," (without SDK enhancements):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// plugins/redis/client/pool.go - ~150 lines of custom pooling\n// plugins/redis/client/health.go - ~50 lines of custom health checks\n// plugins/redis/client/config.go - ~40 lines of custom config loading\n// Total: ~240 lines of boilerplate per plugin\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"After"})," (with SDK enhancements):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// plugins/redis/main.go - ~30 lines using SDK packages\npool := pool.NewPool(factory, poolConfig)\nhealth := health.NewChecker(healthConfig)\nconfig := config.NewLoader("REDIS")\n// Total: ~30 lines, 88% reduction\n'})}),"\n",(0,i.jsx)(n.h3,{id:"maintainability",children:"Maintainability"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Single source of truth"}),": Connection pooling logic in one place"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consistent behavior"}),": All plugins handle health checks the same way"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Easier debugging"}),": Centralized logging in SDK middleware"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Faster development"}),": New plugins can use SDK packages immediately"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"performance",children:"Performance"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"TTL Manager"}),": Heap-based expiration scales to 100K+ keys (vs per-key timers)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Connection Pool"}),": Reuses connections efficiently"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Health Checks"}),": Amortized across all plugins"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"quality",children:"Quality"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Higher test coverage"}),": SDK packages have 85-95% coverage"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fewer bugs"}),": Less duplicated code = fewer places for bugs"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Standardization"}),": All plugins follow same patterns"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"risks-and-mitigations",children:"Risks and Mitigations"}),"\n",(0,i.jsx)(n.h3,{id:"risk-1-sdk-complexity",children:"Risk 1: SDK Complexity"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Risk"}),": SDK becomes too complex and hard to understand."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Mitigation"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Keep SDK packages focused (single responsibility)"}),"\n",(0,i.jsx)(n.li,{children:"Comprehensive documentation with examples"}),"\n",(0,i.jsx)(n.li,{children:"Code reviews for all SDK changes"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"risk-2-breaking-changes",children:"Risk 2: Breaking Changes"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Risk"}),": SDK changes break existing plugins."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Mitigation"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Semantic versioning for SDK"}),"\n",(0,i.jsx)(n.li,{children:"Deprecation warnings before breaking changes"}),"\n",(0,i.jsx)(n.li,{children:"Integration tests catch breakage"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"risk-3-performance-regression",children:"Risk 3: Performance Regression"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Risk"}),": Generic SDK code slower than custom implementations."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Mitigation"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Benchmark all SDK packages"}),"\n",(0,i.jsx)(n.li,{children:"Compare against custom implementations"}),"\n",(0,i.jsx)(n.li,{children:"Profile in production"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"risk-4-over-engineering",children:"Risk 4: Over-Engineering"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Risk"}),": Building SDK features that aren't needed."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Mitigation"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Only extract patterns used by 2+ plugins"}),"\n",(0,i.jsx)(n.li,{children:'Defer "nice to have" features'}),"\n",(0,i.jsx)(n.li,{children:"Iterative approach (Phase 1 \u2192 2 \u2192 3)"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,i.jsx)(n.h3,{id:"alternative-1-keep-custom-implementations",children:"Alternative 1: Keep Custom Implementations"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pros"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Plugins can optimize for their specific use case"}),"\n",(0,i.jsx)(n.li,{children:"No SDK learning curve"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Cons"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Code duplication (38% more code)"}),"\n",(0,i.jsx)(n.li,{children:"Inconsistent behavior across plugins"}),"\n",(0,i.jsx)(n.li,{children:"Higher maintenance burden"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Decision"}),": Rejected - duplication outweighs benefits"]}),"\n",(0,i.jsx)(n.h3,{id:"alternative-2-third-party-libraries",children:"Alternative 2: Third-Party Libraries"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pros"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Battle-tested implementations"}),"\n",(0,i.jsx)(n.li,{children:"Active maintenance"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Cons"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"External dependencies"}),"\n",(0,i.jsx)(n.li,{children:"Less control over behavior"}),"\n",(0,i.jsx)(n.li,{children:"May not fit our use cases"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Decision"}),": Partial adoption - use zap for logging, but build custom pool/ttl/health"]}),"\n",(0,i.jsx)(n.h3,{id:"alternative-3-code-generation",children:"Alternative 3: Code Generation"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pros"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Zero runtime overhead"}),"\n",(0,i.jsx)(n.li,{children:"Type-safe"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Cons"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Complex build process"}),"\n",(0,i.jsx)(n.li,{children:"Harder to debug generated code"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Decision"}),": Deferred to future (POC 5+)"]}),"\n",(0,i.jsx)(n.h2,{id:"success-metrics",children:"Success Metrics"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Metric"}),(0,i.jsx)(n.th,{children:"Target"}),(0,i.jsx)(n.th,{children:"Measurement"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Code reduction"}),(0,i.jsx)(n.td,{children:"35%+"}),(0,i.jsx)(n.td,{children:"Lines of code comparison"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"SDK test coverage"}),(0,i.jsx)(n.td,{children:"85%+"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"make coverage-sdk"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Plugin development time"}),(0,i.jsx)(n.td,{children:"-30%"}),(0,i.jsx)(n.td,{children:"Time to add new plugin"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Bug reduction"}),(0,i.jsx)(n.td,{children:"-40%"}),(0,i.jsx)(n.td,{children:"Bugs in connection/TTL logic"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Performance (TTL)"}),(0,i.jsx)(n.td,{children:"10x better"}),(0,i.jsx)(n.td,{children:"Benchmark: 10K keys w/ TTLs"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Performance (pool)"}),(0,i.jsx)(n.td,{children:"No regression"}),(0,i.jsx)(n.td,{children:"Benchmark vs custom pool"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Review this memo"})," with team"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Approve Phase 1 packages"})," (pool, ttl, health)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Assign owners"})," for each package"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Create RFC-023"})," for detailed API design (if needed)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Begin Phase 1 implementation"})," (3 days)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Refactor plugins"})," to use new SDK packages (2 days)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Measure code reduction"})," and performance impact"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"related-documents",children:"Related Documents"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/rfc/rfc-021",children:"RFC-021: POC 1 Three Plugins Implementation"})," - Original plugin design"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/rfc/rfc-022",children:"RFC-022: Core Pattern SDK Code Layout"})," - SDK structure"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/rfc/rfc-015",children:"RFC-015: Plugin Acceptance Test Framework"})," - Testing strategy"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/memos/memo-004",children:"MEMO-004: Backend Implementation Guide"})," - Backend comparison"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"2025-10-11: Initial analysis of shared complexity across RFC-021 plugins"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>c});var t=r(96540);const i={},s=t.createContext(i);function l(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);