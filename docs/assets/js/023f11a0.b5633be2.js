"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[3511],{2882:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"authentication-authorization","title":"ADR-007: Authentication and Authorization","description":"Context","source":"@site/../docs-cms/adr/007-authentication-authorization.md","sourceDirName":".","slug":"/authentication-authorization","permalink":"/prism-data-layer/adr/authentication-authorization","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/007-authentication-authorization.md","tags":[{"inline":true,"label":"security","permalink":"/prism-data-layer/adr/tags/security"},{"inline":true,"label":"architecture","permalink":"/prism-data-layer/adr/tags/architecture"}],"version":"current","sidebarPosition":7,"frontMatter":{"title":"ADR-007: Authentication and Authorization","status":"Accepted","date":"2025-10-05T00:00:00.000Z","deciders":"Core Team","tags":["security","architecture"]},"sidebar":"adrSidebar","previous":{"title":"ADR-006: Namespace and Multi-Tenancy","permalink":"/prism-data-layer/adr/namespace-multi-tenancy"},"next":{"title":"ADR-008: Observability Strategy","permalink":"/prism-data-layer/adr/observability-strategy"}}');var r=i(4848),s=i(8453);const a={title:"ADR-007: Authentication and Authorization",status:"Accepted",date:new Date("2025-10-05T00:00:00.000Z"),deciders:"Core Team",tags:["security","architecture"]},c=void 0,l={},o=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Authentication Strategy",id:"authentication-strategy",level:3},{value:"Certificate-Based Authentication (mTLS)",id:"certificate-based-authentication-mtls",level:3},{value:"Authorization Model",id:"authorization-model",level:3},{value:"Authorization Flow",id:"authorization-flow",level:3},{value:"Tower Middleware Integration",id:"tower-middleware-integration",level:3},{value:"Audit Logging",id:"audit-logging",level:3},{value:"Alternatives Considered",id:"alternatives-considered",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Implementation Notes",id:"implementation-notes",level:2},{value:"Certificate Rotation",id:"certificate-rotation",level:3},{value:"Policy Storage",id:"policy-storage",level:3},{value:"Policy Distribution",id:"policy-distribution",level:3},{value:"References",id:"references",level:2},{value:"Revision History",id:"revision-history",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,r.jsx)(n.p,{children:"Prism handles sensitive data and must ensure:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Authentication"}),": Verify who/what is making requests"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Authorization"}),": Ensure they're allowed to access the data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Audit"}),": Track all access for compliance"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Multiple access patterns:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Service-to-service"}),": Backend microservices calling Prism"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"User-facing"}),": APIs exposed to end users (via app backends)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Admin"}),": Platform team managing Prism itself"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.strong,{children:"mTLS for service-to-service"})," authentication and ",(0,r.jsx)(n.strong,{children:"OAuth2/JWT for user-facing"})," APIs, with ",(0,r.jsx)(n.strong,{children:"namespace-level authorization"})," policies."]}),"\n",(0,r.jsx)(n.h2,{id:"rationale",children:"Rationale"}),"\n",(0,r.jsx)(n.h3,{id:"authentication-strategy",children:"Authentication Strategy"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Service-to-Service (Primary)"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Service A --[mTLS]--\x3e Prism Proxy --[mTLS]--\x3e Backend\n           (cert-based auth)\n\nCertificate contains:\n- Service name (CN: user-api.prod.company.com)\n- Environment (prod, staging, dev)\n- Expiry (auto-rotated)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"User-Facing APIs"})," (if exposed):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"User --\x3e App Backend --[OAuth2 JWT]--\x3e Prism Proxy\n                      (Bearer token)\n\nJWT contains:\n- User ID\n- Scopes/permissions\n- Expiry\n"})}),"\n",(0,r.jsx)(n.h3,{id:"certificate-based-authentication-mtls",children:"Certificate-Based Authentication (mTLS)"}),"\n",(0,r.jsx)(n.p,{children:"Every service gets a certificate signed by company CA:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use rustls::{ServerConfig, ClientConfig};\n\n// Proxy server config\nlet mut server_config = ServerConfig::new(NoClientAuth::new());\nserver_config\n    .set_single_cert(server_cert, server_key)?\n    .set_client_certificate_verifier(\n        AllowAnyAuthenticatedClient::new(client_ca_cert)\n    );\n\n// Verify client certificate\nlet tls_acceptor = TlsAcceptor::from(Arc::new(server_config));\nlet tls_stream = tls_acceptor.accept(tcp_stream).await?;\n\n// Extract service identity from cert\nlet peer_certs = tls_stream.get_ref().1.peer_certificates();\nlet service_name = extract_cn_from_cert(peer_certs[0])?;\n\n// service_name = "user-api.prod.company.com"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"authorization-model",children:"Authorization Model"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Namespace-based RBAC"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"namespace: user-profiles\n\naccess_control:\n  # Teams that own this namespace\n  owners:\n    - team: user-platform\n      role: admin\n\n  # Services that can access\n  consumers:\n    - service: user-api.prod.*\n      permissions: [read, write]\n\n    - service: analytics-pipeline.prod.*\n      permissions: [read]\n\n    - service: admin-dashboard.prod.*\n      permissions: [read]\n\n  # Deny by default\n  default_policy: deny\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Permission Levels"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"read"}),": Get, Scan operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"write"}),": Put, Delete operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"admin"}),": Modify namespace configuration"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"authorization-flow",children:"Authorization Flow"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'pub struct AuthorizationService {\n    policies: Arc<RwLock<HashMap<String, NamespacePolicy>>>,\n}\n\nimpl AuthorizationService {\n    pub async fn authorize(\n        &self,\n        service_name: &str,\n        namespace: &str,\n        operation: Operation,\n    ) -> Result<Decision> {\n        let policy = self.policies.read().await\n            .get(namespace)\n            .ok_or(Error::NamespaceNotFound)?;\n\n        // Check if service is allowed\n        for consumer in &policy.consumers {\n            if consumer.service_pattern.matches(service_name) {\n                let required_perm = match operation {\n                    Operation::Get | Operation::Scan => Permission::Read,\n                    Operation::Put | Operation::Delete => Permission::Write,\n                };\n\n                if consumer.permissions.contains(&required_perm) {\n                    return Ok(Decision::Allow);\n                }\n            }\n        }\n\n        // Deny by default\n        Ok(Decision::Deny(format!(\n            "Service {} not authorized for {:?} on namespace {}",\n            service_name, operation, namespace\n        )))\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"tower-middleware-integration",children:"Tower Middleware Integration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use tower::{Service, Layer};\n\npub struct AuthLayer {\n    authz: Arc<AuthorizationService>,\n}\n\nimpl<S> Layer<S> for AuthLayer {\n    type Service = AuthMiddleware<S>;\n\n    fn layer(&self, inner: S) -> Self::Service {\n        AuthMiddleware {\n            inner,\n            authz: self.authz.clone(),\n        }\n    }\n}\n\npub struct AuthMiddleware<S> {\n    inner: S,\n    authz: Arc<AuthorizationService>,\n}\n\nimpl<S> Service<Request> for AuthMiddleware<S>\nwhere\n    S: Service<Request>,\n{\n    type Response = S::Response;\n    type Error = S::Error;\n\n    async fn call(&mut self, req: Request) -> Result<Self::Response> {\n        // Extract service identity from mTLS cert\n        let service_name = req.extensions()\n            .get::<PeerCertificate>()\n            .and_then(|cert| extract_service_name(cert))?;\n\n        // Extract namespace and operation from request\n        let namespace = req.extensions().get::<Namespace>()?;\n        let operation = Operation::from_method(&req.method());\n\n        // Authorize\n        match self.authz.authorize(&service_name, namespace, operation).await? {\n            Decision::Allow => {\n                // Log and allow\n                tracing::info!(\n                    service = %service_name,\n                    namespace = %namespace,\n                    operation = ?operation,\n                    "Request authorized"\n                );\n                self.inner.call(req).await\n            }\n            Decision::Deny(reason) => {\n                // Log and reject\n                tracing::warn!(\n                    service = %service_name,\n                    namespace = %namespace,\n                    operation = ?operation,\n                    reason = %reason,\n                    "Request denied"\n                );\n                Err(Error::Forbidden(reason))\n            }\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"audit-logging",children:"Audit Logging"}),"\n",(0,r.jsx)(n.p,{children:"Every request generates an audit entry:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "timestamp": "2025-10-05T12:34:56Z",\n  "request_id": "req-abc-123",\n  "service": "user-api.prod.us-east-1",\n  "user_id": "user:12345",  // If JWT auth\n  "namespace": "user-profiles",\n  "operation": "get",\n  "keys": ["user:12345"],  // Redacted if PII\n  "decision": "allow",\n  "latency_ms": 2.3,\n  "backend": "postgres"\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"API Keys"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Pros: Simple"}),"\n",(0,r.jsx)(n.li,{children:"Cons: Hard to rotate, often leaked"}),"\n",(0,r.jsx)(n.li,{children:"Rejected: Not secure enough"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"OAuth2 for Everything"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Pros: Industry standard, good for users"}),"\n",(0,r.jsx)(n.li,{children:"Cons: Overkill for service-to-service, token endpoint becomes SPOF"}),"\n",(0,r.jsx)(n.li,{children:"Rejected: mTLS better for internal services"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"No Authentication"})," (rely on network security)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Pros: Zero overhead"}),"\n",(0,r.jsx)(n.li,{children:"Cons: Defense in depth, compliance requirements"}),"\n",(0,r.jsx)(n.li,{children:"Rejected: Unacceptable for production"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Row-Level Security"})," (database-native)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Pros: Enforced at DB layer"}),"\n",(0,r.jsx)(n.li,{children:"Cons: Backend-specific, can't work with Kafka"}),"\n",(0,r.jsx)(n.li,{children:"Rejected: Doesn't cover all backends"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,r.jsx)(n.h3,{id:"positive",children:"Positive"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Strong Authentication"}),": mTLS is industry best practice"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fine-Grained AuthZ"}),": Namespace-level policies are flexible"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Audit Trail"}),": Every request logged for compliance"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Defense in Depth"}),": Multiple layers of security"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"negative",children:"Negative"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Certificate Management"}),": Need PKI infrastructure","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"Mitigation"}),": Use existing company CA or service mesh (Linkerd, Istio)"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Policy Complexity"}),": Many namespaces = many policies","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"Mitigation"}),": Template-based policies, inheritance"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"neutral",children:"Neutral"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance"}),": mTLS handshake adds ~1-2ms","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Acceptable for our latency budget"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"OAuth2 Complexity"}),": Token validation adds overhead","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Cache validated tokens"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,r.jsx)(n.h3,{id:"certificate-rotation",children:"Certificate Rotation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// Watch for certificate updates\npub struct CertificateWatcher {\n    cert_path: PathBuf,\n    key_path: PathBuf,\n}\n\nimpl CertificateWatcher {\n    pub async fn watch(&self) -> Result<()> {\n        let mut watcher = notify::watcher(Duration::from_secs(60))?;\n        watcher.watch(&self.cert_path, RecursiveMode::NonRecursive)?;\n\n        loop {\n            match watcher.recv().await {\n                Ok(Event::Modify(_)) => {\n                    tracing::info!("Certificate updated, reloading...");\n                    self.reload_certificates().await?;\n                }\n                _ => {}\n            }\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"policy-storage",children:"Policy Storage"}),"\n",(0,r.jsx)(n.p,{children:"Policies stored in control plane database:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE namespace_policies (\n    namespace VARCHAR(255) PRIMARY KEY,\n    policy JSONB NOT NULL,\n    updated_at TIMESTAMPTZ NOT NULL,\n    updated_by VARCHAR(255) NOT NULL\n);\n\nCREATE INDEX idx_policies_updated ON namespace_policies(updated_at);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"policy-distribution",children:"Policy Distribution"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// Shards pull policies from control plane\npub struct PolicySync {\n    control_plane_url: String,\n    local_cache: Arc<RwLock<HashMap<String, NamespacePolicy>>>,\n}\n\nimpl PolicySync {\n    pub async fn sync_loop(&self) -> Result<()> {\n        let mut last_sync = Timestamp::now();\n\n        loop {\n            // Long-poll for updates\n            let updates: Vec<PolicyUpdate> = self.http_client\n                .get(&format!("{}/policies?since={}", self.control_plane_url, last_sync))\n                .timeout(Duration::from_secs(30))\n                .send()\n                .await?\n                .json()\n                .await?;\n\n            // Apply updates\n            let mut cache = self.local_cache.write().await;\n            for update in updates {\n                cache.insert(update.namespace, update.policy);\n                last_sync = update.timestamp;\n            }\n\n            tokio::time::sleep(Duration::from_secs(10)).await;\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.cloudflare.com/learning/access-management/what-is-mutual-tls/",children:"mTLS Best Practices"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://datatracker.ietf.org/doc/html/rfc6749",children:"OAuth 2.0 RFC 6749"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/rbac/",children:"RBAC in Kubernetes"})}),"\n",(0,r.jsx)(n.li,{children:"ADR-006: Namespace and Multi-Tenancy"}),"\n",(0,r.jsx)(n.li,{children:"FR-004: PII Handling"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"2025-10-05: Initial draft and acceptance"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>c});var t=i(6540);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);