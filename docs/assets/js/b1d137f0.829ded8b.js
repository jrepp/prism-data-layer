"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[4489],{28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>o});var r=s(96540);const i={},a=r.createContext(i);function t(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),r.createElement(a.Provider,{value:n},e.children)}},89080:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"adr-009","title":"Shadow Traffic for Migrations","description":"Context","source":"@site/../docs-cms/adr/adr-009-shadow-traffic-migrations.md","sourceDirName":".","slug":"/adr-009","permalink":"/prism-data-layer/adr/adr-009","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/adr-009-shadow-traffic-migrations.md","tags":[{"inline":true,"label":"operations","permalink":"/prism-data-layer/adr/tags/operations"},{"inline":true,"label":"reliability","permalink":"/prism-data-layer/adr/tags/reliability"},{"inline":true,"label":"backend","permalink":"/prism-data-layer/adr/tags/backend"}],"version":"current","frontMatter":{"date":"2025-10-05T00:00:00.000Z","deciders":"Core Team","doc_uuid":"fefcdbcd-6c7e-4e3c-8ef0-4652fb513085","id":"adr-009","project_id":"prism-data-layer","status":"Accepted","tags":["operations","reliability","backend"],"title":"Shadow Traffic for Migrations"},"sidebar":"adrSidebar","previous":{"title":"Observability Strategy \u2022 ADR-008","permalink":"/prism-data-layer/adr/adr-008"},"next":{"title":"Caching Layer Design \u2022 ADR-010","permalink":"/prism-data-layer/adr/adr-010"}}');var i=s(74848),a=s(28453);const t={date:new Date("2025-10-05T00:00:00.000Z"),deciders:"Core Team",doc_uuid:"fefcdbcd-6c7e-4e3c-8ef0-4652fb513085",id:"adr-009",project_id:"prism-data-layer",status:"Accepted",tags:["operations","reliability","backend"],title:"Shadow Traffic for Migrations"},o=void 0,l={},d=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Shadow Traffic Pattern",id:"shadow-traffic-pattern",level:3},{value:"Configuration Management",id:"configuration-management",level:3},{value:"Alternatives Considered",id:"alternatives-considered",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Implementation Notes",id:"implementation-notes",level:2},{value:"Metrics Dashboard",id:"metrics-dashboard",level:3},{value:"Automated Promotion",id:"automated-promotion",level:3},{value:"References",id:"references",level:2},{value:"Revision History",id:"revision-history",level:2}];function c(e){const n={a:"a",backfillstats:"backfillstats",br:"br",code:"code",em:"em",getresponse:"getresponse",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",putresponse:"putresponse",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,i.jsx)(n.p,{children:"Database migrations are risky and common:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Upgrade Postgres 14 \u2192 16"}),"\n",(0,i.jsx)(n.li,{children:"Move from Cassandra 2 \u2192 3 (Netflix did this for 250 clusters)"}),"\n",(0,i.jsx)(n.li,{children:"Migrate data from Postgres \u2192 Kafka for event sourcing"}),"\n",(0,i.jsx)(n.li,{children:"Change data model (add indexes, change schema)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Traditional migration approaches:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Stop-the-world"}),": Take outage, migrate, restart\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u274c Downtime unacceptable for critical services"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Blue-green deployment"}),": Run both, switch traffic\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u274c Data synchronization issues, expensive"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Gradual rollout"}),": Migrate % of traffic\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Better, but still risk of inconsistency"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Problem"}),": How do we migrate data and backends with zero downtime and high confidence?"]}),"\n",(0,i.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,i.jsxs)(n.p,{children:["Use ",(0,i.jsx)(n.strong,{children:"shadow traffic"})," pattern: Duplicate writes to old and new backends, compare results, promote new backend when confident."]}),"\n",(0,i.jsx)(n.h2,{id:"rationale",children:"Rationale"}),"\n",(0,i.jsx)(n.h3,{id:"shadow-traffic-pattern",children:"Shadow Traffic Pattern"}),"\n",(0,i.jsx)(n.p,{children:"Client Request\n\u2502\n\u25bc\nPrism Proxy\n\u2502\n\u251c\u2500\u2500\u25ba Primary Backend (old) \u2500\u2500\u25ba Response to client\n\u2502\n\u2514\u2500\u2500\u25ba Shadow Backend (new)  \u2500\u2500\u25ba Log comparison"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"\n**Phases**:\n\n1. **Shadow Write**: Write to both, read from primary\n2. **Backfill**: Copy existing data to new backend\n3. **Shadow Read**: Read from both, compare, serve from primary\n4. **Promote**: Switch primary to new backend\n5. **Decommission**: Remove old backend\n\n### Detailed Migration Flow\n\n**Phase 1: Setup Shadow (Week 1)**\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"namespace: user-profiles"}),"\n",(0,i.jsx)(n.p,{children:"backends:\nprimary:\ntype: postgres-old\nconnection: postgres://old-cluster/prism"}),"\n",(0,i.jsx)(n.p,{children:"shadow:\ntype: postgres-new\nconnection: postgres://new-cluster/prism\nmode: shadow_write  # Write only, don't read"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"\nAll writes go to both:\n"})}),"\n",(0,i.jsxs)(n.p,{children:["async fn put(&self, request: PutRequest) -> Result",(0,i.jsx)(n.putresponse,{children:" {\n// Write to primary (blocking)\nlet primary_result = self.primary_backend.put(&request).await?;"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'// Write to shadow (async, don\'t block response)\nlet shadow_request = request.clone();\ntokio::spawn(async move {\n    match self.shadow_backend.put(&shadow_request).await {\n        Ok(_) => {\n            metrics::SHADOW_WRITES_SUCCESS.inc();\n        }\n        Err(e) => {\n            metrics::SHADOW_WRITES_ERRORS.inc();\n            tracing::warn!(error = %e, "Shadow write failed");\n        }\n    }\n});\n\nOk(primary_result)\n'})}),"\n",(0,i.jsx)(n.p,{children:"}"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"\n**Phase 2: Backfill (Week 2-3)**\n\nCopy existing data:\n"})}),"\n",(0,i.jsx)(n.h1,{id:"scan-all-data-from-primary",children:"Scan all data from primary"}),"\n",(0,i.jsxs)(n.p,{children:["prism-cli backfill ",(0,i.jsx)(n.br,{}),"\n--namespace user-profiles ",(0,i.jsx)(n.br,{}),"\n--from postgres-old ",(0,i.jsx)(n.br,{}),"\n--to postgres-new ",(0,i.jsx)(n.br,{}),"\n--parallelism 10 ",(0,i.jsx)(n.br,{}),"\n--throttle-rps 1000"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text"})}),"\n",(0,i.jsxs)(n.p,{children:["async fn backfill(\nfrom: &dyn Backend,\nto: &dyn Backend,\nnamespace: &str,\n) -> Result",(0,i.jsx)(n.backfillstats,{children:" {\nlet mut cursor = None;\nlet mut total_copied = 0;"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"loop {\n    // Scan batch from source\n    let batch = from.scan(namespace, cursor.as_ref(), 1000).await?;\n    if batch.items.is_empty() {\n        break;\n    }\n\n    // Write batch to destination\n    to.put_batch(namespace, &batch.items).await?;\n\n    total_copied += batch.items.len();\n    cursor = batch.next_cursor;\n\n    metrics::BACKFILL_ITEMS.inc_by(batch.items.len() as u64);\n}\n\nOk(BackfillStats { items_copied: total_copied })\n"})}),"\n",(0,i.jsx)(n.p,{children:"}"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"\n**Phase 3: Shadow Read (Week 4)**\n\nRead from both, compare:\n"})}),"\n",(0,i.jsx)(n.p,{children:"namespace: user-profiles"}),"\n",(0,i.jsx)(n.p,{children:"backends:\nprimary:\ntype: postgres-old"}),"\n",(0,i.jsx)(n.p,{children:"shadow:\ntype: postgres-new\nmode: shadow_read  # Read and compare"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text"})}),"\n",(0,i.jsxs)(n.p,{children:["async fn get(&self, request: GetRequest) -> Result",(0,i.jsx)(n.getresponse,{children:" {\n// Read from primary (blocking)\nlet primary_response = self.primary_backend.get(&request).await?;"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'// Read from shadow (async comparison)\nlet shadow_request = request.clone();\nlet primary_items = primary_response.items.clone();\ntokio::spawn(async move {\n    match self.shadow_backend.get(&shadow_request).await {\n        Ok(shadow_response) => {\n            // Compare results\n            if shadow_response.items == primary_items {\n                metrics::SHADOW_READS_MATCH.inc();\n            } else {\n                metrics::SHADOW_READS_MISMATCH.inc();\n                tracing::error!(\n                    "Shadow read mismatch for {}",\n                    shadow_request.id\n                );\n                // Log differences for analysis\n            }\n        }\n        Err(e) => {\n            metrics::SHADOW_READS_ERRORS.inc();\n            tracing::warn!(error = %e, "Shadow read failed");\n        }\n    }\n});\n\nOk(primary_response)\n'})}),"\n",(0,i.jsx)(n.p,{children:"}"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"\n**Monitor mismatch rate**:\nshadow_reads_mismatch_rate =\n    shadow_reads_mismatch / (shadow_reads_match + shadow_reads_mismatch)\n\nTarget: < 0.1% (1 in 1000)\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Phase 4: Promote (Week 5)"})}),"\n",(0,i.jsx)(n.p,{children:"Flip primary when confident:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"namespace: user-profiles\n\nbackends:\n  primary:\n    type: postgres-new  # \u2190 Changed!\n\n  shadow:\n    type: postgres-old  # Keep old as shadow for safety\n    mode: shadow_write\n"})}),"\n",(0,i.jsx)(n.p,{children:"Monitor for issues. If problems, flip back instantly."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Phase 5: Decommission (Week 6+)"})}),"\n",(0,i.jsx)(n.p,{children:"After confidence period (e.g., 2 weeks):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"namespace: user-profiles\n\nbackends:\n  primary:\n    type: postgres-new\n  # shadow removed\n"})}),"\n",(0,i.jsx)(n.p,{children:"Delete old backend resources."}),"\n",(0,i.jsx)(n.h3,{id:"configuration-management",children:"Configuration Management"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"#[derive(Deserialize)]\npub struct NamespaceConfig {\n    pub name: String,\n    pub backends: BackendConfig,\n}\n\n#[derive(Deserialize)]\npub struct BackendConfig {\n    pub primary: BackendSpec,\n    pub shadow: Option<ShadowBackendSpec>,\n}\n\n#[derive(Deserialize)]\npub struct ShadowBackendSpec {\n    #[serde(flatten)]\n    pub backend: BackendSpec,\n\n    pub mode: ShadowMode,\n    pub sample_rate: f64,  // 0.0-1.0, default 1.0\n}\n\n#[derive(Deserialize)]\npub enum ShadowMode {\n    ShadowWrite,  // Write to both, read from primary\n    ShadowRead,   // Read from both, compare\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Stop-the-World Migration"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Pros: Simple, guaranteed consistent"}),"\n",(0,i.jsx)(n.li,{children:"Cons: Downtime unacceptable"}),"\n",(0,i.jsx)(n.li,{children:"Rejected: Not viable for critical services"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Application-Level Dual Writes"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Pros: Application has full control"}),"\n",(0,i.jsx)(n.li,{children:"Cons: Every app must implement, error-prone"}),"\n",(0,i.jsx)(n.li,{children:"Rejected: Platform should handle this"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Database Replication"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Pros: Database-native"}),"\n",(0,i.jsx)(n.li,{children:"Cons: Tied to specific databases, not all support it"}),"\n",(0,i.jsx)(n.li,{children:"Rejected: Doesn't work for Postgres \u2192 Kafka migration"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Event Sourcing + Replay"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Pros: Can replay events to new backend"}),"\n",(0,i.jsx)(n.li,{children:"Cons: Requires event log, complex"}),"\n",(0,i.jsx)(n.li,{children:"Rejected: Too heavy for simple migrations"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,i.jsx)(n.h3,{id:"positive",children:"Positive"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Zero Downtime"}),": No service interruption"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"High Confidence"}),": Validate new backend with prod traffic before switching"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rollback"}),": Easy to revert if issues found"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Gradual"}),": Can shadow 10% of traffic first, then 100%"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"negative",children:"Negative"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Write Amplification"}),": 2x writes during shadow phase\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Mitigation"}),": Shadow writes async, don't block"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cost"}),": Running two backends simultaneously\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Mitigation"}),": Migration is temporary (weeks, not months)"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Complexity"}),": More code, more config\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Mitigation"}),": Platform handles it, not app developers"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"neutral",children:"Neutral"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mismatch Debugging"}),": Need to investigate mismatches\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Provides valuable validation"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,i.jsx)(n.h3,{id:"metrics-dashboard",children:"Metrics Dashboard"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# Grafana dashboard\npanels:\n  - title: "Shadow Write Success Rate"\n    expr: |\n      sum(rate(prism_shadow_writes_success[5m]))\n      /\n      sum(rate(prism_shadow_writes_total[5m]))\n\n  - title: "Shadow Read Mismatch Rate"\n    expr: |\n      sum(rate(prism_shadow_reads_mismatch[5m]))\n      /\n      sum(rate(prism_shadow_reads_total[5m]))\n\n  - title: "Backfill Progress"\n    expr: prism_backfill_items_total\n'})}),"\n",(0,i.jsx)(n.h3,{id:"automated-promotion",children:"Automated Promotion"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub struct MigrationOrchestrator {\n    config: MigrationConfig,\n}\n\nimpl MigrationOrchestrator {\n    pub async fn execute(&self) -> Result<()> {\n        // Phase 1: Enable shadow writes\n        self.update_config(ShadowMode::ShadowWrite).await?;\n        metrics::wait_for_shadow_write_success_rate(0.99, Duration::from_hours(24)).await?;\n\n        // Phase 2: Backfill\n        self.backfill().await?;\n\n        // Phase 3: Enable shadow reads\n        self.update_config(ShadowMode::ShadowRead).await?;\n        metrics::wait_for_shadow_read_mismatch_rate(0.001, Duration::from_days(3)).await?;\n\n        // Phase 4: Promote\n        self.promote().await?;\n        metrics::wait_for_no_errors(Duration::from_days(7)).await?;\n\n        // Phase 5: Decommission\n        self.decommission_old().await?;\n\n        Ok(())\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Netflix Data Gateway: Shadow Traffic"}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.blog/2021-04-27-ship-code-faster-safer-feature-flags/",children:"GitHub: How We Ship Code Faster and Safer with Feature Flags"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://stripe.com/blog/online-migrations",children:"Stripe: Online Migrations at Scale"})}),"\n",(0,i.jsx)(n.li,{children:"ADR-005: Backend Plugin Architecture"}),"\n",(0,i.jsx)(n.li,{children:"ADR-006: Namespace and Multi-Tenancy"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"2025-10-05: Initial draft and acceptance"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);