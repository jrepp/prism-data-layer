"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[40798],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var s=t(96540);const r={},a=s.createContext(r);function o(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(a.Provider,{value:n},e.children)}},71013:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"adr-004","title":"Local-First Testing Strategy","description":"Context","source":"@site/../docs-cms/adr/adr-004-local-first-testing.md","sourceDirName":".","slug":"/adr-004","permalink":"/prism-data-layer/adr/adr-004","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/adr-004-local-first-testing.md","tags":[{"inline":true,"label":"testing","permalink":"/prism-data-layer/adr/tags/testing"},{"inline":true,"label":"dx","permalink":"/prism-data-layer/adr/tags/dx"},{"inline":true,"label":"reliability","permalink":"/prism-data-layer/adr/tags/reliability"}],"version":"current","frontMatter":{"date":"2025-10-05T00:00:00.000Z","deciders":"Core Team","doc_uuid":"fd47488b-2780-4211-8e94-f2131102eb01","id":"adr-004","project_id":"prism-data-layer","status":"Accepted","tags":["testing","dx","reliability"],"title":"Local-First Testing Strategy"},"sidebar":"adrSidebar","previous":{"title":"Protobuf as Single Source of Truth \u2022 ADR-003","permalink":"/prism-data-layer/adr/adr-003"},"next":{"title":"Backend Plugin Architecture \u2022 ADR-005","permalink":"/prism-data-layer/adr/adr-005"}}');var r=t(74848),a=t(28453);const o={date:new Date("2025-10-05T00:00:00.000Z"),deciders:"Core Team",doc_uuid:"fd47488b-2780-4211-8e94-f2131102eb01",id:"adr-004",project_id:"prism-data-layer",status:"Accepted",tags:["testing","dx","reliability"],title:"Local-First Testing Strategy"},i=void 0,l={},c=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Principles",id:"principles",level:3},{value:"Architecture",id:"architecture",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,r.jsx)(n.p,{children:"Testing data infrastructure is challenging:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Traditional approach"}),": Use mocks/fakes for unit tests, real databases for integration tests"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problems with mocks"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Don't catch integration bugs"}),"\n",(0,r.jsx)(n.li,{children:"Drift from real behavior"}),"\n",(0,r.jsx)(n.li,{children:"Give false confidence"}),"\n",(0,r.jsx)(n.li,{children:"Don't test performance characteristics"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problems with cloud-only testing"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Slow feedback loop (deploy to test)"}),"\n",(0,r.jsx)(n.li,{children:"Expensive (running test infra 24/7)"}),"\n",(0,r.jsx)(n.li,{children:"Complex setup (VPNs, credentials, etc.)"}),"\n",(0,r.jsx)(n.li,{children:"Hard to reproduce CI failures locally"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": How do we test Prism thoroughly while maintaining fast iteration and developer happiness?"]}),"\n",(0,r.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,r.jsxs)(n.p,{children:["Adopt a ",(0,r.jsx)(n.strong,{children:"local-first testing strategy"}),": All backends must support running locally with Docker Compose. Prioritize real local backends over mocks. Use the same test suite locally and in CI."]}),"\n",(0,r.jsx)(n.h2,{id:"rationale",children:"Rationale"}),"\n",(0,r.jsx)(n.h3,{id:"principles",children:"Principles"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Real > Fake"}),": Use actual databases (sqlite, postgres, kafka) instead of mocks"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Local > Cloud"}),": Developers can run full stack on laptop"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fast > Slow"}),": Optimize for sub-second test execution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Simple > Complex"}),": Minimal setup; works out of the box"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"architecture",children:"Architecture"}),"\n",(0,r.jsx)(n.p,{children:"Developer Laptop\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Tests (Rust, Python)                  \u2502\n\u2502         \u2193 \u2193 \u2193                          \u2502\n\u2502  Prism Proxy (Rust)                    \u2502\n\u2502         \u2193 \u2193 \u2193                          \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502 Docker Compose                   \u2502  \u2502\n\u2502  \u2502  \u2022 PostgreSQL (in-memory mode)   \u2502  \u2502\n\u2502  \u2502  \u2022 Kafka (kraft, single broker)  \u2502  \u2502\n\u2502  \u2502  \u2022 NATS (embedded mode)          \u2502  \u2502\n\u2502  \u2502  \u2022 SQLite (file://local.db)      \u2502  \u2502\n\u2502  \u2502  \u2022 Neptune (localstack)          \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n### Local Stack Configuration\n\n"})}),"\n",(0,r.jsx)(n.h1,{id:"docker-composetestyml",children:"docker-compose.test.yml"}),"\n",(0,r.jsx)(n.p,{children:"version: '3.9'"}),"\n",(0,r.jsx)(n.p,{children:'services:\npostgres:\nimage: postgres:16-alpine\nenvironment:\nPOSTGRES_DB: prism_test\nPOSTGRES_USER: prism\nPOSTGRES_PASSWORD: prism_test_password\ncommand:\n- postgres\n- -c\n- fsync=off              # Faster for tests\n- -c\n- full_page_writes=off\n- -c\n- synchronous_commit=off\ntmpfs:\n- /var/lib/postgresql/data  # In-memory for speed\nports:\n- "5432:5432"\nhealthcheck:\ntest: ["CMD-SHELL", "pg_isready -U prism"]\ninterval: 1s\ntimeout: 1s\nretries: 30'}),"\n",(0,r.jsx)(n.p,{children:'kafka:\nimage: apache/kafka:latest\nenvironment:\nKAFKA_NODE_ID: 1\nKAFKA_PROCESS_ROLES: broker,controller\nKAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092,CONTROLLER://0.0.0.0:9093\nKAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092\nKAFKA_CONTROLLER_LISTENER_NAMES: CONTROLLER\nKAFKA_CONTROLLER_QUORUM_VOTERS: 1@localhost:9093\n# Fast for tests\nKAFKA_LOG_FLUSH_INTERVAL_MESSAGES: 1\nKAFKA_LOG_FLUSH_INTERVAL_MS: 10\nports:\n- "9092:9092"\nhealthcheck:\ntest: ["CMD-SHELL", "kafka-broker-api-versions.sh --bootstrap-server localhost:9092"]\ninterval: 1s\ntimeout: 1s\nretries: 30'}),"\n",(0,r.jsx)(n.p,{children:'nats:\nimage: nats:alpine\ncommand: ["-js", "-m", "8222"]  # Enable JetStream and monitoring\nports:\n- "4222:4222"  # Client port\n- "8222:8222"  # Monitoring port\nhealthcheck:\ntest: ["CMD-SHELL", "wget -q --spider http://localhost:8222/healthz"]\ninterval: 1s\ntimeout: 1s\nretries: 10'}),"\n",(0,r.jsx)(n.h1,{id:"aws-neptune-compatible-for-local-graph-testing",children:"AWS Neptune compatible (for local graph testing)"}),"\n",(0,r.jsx)(n.p,{children:'neptune:\nimage: localstack/localstack:latest\nenvironment:\nSERVICES: neptune\nDEBUG: 1\nports:\n- "8182:8182"\nvolumes:\n- /var/run/docker.sock:/var/run/docker.sock'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n### Python Tooling\n\n"})}),"\n",(0,r.jsx)(n.h1,{id:"toolingtestlocal_stackpy",children:"tooling/test/local_stack.py"}),"\n",(0,r.jsx)(n.p,{children:"import subprocess\nimport time\nfrom dataclasses import dataclass"}),"\n",(0,r.jsx)(n.p,{children:"@dataclass\nclass Backend:\nname: str\nport: int\nhealthcheck: callable"}),"\n",(0,r.jsx)(n.p,{children:'class LocalStack:\n"""Manage local test infrastructure."""'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'def __init__(self):\n    self.backends = [\n        Backend("postgres", 5432, self._check_postgres),\n        Backend("kafka", 9092, self._check_kafka),\n        Backend("nats", 4222, self._check_nats),\n    ]\n\ndef up(self, wait: bool = True):\n    """Start all backend services."""\n    subprocess.run([\n        "docker", "compose",\n        "-f", "docker-compose.test.yml",\n        "up", "-d"\n    ], check=True)\n\n    if wait:\n        self.wait_healthy()\n\ndef down(self):\n    """Stop and remove all services."""\n    subprocess.run([\n        "docker", "compose",\n        "-f", "docker-compose.test.yml",\n        "down", "-v"  # Remove volumes\n    ], check=True)\n\ndef wait_healthy(self, timeout: int = 60):\n    """Wait for all services to be healthy."""\n    start = time.time()\n    while time.time() - start < timeout:\n        if all(b.healthcheck() for b in self.backends):\n            print("\u2713 All services healthy")\n            return\n        time.sleep(0.5)\n    raise TimeoutError("Services failed to become healthy")\n\ndef reset(self):\n    """Reset all data (for test isolation)."""\n    # Truncate all tables, delete all Kafka topics, etc.\n    pass\n'})}),"\n",(0,r.jsx)(n.h1,{id:"cli",children:"CLI"}),"\n",(0,r.jsxs)(n.p,{children:["if ",(0,r.jsx)(n.strong,{children:"name"}),' == "',(0,r.jsx)(n.strong,{children:"main"}),'":\nimport argparse\nparser = argparse.ArgumentParser()\nparser.add_argument("command", choices=["up", "down", "reset"])\nargs = parser.parse_args()']}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'stack = LocalStack()\nif args.command == "up":\n    stack.up()\nelif args.command == "down":\n    stack.down()\nelif args.command == "reset":\n    stack.reset()\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n### Test Structure\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"// proxy/tests/integration/keyvalue_test.rs"}),"\n",(0,r.jsxs)(n.p,{children:["use prism_proxy::",(0,r.jsx)(n.em,{children:";\nuse testcontainers::"}),"; // Fallback if Docker Compose not available"]}),"\n",(0,r.jsx)(n.p,{children:"#[tokio::test]\nasync fn test_keyvalue_postgres() {\n// Uses real Postgres from docker-compose.test.yml\nlet mut proxy = TestProxy::new(Backend::Postgres).await;"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// Write data\nproxy.put("user:123", b"Alice").await.unwrap();\n\n// Read it back\nlet value = proxy.get("user:123").await.unwrap();\nassert_eq!(value, b"Alice");\n\n// Verify it\'s actually in Postgres\nlet row: (String,) = sqlx::query_as("SELECT value FROM kv WHERE key = $1")\n    .bind("user:123")\n    .fetch_one(&proxy.postgres_pool())\n    .await\n    .unwrap();\nassert_eq!(row.0, "Alice");\n'})}),"\n",(0,r.jsx)(n.p,{children:"}"}),"\n",(0,r.jsx)(n.p,{children:"#[tokio::test]\nasync fn test_keyvalue_kafka() {\nlet mut proxy = TestProxy::new(Backend::Kafka).await;"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// Same API, different backend\nproxy.put("event:456", b"Login").await.unwrap();\n\nlet value = proxy.get("event:456").await.unwrap();\nassert_eq!(value, b"Login");\n\n// Verify it\'s actually in Kafka\n// ... Kafka consumer check ...\n'})}),"\n",(0,r.jsx)(n.p,{children:"}"}),"\n",(0,r.jsx)(n.p,{children:"// Load test\n#[tokio::test]\n#[ignore]  // Run explicitly with: cargo test --ignored\nasync fn load_test_keyvalue_writes() {\nlet proxy = TestProxy::new(Backend::Postgres).await;"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'let start = std::time::Instant::now();\nlet tasks: Vec<_> = (0..1000)\n    .map(|i| {\n        let mut proxy = proxy.clone();\n        tokio::spawn(async move {\n            proxy.put(&format!("key:{}", i), b"value").await.unwrap();\n        })\n    })\n    .collect();\n\nfutures::future::join_all(tasks).await;\n\nlet elapsed = start.elapsed();\nlet throughput = 1000.0 / elapsed.as_secs_f64();\n\nprintln!("Throughput: {:.0} writes/sec", throughput);\nprintln!("Latency: {:.2}ms per write", elapsed.as_secs_f64() / 1000.0 * 1000.0);\n\nassert!(throughput > 500.0, "Throughput too low: {}", throughput);\n'})}),"\n",(0,r.jsx)(n.p,{children:"}"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n### Alternatives Considered\n\n1. **Mock All The Things**\n   - Pros:\n     - Fast tests\n     - No external dependencies\n   - Cons:\n     - Doesn't catch integration bugs\n     - Mocks drift from reality\n     - More code to maintain (mocks)\n   - Rejected because: Low confidence in test results\n\n2. **Cloud-Only Testing**\n   - Pros:\n     - Tests production environment\n     - No local setup\n   - Cons:\n     - Slow feedback (minutes, not seconds)\n     - Expensive\n     - Can't debug locally\n   - Rejected because: Poor developer experience\n\n3. **In-Memory Fakes**\n   - Pros:\n     - Faster than real databases\n     - No Docker required\n   - Cons:\n     - Subtle behavior differences\n     - Don't test performance\n     - Still not the real thing\n   - Rejected because: Real backends with optimization are fast enough\n\n4. **Testcontainers Only** (no Docker Compose)\n   - Pros:\n     - Programmatic container management\n     - Good for isolated tests\n   - Cons:\n     - Slower startup per test\n     - Harder to reuse containers\n     - No standard docker-compose.yml for docs\n   - Rejected because: Docker Compose is simpler; can use testcontainers as fallback\n\n## Consequences\n\n### Positive\n\n- **High Confidence**: Tests use real backends, catch real bugs\n- **Fast Feedback**: Full test suite runs in `<1 minute` locally\n- **Easy Debugging**: Reproduce any test failure on laptop\n- **Performance Testing**: Load tests use same local infrastructure\n- **Documentation**: docker-compose.yml shows how to run Prism\n\n### Negative\n\n- **Requires Docker**: Developers must install Docker\n  - *Mitigation*: Docker is ubiquitous; provide install instructions\n- **Slower Than Mocks**: Real databases have overhead\n  - *Mitigation*: Optimize with in-memory modes, tmpfs\n- **More Complex Setup**: docker-compose.yml to maintain\n  - *Mitigation*: Tooling abstracts complexity; `python -m tooling.test.local-stack up`\n\n### Neutral\n\n- **Not Production-Identical**: Local postgres \u2260 AWS RDS\n  - Use same software version; accept minor differences\n  - Run subset of tests against staging/prod\n- **Resource Usage**: Running backends uses CPU/memory\n  - Modern laptops handle it fine\n  - CI runners sized appropriately\n\n## Implementation Notes\n\n### Optimizations for Speed\n\n1. **In-Memory Postgres**: Use `tmpfs` for data directory\n2. **Kafka**: Single broker, minimal replication\n3. **Connection Pooling**: Reuse connections between tests\n4. **Parallel Tests**: Use `cargo test --jobs 4`\n5. **Test Isolation**: Each test uses unique namespace (no truncation needed)\n\n### CI Configuration\n\n"})}),"\n",(0,r.jsx)(n.h1,{id:"githubworkflowstestyml",children:".github/workflows/test.yml"}),"\n",(0,r.jsx)(n.p,{children:"name: Tests"}),"\n",(0,r.jsx)(n.p,{children:"on: [push, pull_request]"}),"\n",(0,r.jsx)(n.p,{children:"jobs:\ntest:\nruns-on: ubuntu-latest"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"steps:\n  - uses: actions/checkout@v3\n\n  - name: Start local stack\n    run: python -m tooling.test.local-stack up\n\n  - name: Run tests\n    run: cargo test --workspace\n\n  - name: Run load tests\n    run: cargo test --workspace --ignored\n\n  - name: Stop local stack\n    if: always()\n    run: python -m tooling.test.local-stack down\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n### Developer Workflow\n\n"})}),"\n",(0,r.jsx)(n.h1,{id:"one-time-setup",children:"One-time setup"}),"\n",(0,r.jsxs)(n.p,{children:["curl -LsSf ",(0,r.jsx)(n.a,{href:"https://astral.sh/uv/install.sh",children:"https://astral.sh/uv/install.sh"})," | sh\nuv sync"]}),"\n",(0,r.jsx)(n.h1,{id:"start-backends-leave-running",children:"Start backends (leave running)"}),"\n",(0,r.jsx)(n.p,{children:"python -m tooling.test.local-stack up"}),"\n",(0,r.jsx)(n.h1,{id:"run-tests-as-many-times-as-you-want",children:"Run tests (as many times as you want)"}),"\n",(0,r.jsx)(n.p,{children:"cargo test\ncargo test --ignored  # Load tests"}),"\n",(0,r.jsx)(n.h1,{id:"stop-when-done",children:"Stop when done"}),"\n",(0,r.jsx)(n.p,{children:"python -m tooling.test.local-stack down"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n## References\n\n- [Testcontainers](https://www.testcontainers.org/)\n- [Docker Compose](https://docs.docker.com/compose/)\n- [Martin Fowler - Integration Testing](https://martinfowler.com/bliki/IntegrationTest.html)\n- [Google Testing Blog - Test Sizes](https://testing.googleblog.com/2010/12/test-sizes.html)\n\n## Revision History\n\n- 2025-10-05: Initial draft and acceptance\n\n"})})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);