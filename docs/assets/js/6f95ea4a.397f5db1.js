"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[54862],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var s=t(96540);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}},52154:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"adr-011","title":"Implementation Roadmap and Next Steps","description":"Context","source":"@site/../docs-cms/adr/adr-011-implementation-roadmap.md","sourceDirName":".","slug":"/adr-011","permalink":"/prism-data-layer/adr/adr-011","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/adr-011-implementation-roadmap.md","tags":[{"inline":true,"label":"architecture","permalink":"/prism-data-layer/adr/tags/architecture"},{"inline":true,"label":"planning","permalink":"/prism-data-layer/adr/tags/planning"}],"version":"current","frontMatter":{"date":"2025-10-05T00:00:00.000Z","deciders":"Core Team","doc_uuid":"dbf661b2-ebfc-493a-97d6-071f027c9f6e","id":"adr-011","project_id":"prism-data-layer","status":"Accepted","tags":["architecture","planning"],"title":"Implementation Roadmap and Next Steps"},"sidebar":"adrSidebar","previous":{"title":"Caching Layer Design \u2022 ADR-010","permalink":"/prism-data-layer/adr/adr-010"},"next":{"title":"Go for Tooling and CLI Utilities \u2022 ADR-012","permalink":"/prism-data-layer/adr/adr-012"}}');var r=t(74848),a=t(28453);const i={date:new Date("2025-10-05T00:00:00.000Z"),deciders:"Core Team",doc_uuid:"dbf661b2-ebfc-493a-97d6-071f027c9f6e",id:"adr-011",project_id:"prism-data-layer",status:"Accepted",tags:["architecture","planning"],title:"Implementation Roadmap and Next Steps"},l=void 0,o={},c=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Step 1: Protobuf Foundation (Week 1, Days 1-3)",id:"step-1-protobuf-foundation-week-1-days-1-3",level:2},{value:"Goal",id:"goal",level:3},{value:"Deliverables",id:"deliverables",level:3}];function d(e){const n={channel:"channel",code:"code",dyn:"dyn",h1:"h1",h2:"h2",h3:"h3",healthcheckresponse:"healthcheckresponse",item:"item",li:"li",ol:"ol",p:"p",pre:"pre",putrequest:"putrequest",putresponse:"putresponse",strong:"strong",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,r.jsx)(n.p,{children:"We have comprehensive architecture documentation (ADRs 001-010), protobuf data model plan, and PRD. Now we need a concrete implementation roadmap that balances:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Quick wins"}),": Show value early"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Risk reduction"}),": Validate core assumptions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Incremental delivery"}),": Each step produces working software"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Learning"}),": Build expertise progressively"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The roadmap must deliver a working system that demonstrates Prism's core value proposition within 4 weeks."}),"\n",(0,r.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,r.jsxs)(n.p,{children:["Implement Prism in ",(0,r.jsx)(n.strong,{children:"6 major steps"}),", each building on the previous, with clear deliverables and success criteria."]}),"\n",(0,r.jsx)(n.h2,{id:"step-1-protobuf-foundation-week-1-days-1-3",children:"Step 1: Protobuf Foundation (Week 1, Days 1-3)"}),"\n",(0,r.jsx)(n.h3,{id:"goal",children:"Goal"}),"\n",(0,r.jsx)(n.p,{children:"Establish protobuf as single source of truth with code generation pipeline."}),"\n",(0,r.jsx)(n.h3,{id:"deliverables",children:"Deliverables"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Create ",(0,r.jsx)(n.code,{children:"proto/"})," directory structure"]}),":\nproto/\n\u251c\u2500\u2500 prism/\n\u2502   \u251c\u2500\u2500 options.proto         # Custom Prism tags\n\u2502   \u2514\u2500\u2500 common/\n\u2502       \u251c\u2500\u2500 types.proto       # Timestamps, UUIDs, etc.\n\u2502       \u251c\u2500\u2500 errors.proto      # Error definitions\n\u2502       \u2514\u2500\u2500 metadata.proto    # Item metadata\n\u251c\u2500\u2500 buf.yaml                   # Buf configuration\n\u2514\u2500\u2500 buf.lock"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n2. **Implement Prism custom options**:\n   - Message-level: `namespace`, `backend`, `access_pattern`, `estimated_*_rps`, etc.\n   - Field-level: `pii`, `encrypt_at_rest`, `index`, `validation`\n   - Service/RPC-level: `require_auth`, `timeout_ms`, `idempotent`\n\n3. **Set up code generation**:\n"})}),"\n",(0,r.jsx)(n.h1,{id:"install-buf",children:"Install buf"}),"\n",(0,r.jsx)(n.p,{children:"brew install bufbuild/buf/buf"}),"\n",(0,r.jsx)(n.h1,{id:"generate-rust-code",children:"Generate Rust code"}),"\n",(0,r.jsx)(n.p,{children:"buf generate --template buf.gen.rust.yaml"}),"\n",(0,r.jsx)(n.h1,{id:"generate-python-code",children:"Generate Python code"}),"\n",(0,r.jsx)(n.p,{children:"buf generate --template buf.gen.python.yaml"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n4. **Create `tooling/codegen`** module:\n"})}),"\n",(0,r.jsx)(n.p,{children:"python -m tooling.codegen generate"}),"\n",(0,r.jsx)(n.h1,{id:"-generates-rust-python-typescript-from-proto",children:"\u2192 Generates Rust, Python, TypeScript from proto"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n### Success Criteria\n- \u2705 `prism/options.proto` compiles without errors\n- \u2705 Rust code generates successfully with `prost`\n- \u2705 Can import generated Rust code in a test program\n- \u2705 Buf lint passes with zero warnings\n\n### Files to Create\n- `proto/prism/options.proto` (~200 lines)\n- `proto/prism/common/*.proto` (~150 lines total)\n- `proto/buf.yaml` (~30 lines)\n- `tooling/codegen/generator.py` (~100 lines)\n\n---\n\n## Step 2: Rust Proxy Skeleton (Week 1, Days 4-5)\n\n### Goal\nCreate minimal gRPC server in Rust that can accept requests and return dummy responses.\n\n### Deliverables\n\n1. **Initialize Rust workspace**:\n"})}),"\n",(0,r.jsx)(n.p,{children:"cargo new --lib proxy\ncd proxy"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n2. **Add dependencies** (`Cargo.toml`):\n"})}),"\n",(0,r.jsx)(n.p,{children:'[dependencies]\ntokio = { version = "1.35", features = ["full"] }\ntonic = "0.10"\nprost = "0.12"\ntower = "0.4"\ntracing = "0.1"\ntracing-subscriber = "0.3"'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n3. **Implement health check service**:\n"})}),"\n",(0,r.jsx)(n.p,{children:"// proxy/src/health.rs\npub struct HealthService;"}),"\n",(0,r.jsxs)(n.p,{children:["#[tonic::async_trait]\nimpl HealthCheck for HealthService {\nasync fn check(&self, _req: Request<()>) -> Result<Response",(0,r.jsx)(n.healthcheckresponse,{children:'> {\nOk(Response::new(HealthCheckResponse { status: "healthy" }))\n}\n}'})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n4. **Create main server**:\n"})}),"\n",(0,r.jsx)(n.p,{children:'// proxy/src/main.rs\n#[tokio::main]\nasync fn main() -> Result<()> {\nlet addr = "0.0.0.0:8980".parse()?;\nlet health_svc = HealthService::default();'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Server::builder()\n    .add_service(HealthServer::new(health_svc))\n    .serve(addr)\n    .await?;\n\nOk(())\n"})}),"\n",(0,r.jsx)(n.p,{children:"}"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n5. **Add basic logging**:\n"})}),"\n",(0,r.jsx)(n.p,{children:"tracing_subscriber::fmt()\n.with_target(false)\n.compact()\n.init();"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n### Success Criteria\n- \u2705 `cargo build` succeeds\n- \u2705 Server starts on port 8980\n- \u2705 Health check responds: `grpcurl localhost:8980 Health/Check`\n- \u2705 Logs appear in JSON format\n\n### Files to Create\n- `proxy/Cargo.toml` (~40 lines)\n- `proxy/src/main.rs` (~80 lines)\n- `proxy/src/health.rs` (~30 lines)\n\n---\n\n## Step 3: KeyValue Protobuf + Service Stub (Week 2, Days 1-2)\n\n### Goal\nDefine complete KeyValue protobuf API and generate server stubs.\n\n### Deliverables\n\n1. **Create KeyValue proto**:\n"})}),"\n",(0,r.jsx)(n.p,{children:"// proto/prism/keyvalue/v1/keyvalue.proto\nservice KeyValueService {\nrpc Put(PutRequest) returns (PutResponse);\nrpc Get(GetRequest) returns (GetResponse);\nrpc Delete(DeleteRequest) returns (DeleteResponse);\nrpc Scan(ScanRequest) returns (stream ScanResponse);\n}"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n2. **Create KeyValue types**:\n"})}),"\n",(0,r.jsx)(n.p,{children:"// proto/prism/keyvalue/v1/types.proto\nmessage Item {\nbytes key = 1;\nbytes value = 2;\nprism.common.ItemMetadata metadata = 3;\n}"}),"\n",(0,r.jsx)(n.p,{children:"message PutRequest {\nstring namespace = 1;\nstring id = 2;\nrepeated Item items = 3;\n}\n// ... etc"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n3. **Regenerate Rust code**:\n"})}),"\n",(0,r.jsx)(n.p,{children:"buf generate"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n4. **Implement stub service** (returns errors):\n"})}),"\n",(0,r.jsx)(n.p,{children:"// proxy/src/keyvalue/service.rs\npub struct KeyValueService;"}),"\n",(0,r.jsxs)(n.p,{children:["#[tonic::async_trait]\nimpl KeyValue for KeyValueService {\nasync fn put(&self, req: Request",(0,r.jsxs)(n.putrequest,{children:[") -> Result<Response",(0,r.jsx)(n.putresponse,{children:'> {\nErr(Status::unimplemented("put not yet implemented"))\n}\n// ... etc\n}'})]})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n5. **Wire into server**:\n"})}),"\n",(0,r.jsx)(n.p,{children:"Server::builder()\n.add_service(HealthServer::new(health_svc))\n.add_service(KeyValueServer::new(kv_svc))  // \u2190 New!\n.serve(addr)\n.await?;"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n### Success Criteria\n- \u2705 Protobuf compiles cleanly\n- \u2705 Rust code generates without errors\n- \u2705 Server starts with KeyValue service\n- \u2705 `grpcurl` can call `KeyValue/Put` (gets unimplemented error)\n\n### Files to Create/Update\n- `proto/prism/keyvalue/v1/keyvalue.proto` (~80 lines)\n- `proto/prism/keyvalue/v1/types.proto` (~120 lines)\n- `proxy/src/keyvalue/service.rs` (~100 lines)\n- `proxy/src/main.rs` (update: +5 lines)\n\n---\n\n## Step 4: SQLite Backend Implementation (Week 2, Days 3-5)\n\n### Goal\nImplement working KeyValue backend using SQLite for local testing.\n\n### Deliverables\n\n1. **Define backend trait**:\n"})}),"\n",(0,r.jsxs)(n.p,{children:["// proxy/src/backend/mod.rs\n#[async_trait]\npub trait KeyValueBackend: Send + Sync {\nasync fn put(&self, namespace: &str, id: &str, items: Vec",(0,r.jsxs)(n.item,{children:[") -> Result<()>;\nasync fn get(&self, namespace: &str, id: &str, keys: Vec<&[u8]>) -> Result<Vec",(0,r.jsxs)(n.item,{children:[">;\nasync fn delete(&self, namespace: &str, id: &str, keys: Vec<&[u8]>) -> Result<()>;\nasync fn scan(&self, namespace: &str, id: &str) -> Result<Vec",(0,r.jsx)(n.item,{children:">;\n}"})]})]})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n2. **Implement SQLite backend**:\n"})}),"\n",(0,r.jsx)(n.p,{children:"// proxy/src/backend/sqlite.rs\npub struct SqliteBackend {\npool: SqlitePool,\n}"}),"\n",(0,r.jsxs)(n.p,{children:["#[async_trait]\nimpl KeyValueBackend for SqliteBackend {\nasync fn put(&self, namespace: &str, id: &str, items: Vec",(0,r.jsx)(n.item,{children:") -> Result<()> {\nlet mut tx = self.pool.begin().await?;"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'    for item in items {\n        sqlx::query(\n            "INSERT OR REPLACE INTO kv (namespace, id, key, value) VALUES (?, ?, ?, ?)"\n        )\n        .bind(namespace)\n        .bind(id)\n        .bind(&item.key)\n        .bind(&item.value)\n        .execute(&mut tx)\n        .await?;\n    }\n\n    tx.commit().await?;\n    Ok(())\n}\n// ... etc\n'})}),"\n",(0,r.jsx)(n.p,{children:"}"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n3. **Create schema migration**:\n"})}),"\n",(0,r.jsx)(n.p,{children:"-- proxy/migrations/001_create_kv_table.sql\nCREATE TABLE IF NOT EXISTS kv (\nnamespace TEXT NOT NULL,\nid TEXT NOT NULL,\nkey BLOB NOT NULL,\nvalue BLOB NOT NULL,\ncreated_at INTEGER NOT NULL DEFAULT (unixepoch()),\nupdated_at INTEGER NOT NULL DEFAULT (unixepoch()),\nPRIMARY KEY (namespace, id, key)\n);"}),"\n",(0,r.jsx)(n.p,{children:"CREATE INDEX idx_kv_namespace ON kv(namespace);"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n4. **Wire backend into service**:\n"})}),"\n",(0,r.jsxs)(n.p,{children:["// proxy/src/keyvalue/service.rs\npub struct KeyValueService {\nbackend: Arc",(0,r.jsx)(n.dyn,{keyvaluebackend:"",children:",\n}"})]}),"\n",(0,r.jsxs)(n.p,{children:["#[tonic::async_trait]\nimpl KeyValue for KeyValueService {\nasync fn put(&self, req: Request",(0,r.jsxs)(n.putrequest,{children:[") -> Result<Response",(0,r.jsx)(n.putresponse,{children:"> {\nlet req = req.into_inner();\nself.backend.put(&req.namespace, &req.id, req.items).await?;\nOk(Response::new(PutResponse { success: true }))\n}\n// ... etc\n}"})]})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n5. **Add configuration**:\n"})}),"\n",(0,r.jsx)(n.h1,{id:"proxyconfigyaml",children:"proxy/config.yaml"}),"\n",(0,r.jsx)(n.p,{children:"database:\ntype: sqlite\npath: ./prism.db"}),"\n",(0,r.jsx)(n.p,{children:"logging:\nlevel: debug\nformat: json"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:'\n### Success Criteria\n- \u2705 Can put data: `grpcurl -d \'{"namespace":"test","id":"1","items":[{"key":"aGVsbG8=","value":"d29ybGQ="}]}\' localhost:8980 prism.keyvalue.v1.KeyValueService/Put`\n- \u2705 Can get data back with same value\n- \u2705 Data persists across server restarts\n- \u2705 All CRUD operations work (Put, Get, Delete, Scan)\n\n### Files to Create\n- `proxy/src/backend/mod.rs` (~50 lines)\n- `proxy/src/backend/sqlite.rs` (~250 lines)\n- `proxy/migrations/001_create_kv_table.sql` (~15 lines)\n- `proxy/config.yaml` (~20 lines)\n- `proxy/Cargo.toml` (update: add `sqlx`, `serde_yaml`)\n\n---\n\n## Step 5: Integration Tests + Local Stack (Week 3, Days 1-3)\n\n### Goal\nValidate end-to-end functionality with automated tests using real local backends.\n\n### Deliverables\n\n1. **Create integration test**:\n'})}),"\n",(0,r.jsx)(n.p,{children:'// proxy/tests/integration_test.rs\n#[tokio::test]\nasync fn test_put_get_roundtrip() {\nlet client = KeyValueClient::connect("http://".to_string() + "localhost:8980").await.unwrap();'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// Put\nlet put_req = PutRequest {\n    namespace: "test".to_string(),\n    id: "user123".to_string(),\n    items: vec![Item {\n        key: b"profile".to_vec(),\n        value: b"Alice".to_vec(),\n        metadata: None,\n    }],\n    item_priority_token: 0,\n};\nclient.put(put_req).await.unwrap();\n\n// Get\nlet get_req = GetRequest {\n    namespace: "test".to_string(),\n    id: "user123".to_string(),\n    predicate: Some(KeyPredicate {\n        predicate: Some(key_predicate::Predicate::MatchAll(MatchAll {})),\n    }),\n};\nlet response = client.get(get_req).await.unwrap().into_inner();\n\nassert_eq!(response.items.len(), 1);\nassert_eq!(response.items[0].key, b"profile");\nassert_eq!(response.items[0].value, b"Alice");\n'})}),"\n",(0,r.jsx)(n.p,{children:"}"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n2. **Enhance `docker-compose.test.yml`**:\n"})}),"\n",(0,r.jsx)(n.p,{children:'services:\nprism-proxy:\nbuild: ./proxy\nports:\n- "8980:8980"\ndepends_on:\n- postgres\nenvironment:\nDATABASE_URL: postgres://prism:prism_test_password@postgres/prism_test'}),"\n",(0,r.jsx)(n.p,{children:"postgres:\n# ... existing config ..."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n3. **Create test helper**:\n"})}),"\n",(0,r.jsxs)(n.p,{children:["// proxy/tests/common/mod.rs\npub struct TestFixture {\npub client: KeyValueClient",(0,r.jsx)(n.channel,{children:",\n}"})]}),"\n",(0,r.jsx)(n.p,{children:"impl TestFixture {\npub async fn new() -> Self {\n// Wait for server to be ready\ntokio::time::sleep(Duration::from_secs(1)).await;"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'    let client = KeyValueClient::connect("http://localhost:8980")\n        .await\n        .expect("Failed to connect");\n\n    Self { client }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"}"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n4. **Add CI workflow**:\n"})}),"\n",(0,r.jsx)(n.h1,{id:"githubworkflowstestyml",children:".github/workflows/test.yml"}),"\n",(0,r.jsx)(n.p,{children:"name: Tests"}),"\n",(0,r.jsx)(n.p,{children:"on: [push, pull_request]"}),"\n",(0,r.jsx)(n.p,{children:"jobs:\ntest:\nruns-on: ubuntu-latest\nsteps:\n- uses: actions/checkout@v3"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"  - name: Start local stack\n    run: python -m tooling.test.local-stack up\n\n  - name: Run unit tests\n    run: cargo test --lib\n\n  - name: Run integration tests\n    run: cargo test --test integration_test\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n### Success Criteria\n- \u2705 All integration tests pass locally\n- \u2705 Tests pass in CI\n- \u2705 Can run full test suite in < 60 seconds\n- \u2705 Tests clean up after themselves (no state leakage)\n\n### Files to Create\n- `proxy/tests/integration_test.rs` (~200 lines)\n- `proxy/tests/common/mod.rs` (~50 lines)\n- `.github/workflows/test.yml` (~40 lines)\n- `docker-compose.test.yml` (update: add prism-proxy service)\n\n---\n\n## Step 6: Postgres Backend + Documentation (Week 3-4, Days 4-7)\n\n### Goal\nProduction-ready Postgres backend with complete documentation.\n\n### Deliverables\n\n1. **Implement Postgres backend**:\n"})}),"\n",(0,r.jsx)(n.p,{children:"// proxy/src/backend/postgres.rs\npub struct PostgresBackend {\npool: PgPool,\n}"}),"\n",(0,r.jsxs)(n.p,{children:["#[async_trait]\nimpl KeyValueBackend for PostgresBackend {\nasync fn put(&self, namespace: &str, id: &str, items: Vec",(0,r.jsx)(n.item,{children:") -> Result<()> {\nlet mut tx = self.pool.begin().await?;"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'    for item in items {\n        sqlx::query(\n            "INSERT INTO kv (namespace, id, key, value, updated_at)\n             VALUES ($1, $2, $3, $4, NOW())\n             ON CONFLICT (namespace, id, key)\n             DO UPDATE SET value = EXCLUDED.value, updated_at = NOW()"\n        )\n        .bind(namespace)\n        .bind(id)\n        .bind(&item.key)\n        .bind(&item.value)\n        .execute(&mut tx)\n        .await?;\n    }\n\n    tx.commit().await?;\n    Ok(())\n}\n// ... etc (similar to SQLite but with Postgres-specific SQL)\n'})}),"\n",(0,r.jsx)(n.p,{children:"}"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n2. **Add connection pooling**:\n"})}),"\n",(0,r.jsx)(n.p,{children:"let pool = PgPoolOptions::new()\n.max_connections(20)\n.connect(&database_url)\n.await?;"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n3. **Create Postgres migrations**:\n"})}),"\n",(0,r.jsx)(n.p,{children:"-- proxy/migrations/postgres/001_create_kv_table.sql\nCREATE TABLE IF NOT EXISTS kv (\nnamespace VARCHAR(255) NOT NULL,\nid VARCHAR(255) NOT NULL,\nkey BYTEA NOT NULL,\nvalue BYTEA NOT NULL,\ncreated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\nupdated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\nPRIMARY KEY (namespace, id, key)\n);"}),"\n",(0,r.jsx)(n.p,{children:"CREATE INDEX idx_kv_namespace ON kv(namespace);\nCREATE INDEX idx_kv_id ON kv(namespace, id);"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n4. **Add integration tests for Postgres**:\n"})}),"\n",(0,r.jsx)(n.p,{children:'#[tokio::test]\nasync fn test_postgres_backend() {\nlet pool = PgPool::connect("postgres://prism:prism_test_password@localhost/prism_test")\n.await\n.unwrap();'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"let backend = PostgresBackend::new(pool);\n\n// Run same tests as SQLite\n// ... test put, get, delete, scan\n"})}),"\n",(0,r.jsx)(n.p,{children:"}"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n5. **Write documentation**:\n   - `docs/getting-started.md`: Quickstart guide\n   - `docs/api-reference.md`: gRPC API documentation\n   - `docs/deployment.md`: How to deploy Prism\n   - Update `README.md` with real examples\n\n### Success Criteria\n- \u2705 Postgres backend passes all integration tests\n- \u2705 Performance: 10k RPS sustained on laptop\n- \u2705 Connection pooling works correctly\n- \u2705 Documentation covers all key use cases\n- \u2705 Can deploy Prism with Postgres in production\n\n### Files to Create\n- `proxy/src/backend/postgres.rs` (~300 lines)\n- `proxy/migrations/postgres/001_create_kv_table.sql` (~20 lines)\n- `proxy/tests/postgres_test.rs` (~150 lines)\n- `docs/getting-started.md` (~200 lines)\n- `docs/api-reference.md` (~300 lines)\n- `docs/deployment.md` (~150 lines)\n\n---\n\n## Summary Timeline\n\n| Week | Days | Step | Deliverable | Status |\n|------|------|------|-------------|--------|\n| 1 | 1-3 | Step 1 | Protobuf foundation | \ud83d\udccb Planned |\n| 1 | 4-5 | Step 2 | Rust proxy skeleton | \ud83d\udccb Planned |\n| 2 | 1-2 | Step 3 | KeyValue protobuf + stubs | \ud83d\udccb Planned |\n| 2 | 3-5 | Step 4 | SQLite backend | \ud83d\udccb Planned |\n| 3 | 1-3 | Step 5 | Integration tests + CI | \ud83d\udccb Planned |\n| 3-4 | 4-7 | Step 6 | Postgres + docs | \ud83d\udccb Planned |\n\n**Total**: ~4 weeks to production-ready KeyValue abstraction\n\n## Success Metrics\n\nAfter completing all 6 steps, we should have:\n\n- \u2705 **Working system**: KeyValue abstraction with SQLite + Postgres\n- \u2705 **Performance**: P99 < 10ms, 10k RPS sustained\n- \u2705 **Testing**: 90%+ code coverage, all tests green\n- \u2705 **Documentation**: Complete getting-started guide\n- \u2705 **Deployable**: Can deploy to production\n- \u2705 **Validated**: Core architecture proven with real code\n\n## Next Steps After Step 6\n\nOnce the foundation is solid, subsequent phases:\n\n**Phase 2** (Weeks 5-8):\n- TimeSeries abstraction + Kafka backend\n- OpenTelemetry observability\n- Shadow traffic support\n- Production deployment\n\n**Phase 3** (Weeks 9-12):\n- Graph abstraction + Neptune backend\n- Client-originated configuration\n- Admin UI basics\n- Auto-provisioning\n\n## Alternatives Considered\n\n### Big Bang Approach\n- Implement all abstractions (KeyValue, TimeSeries, Graph) at once\n- **Rejected**: Too risky, can't validate assumptions early\n\n### Vertical Slice\n- Implement one end-to-end use case (e.g., user profiles)\n- **Rejected**: Doesn't validate platform generality\n\n### Backend-First\n- Implement all backends for KeyValue before moving to TimeSeries\n- **Rejected**: Diminishing returns; SQLite + Postgres sufficient to validate\n\n## References\n\n- ADR-001 through ADR-010 (all previous architectural decisions)\n- [Protobuf Data Model Plan](https://github.com/jrepp/prism-data-layer/blob/main/docs-cms/protobuf-data-model-plan.md)\n- [PRD](https://github.com/jrepp/prism-data-layer/blob/main/PRD.md)\n\n## Revision History\n\n- 2025-10-05: Initial roadmap and acceptance\n\n"})})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);