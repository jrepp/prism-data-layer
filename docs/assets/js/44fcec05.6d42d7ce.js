"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[7487],{2109:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"adr-047","title":"OpenTelemetry Tracing Integration","description":"Context","source":"@site/../docs-cms/adr/adr-047-opentelemetry-tracing-integration.md","sourceDirName":".","slug":"/adr-047","permalink":"/prism-data-layer/adr/adr-047","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/adr-047-opentelemetry-tracing-integration.md","tags":[{"inline":true,"label":"observability","permalink":"/prism-data-layer/adr/tags/observability"},{"inline":true,"label":"tracing","permalink":"/prism-data-layer/adr/tags/tracing"},{"inline":true,"label":"opentelemetry","permalink":"/prism-data-layer/adr/tags/opentelemetry"},{"inline":true,"label":"go","permalink":"/prism-data-layer/adr/tags/go"},{"inline":true,"label":"rust","permalink":"/prism-data-layer/adr/tags/rust"},{"inline":true,"label":"plugin","permalink":"/prism-data-layer/adr/tags/plugin"}],"version":"current","frontMatter":{"date":"2025-10-09T00:00:00.000Z","deciders":"Core Team","doc_uuid":"2cbe9b6e-ecf7-4c00-9c7c-dae8aebaa5cf","id":"adr-047","project_id":"prism-data-layer","status":"Accepted","tags":["observability","tracing","opentelemetry","go","rust","plugin"],"title":"OpenTelemetry Tracing Integration"},"sidebar":"adrSidebar","previous":{"title":"Dex IDP for Local Identity Testing \u2022 ADR-046","permalink":"/prism-data-layer/adr/adr-046"},"next":{"title":"Local Signoz Instance for Observability Testing \u2022 ADR-048","permalink":"/prism-data-layer/adr/adr-048"}}');var a=n(74848),i=n(28453);const s={date:new Date("2025-10-09T00:00:00.000Z"),deciders:"Core Team",doc_uuid:"2cbe9b6e-ecf7-4c00-9c7c-dae8aebaa5cf",id:"adr-047",project_id:"prism-data-layer",status:"Accepted",tags:["observability","tracing","opentelemetry","go","rust","plugin"],title:"OpenTelemetry Tracing Integration"},o=void 0,l={},c=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Why End-to-End Tracing?",id:"why-end-to-end-tracing",level:3},{value:"Implementation",id:"implementation",level:2},{value:"1. Rust Proxy Integration",id:"1-rust-proxy-integration",level:3},{value:"Proxy Initialization",id:"proxy-initialization",level:4},{value:"gRPC Request Handler",id:"grpc-request-handler",level:4},{value:"2. Go Plugin Core Integration",id:"2-go-plugin-core-integration",level:3},{value:"Plugin Core Library (<code>plugins/core/tracing</code>)",id:"plugin-core-library-pluginscoretracing",level:4},{value:"Plugin gRPC Interceptor",id:"plugin-grpc-interceptor",level:4},{value:"3. Plugin Implementation Example",id:"3-plugin-implementation-example",level:3},{value:"4. Backend Trace Context Propagation",id:"4-backend-trace-context-propagation",level:3},{value:"PostgreSQL (SQL Comments)",id:"postgresql-sql-comments",level:4},{value:"Redis (Tags)",id:"redis-tags",level:4},{value:"5. Testing Tracing",id:"5-testing-tracing",level:3},{value:"Alternatives Considered",id:"alternatives-considered",level:2},{value:"1. Custom Tracing Implementation",id:"1-custom-tracing-implementation",level:3},{value:"2. Jaeger-Only (No OpenTelemetry)",id:"2-jaeger-only-no-opentelemetry",level:3},{value:"3. No Plugin Tracing",id:"3-no-plugin-tracing",level:3},{value:"4. Separate Trace IDs per Component",id:"4-separate-trace-ids-per-component",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Implementation Notes",id:"implementation-notes",level:2},{value:"Deployment Configuration",id:"deployment-configuration",level:3},{value:"Trace Example (Jaeger UI)",id:"trace-example-jaeger-ui",level:3}];function p(e){const t={code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h2,{id:"context",children:"Context"}),"\n",(0,a.jsx)(t.p,{children:"Prism's request flow spans multiple components:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Client"})," (application)"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Proxy"})," (Rust) - gRPC server, authentication, routing"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Plugin"})," (Go/Rust) - Backend-specific protocol implementation"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Backend"})," (PostgreSQL, Kafka, Redis, etc.) - Data storage"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Debugging issues requires understanding the full request path. Without distributed tracing:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"No visibility"})," into plugin-level operations"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Can't correlate"})," proxy logs with plugin logs"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Hard to identify"})," bottlenecks (is it proxy routing? plugin processing? backend query?)"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"No end-to-end latency"})," breakdown"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"ADR-008 established OpenTelemetry as our observability strategy. This ADR details the implementation of distributed tracing across Rust proxy and Go plugins, with trace context propagation at every hop."}),"\n",(0,a.jsx)(t.h2,{id:"decision",children:"Decision"}),"\n",(0,a.jsxs)(t.p,{children:["Implement ",(0,a.jsx)(t.strong,{children:"end-to-end OpenTelemetry tracing"})," across all Prism components:"]}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Rust Proxy"}),": Use ",(0,a.jsx)(t.code,{children:"tracing"})," + ",(0,a.jsx)(t.code,{children:"tracing-opentelemetry"})," crates"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Go Plugins"}),": Use ",(0,a.jsx)(t.code,{children:"go.opentelemetry.io/otel"})," in plugin core library"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Trace Propagation"}),": W3C Trace Context via gRPC metadata"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Plugin Core Integration"}),": Automatic tracing middleware in ",(0,a.jsx)(t.code,{children:"plugins/core"})," package"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Sampling Strategy"}),": Adaptive sampling (100% errors, 100% slow requests, 1% normal)"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"rationale",children:"Rationale"}),"\n",(0,a.jsx)(t.h3,{id:"why-end-to-end-tracing",children:"Why End-to-End Tracing?"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Problem"}),": Request takes 150ms. Where is the time spent?"]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"With tracing"}),":\nprism.handle_request           [150ms total]\n\u251c\u2500 prism.auth.verify            [5ms]\n\u251c\u2500 prism.routing.select_plugin  [2ms]\n\u251c\u2500 plugin.postgres.execute      [140ms]  \u2190 Bottleneck found!\n\u2502  \u251c\u2500 plugin.pool.acquire       [3ms]\n\u2502  \u2514\u2500 postgres.query            [137ms]\n\u2502     \u2514\u2500 SQL: SELECT * FROM... [135ms]\n\u2514\u2500 prism.response.serialize     [3ms]"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-text",children:"\n### Architecture\n\n"})}),"\n",(0,a.jsx)(t.p,{children:"sequenceDiagram\nparticipant Client\nparticipant Proxy as Rust Proxy\nparticipant Plugin as Go Plugin\nparticipant Backend as Backend (PostgreSQL)"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"Client->>Proxy: gRPC Request<br/>(traceparent header)\nNote over Proxy: Extract trace context<br/>Create root span<br/>trace_id: abc123\n\nProxy->>Proxy: Auth span<br/>(parent: abc123)\nProxy->>Proxy: Routing span<br/>(parent: abc123)\n\nProxy->>Plugin: gRPC Plugin Call<br/>(inject traceparent)\nNote over Plugin: Extract trace context<br/>Create child span<br/>same trace_id: abc123\n\nPlugin->>Backend: PostgreSQL Query<br/>(with trace context)\nBackend--\x3e>Plugin: Result\n\nPlugin--\x3e>Proxy: gRPC Response\nProxy--\x3e>Client: gRPC Response\n\nNote over Client,Backend: All spans linked by<br/>trace_id: abc123\n"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-text",children:"\n### Trace Context Propagation\n\nUse **W3C Trace Context** standard:\n\ntraceparent: 00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01\n             \u2502  \u2502                                \u2502                \u2514\u2500 flags (sampled)\n             \u2502  \u2502                                \u2514\u2500 span_id (16 hex)\n             \u2502  \u2514\u2500 trace_id (32 hex)\n             \u2514\u2500 version\n"})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Propagation Flow"}),":"]}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["Client \u2192 Proxy: gRPC metadata ",(0,a.jsx)(t.code,{children:"traceparent"})]}),"\n",(0,a.jsxs)(t.li,{children:["Proxy \u2192 Plugin: gRPC metadata ",(0,a.jsx)(t.code,{children:"traceparent"})]}),"\n",(0,a.jsx)(t.li,{children:"Plugin \u2192 Backend: SQL comments or protocol-specific tags"}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"implementation",children:"Implementation"}),"\n",(0,a.jsx)(t.h3,{id:"1-rust-proxy-integration",children:"1. Rust Proxy Integration"}),"\n",(0,a.jsx)(t.h4,{id:"proxy-initialization",children:"Proxy Initialization"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:'// proxy/src/telemetry.rs\nuse opentelemetry::sdk::trace::{self, Tracer, Sampler};\nuse opentelemetry::global;\nuse tracing_subscriber::{layer::SubscriberExt, Registry, EnvFilter};\nuse tracing_opentelemetry::OpenTelemetryLayer;\n\npub fn init_telemetry() -> Result<()> {\n    // Configure OpenTelemetry tracer with Jaeger exporter\n    let tracer = opentelemetry_jaeger::new_pipeline()\n        .with_service_name("prism-proxy")\n        .with_agent_endpoint("jaeger:6831")\n        .with_trace_config(\n            trace::config()\n                .with_sampler(AdaptiveSampler::new())\n                .with_resource(opentelemetry::sdk::Resource::new(vec![\n                    opentelemetry::KeyValue::new("service.name", "prism-proxy"),\n                    opentelemetry::KeyValue::new("service.version", env!("CARGO_PKG_VERSION")),\n                ]))\n        )\n        .install_batch(opentelemetry::runtime::Tokio)?;\n\n    // Create OpenTelemetry tracing layer\n    let telemetry_layer = OpenTelemetryLayer::new(tracer);\n\n    // Combine with structured logging\n    let subscriber = Registry::default()\n        .with(EnvFilter::from_default_env())\n        .with(tracing_subscriber::fmt::layer().json())\n        .with(telemetry_layer);\n\n    tracing::subscriber::set_global_default(subscriber)?;\n\n    Ok(())\n}\n\n/// Adaptive sampler: 100% errors, 100% slow (>100ms), 1% normal\npub struct AdaptiveSampler;\n\nimpl AdaptiveSampler {\n    pub fn new() -> Self {\n        Self\n    }\n}\n\nimpl Sampler for AdaptiveSampler {\n    fn should_sample(\n        &self,\n        parent_context: Option<&opentelemetry::Context>,\n        trace_id: opentelemetry::trace::TraceId,\n        name: &str,\n        _span_kind: &opentelemetry::trace::SpanKind,\n        attributes: &[opentelemetry::KeyValue],\n        _links: &[opentelemetry::trace::Link],\n    ) -> opentelemetry::sdk::trace::SamplingResult {\n        use opentelemetry::sdk::trace::SamplingDecision;\n\n        // Always sample if parent is sampled\n        if let Some(ctx) = parent_context {\n            if ctx.span().span_context().is_sampled() {\n                return SamplingResult {\n                    decision: SamplingDecision::RecordAndSample,\n                    attributes: vec![],\n                    trace_state: Default::default(),\n                };\n            }\n        }\n\n        // Check for error attribute\n        let has_error = attributes.iter()\n            .any(|kv| kv.key.as_str() == "error" && kv.value.as_str() == "true");\n\n        if has_error {\n            return SamplingResult {\n                decision: SamplingDecision::RecordAndSample,\n                attributes: vec![],\n                trace_state: Default::default(),\n            };\n        }\n\n        // Check for high latency (set by instrumentation)\n        let is_slow = attributes.iter()\n            .any(|kv| kv.key.as_str() == "slow" && kv.value.as_str() == "true");\n\n        if is_slow {\n            return SamplingResult {\n                decision: SamplingDecision::RecordAndSample,\n                attributes: vec![],\n                trace_state: Default::default(),\n            };\n        }\n\n        // Otherwise 1% sample rate\n        let sample = (trace_id.to_u128() % 100) == 0;\n\n        SamplingResult {\n            decision: if sample {\n                SamplingDecision::RecordAndSample\n            } else {\n                SamplingDecision::Drop\n            },\n            attributes: vec![],\n            trace_state: Default::default(),\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(t.h4,{id:"grpc-request-handler",children:"gRPC Request Handler"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:'// proxy/src/grpc/handler.rs\nuse tonic::{Request, Response, Status};\nuse opentelemetry::propagation::{Extractor, Injector, TextMapPropagator};\nuse opentelemetry_sdk::propagation::TraceContextPropagator;\nuse tracing::{instrument, info, error};\n\n/// Extract trace context from gRPC metadata\nstruct MetadataExtractor<\'a>(&\'a tonic::metadata::MetadataMap);\n\nimpl<\'a> Extractor for MetadataExtractor<\'a> {\n    fn get(&self, key: &str) -> Option<&str> {\n        self.0.get(key).and_then(|v| v.to_str().ok())\n    }\n\n    fn keys(&self) -> Vec<&str> {\n        self.0.keys().map(|k| k.as_str()).collect()\n    }\n}\n\n/// Inject trace context into gRPC metadata\nstruct MetadataInjector<\'a>(&\'a mut tonic::metadata::MetadataMap);\n\nimpl<\'a> Injector for MetadataInjector<\'a> {\n    fn set(&mut self, key: &str, value: String) {\n        if let Ok(metadata_value) = tonic::metadata::MetadataValue::try_from(&value) {\n            self.0.insert(\n                tonic::metadata::MetadataKey::from_bytes(key.as_bytes()).unwrap(),\n                metadata_value\n            );\n        }\n    }\n}\n\n#[instrument(\n    skip(request, plugin_client),\n    fields(\n        request_id = %request.get_ref().request_id,\n        namespace = %request.get_ref().namespace,\n        operation = %request.get_ref().operation,\n        trace_id = tracing::field::Empty,\n    )\n)]\npub async fn handle_data_request(\n    request: Request<DataRequest>,\n    plugin_client: &PluginClient,\n) -> Result<Response<DataResponse>, Status> {\n    // Extract trace context from incoming request\n    let propagator = TraceContextPropagator::new();\n    let parent_context = propagator.extract(&MetadataExtractor(request.metadata()));\n\n    // Set current trace context\n    let span = tracing::Span::current();\n    if let Some(span_ref) = parent_context.span().span_context().trace_id().to_string() {\n        span.record("trace_id", &tracing::field::display(&span_ref));\n    }\n\n    info!("Processing data request");\n\n    // Create child span for plugin call\n    let plugin_response = {\n        let _plugin_span = tracing::info_span!(\n            "plugin.execute",\n            plugin = "postgres",\n            backend = "postgresql"\n        ).entered();\n\n        // Inject trace context into plugin request metadata\n        let mut plugin_metadata = tonic::metadata::MetadataMap::new();\n        let current_context = opentelemetry::Context::current();\n        propagator.inject_context(&current_context, &mut MetadataInjector(&mut plugin_metadata));\n\n        let mut plugin_req = tonic::Request::new(request.into_inner());\n        *plugin_req.metadata_mut() = plugin_metadata;\n\n        plugin_client.execute(plugin_req).await\n            .map_err(|e| {\n                error!(error = %e, "Plugin execution failed");\n                Status::internal("Plugin error")\n            })?\n    };\n\n    info!("Request completed successfully");\n    Ok(plugin_response)\n}\n'})}),"\n",(0,a.jsx)(t.h3,{id:"2-go-plugin-core-integration",children:"2. Go Plugin Core Integration"}),"\n",(0,a.jsxs)(t.h4,{id:"plugin-core-library-pluginscoretracing",children:["Plugin Core Library (",(0,a.jsx)(t.code,{children:"plugins/core/tracing"}),")"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-go",children:'// plugins/core/tracing/tracing.go\npackage tracing\n\nimport (\n\t"context"\n\t"fmt"\n\n\t"go.opentelemetry.io/otel"\n\t"go.opentelemetry.io/otel/attribute"\n\t"go.opentelemetry.io/otel/exporters/jaeger"\n\t"go.opentelemetry.io/otel/propagation"\n\t"go.opentelemetry.io/otel/sdk/resource"\n\tsdktrace "go.opentelemetry.io/otel/sdk/trace"\n\tsemconv "go.opentelemetry.io/otel/semconv/v1.17.0"\n\t"go.opentelemetry.io/otel/trace"\n\t"google.golang.org/grpc/metadata"\n)\n\n// InitTracer initializes OpenTelemetry tracing for a plugin\nfunc InitTracer(pluginName, pluginVersion string) (func(context.Context) error, error) {\n\t// Create Jaeger exporter\n\texporter, err := jaeger.New(jaeger.WithAgentEndpoint())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf("failed to create Jaeger exporter: %w", err)\n\t}\n\n\t// Create trace provider\n\ttp := sdktrace.NewTracerProvider(\n\t\tsdktrace.WithBatcher(exporter),\n\t\tsdktrace.WithResource(resource.NewWithAttributes(\n\t\t\tsemconv.SchemaURL,\n\t\t\tsemconv.ServiceNameKey.String(fmt.Sprintf("prism-plugin-%s", pluginName)),\n\t\t\tsemconv.ServiceVersionKey.String(pluginVersion),\n\t\t\tattribute.String("plugin.name", pluginName),\n\t\t)),\n\t\tsdktrace.WithSampler(newAdaptiveSampler()),\n\t)\n\n\t// Set global trace provider\n\totel.SetTracerProvider(tp)\n\n\t// Set global propagator (W3C Trace Context)\n\totel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(\n\t\tpropagation.TraceContext{},\n\t\tpropagation.Baggage{},\n\t))\n\n\t// Return cleanup function\n\treturn tp.Shutdown, nil\n}\n\n// ExtractTraceContext extracts trace context from gRPC incoming metadata\nfunc ExtractTraceContext(ctx context.Context) context.Context {\n\tmd, ok := metadata.FromIncomingContext(ctx)\n\tif !ok {\n\t\treturn ctx\n\t}\n\n\t// Create propagator\n\tpropagator := otel.GetTextMapPropagator()\n\n\t// Extract trace context from metadata\n\treturn propagator.Extract(ctx, &metadataSupplier{md})\n}\n\n// InjectTraceContext injects trace context into gRPC outgoing metadata\nfunc InjectTraceContext(ctx context.Context) context.Context {\n\tmd := metadata.MD{}\n\n\t// Create propagator\n\tpropagator := otel.GetTextMapPropagator()\n\n\t// Inject trace context into metadata\n\tpropagator.Inject(ctx, &metadataSupplier{md})\n\n\treturn metadata.NewOutgoingContext(ctx, md)\n}\n\n// metadataSupplier implements TextMapCarrier for gRPC metadata\ntype metadataSupplier struct {\n\tmetadata metadata.MD\n}\n\nfunc (s *metadataSupplier) Get(key string) string {\n\tvalues := s.metadata.Get(key)\n\tif len(values) == 0 {\n\t\treturn ""\n\t}\n\treturn values[0]\n}\n\nfunc (s *metadataSupplier) Set(key, value string) {\n\ts.metadata.Set(key, value)\n}\n\nfunc (s *metadataSupplier) Keys() []string {\n\tkeys := make([]string, 0, len(s.metadata))\n\tfor k := range s.metadata {\n\t\tkeys = append(keys, k)\n\t}\n\treturn keys\n}\n\n// adaptiveSampler implements same logic as Rust proxy\ntype adaptiveSampler struct {\n\tfallback sdktrace.Sampler\n}\n\nfunc newAdaptiveSampler() sdktrace.Sampler {\n\treturn &adaptiveSampler{\n\t\tfallback: sdktrace.TraceIDRatioBased(0.01), // 1% for normal requests\n\t}\n}\n\nfunc (s *adaptiveSampler) ShouldSample(p sdktrace.SamplingParameters) sdktrace.SamplingResult {\n\t// Always sample if parent is sampled\n\tif p.ParentContext.IsSampled() {\n\t\treturn sdktrace.SamplingResult{\n\t\t\tDecision:   sdktrace.RecordAndSample,\n\t\t\tTracestate: trace.SpanContextFromContext(p.ParentContext).TraceState(),\n\t\t}\n\t}\n\n\t// Check for error attribute\n\tfor _, attr := range p.Attributes {\n\t\tif attr.Key == "error" && attr.Value.AsString() == "true" {\n\t\t\treturn sdktrace.SamplingResult{\n\t\t\t\tDecision:   sdktrace.RecordAndSample,\n\t\t\t\tTracestate: trace.SpanContextFromContext(p.ParentContext).TraceState(),\n\t\t\t}\n\t\t}\n\t}\n\n\t// Fallback to ratio-based sampling (1%)\n\treturn s.fallback.ShouldSample(p)\n}\n\nfunc (s *adaptiveSampler) Description() string {\n\treturn "AdaptiveSampler{errors=100%, slow=100%, normal=1%}"\n}\n'})}),"\n",(0,a.jsx)(t.h4,{id:"plugin-grpc-interceptor",children:"Plugin gRPC Interceptor"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-go",children:'// plugins/core/tracing/interceptor.go\npackage tracing\n\nimport (\n\t"context"\n\n\t"go.opentelemetry.io/otel"\n\t"go.opentelemetry.io/otel/attribute"\n\t"go.opentelemetry.io/otel/codes"\n\t"go.opentelemetry.io/otel/trace"\n\t"google.golang.org/grpc"\n)\n\n// UnaryServerInterceptor creates a gRPC interceptor for automatic tracing\nfunc UnaryServerInterceptor(pluginName string) grpc.UnaryServerInterceptor {\n\ttracer := otel.Tracer(fmt.Sprintf("prism-plugin-%s", pluginName))\n\n\treturn func(\n\t\tctx context.Context,\n\t\treq interface{},\n\t\tinfo *grpc.UnaryServerInfo,\n\t\thandler grpc.UnaryHandler,\n\t) (interface{}, error) {\n\t\t// Extract trace context from incoming metadata\n\t\tctx = ExtractTraceContext(ctx)\n\n\t\t// Start new span\n\t\tctx, span := tracer.Start(ctx, info.FullMethod,\n\t\t\ttrace.WithSpanKind(trace.SpanKindServer),\n\t\t\ttrace.WithAttributes(\n\t\t\t\tattribute.String("rpc.system", "grpc"),\n\t\t\t\tattribute.String("rpc.service", pluginName),\n\t\t\t\tattribute.String("rpc.method", info.FullMethod),\n\t\t\t),\n\t\t)\n\t\tdefer span.End()\n\n\t\t// Call handler\n\t\tresp, err := handler(ctx, req)\n\n\t\tif err != nil {\n\t\t\tspan.RecordError(err)\n\t\t\tspan.SetStatus(codes.Error, err.Error())\n\t\t} else {\n\t\t\tspan.SetStatus(codes.Ok, "")\n\t\t}\n\n\t\treturn resp, err\n\t}\n}\n'})}),"\n",(0,a.jsx)(t.h3,{id:"3-plugin-implementation-example",children:"3. Plugin Implementation Example"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-go",children:'// plugins/postgres/main.go\npackage main\n\nimport (\n\t"context"\n\t"log"\n\n\t"github.com/jrepp/prism-data-layer/plugins/core/tracing"\n\t"go.opentelemetry.io/otel"\n\t"go.opentelemetry.io/otel/attribute"\n\t"google.golang.org/grpc"\n)\n\nfunc main() {\n\t// Initialize tracing\n\tshutdown, err := tracing.InitTracer("postgres", "1.0.0")\n\tif err != nil {\n\t\tlog.Fatalf("Failed to initialize tracing: %v", err)\n\t}\n\tdefer shutdown(context.Background())\n\n\t// Create gRPC server with tracing interceptor\n\tserver := grpc.NewServer(\n\t\tgrpc.UnaryInterceptor(tracing.UnaryServerInterceptor("postgres")),\n\t)\n\n\t// Register plugin service\n\tRegisterPluginService(server, &PostgresPlugin{})\n\n\t// Start server...\n}\n\n// PostgresPlugin implements plugin with tracing\ntype PostgresPlugin struct {\n\ttracer trace.Tracer\n}\n\nfunc (p *PostgresPlugin) Execute(ctx context.Context, req *ExecuteRequest) (*ExecuteResponse, error) {\n\t// Trace context automatically extracted by interceptor\n\t// Create child span for database operation\n\ttracer := otel.Tracer("prism-plugin-postgres")\n\tctx, span := tracer.Start(ctx, "postgres.query",\n\t\ttrace.WithAttributes(\n\t\t\tattribute.String("db.system", "postgresql"),\n\t\t\tattribute.String("db.operation", req.Operation),\n\t\t\tattribute.String("db.table", req.Table),\n\t\t),\n\t)\n\tdefer span.End()\n\n\t// Execute query (trace context propagated)\n\tresult, err := p.db.QueryContext(ctx, req.Query)\n\tif err != nil {\n\t\tspan.RecordError(err)\n\t\treturn nil, err\n\t}\n\n\tspan.SetAttributes(attribute.Int("db.rows", result.RowsAffected))\n\treturn &ExecuteResponse{Data: result}, nil\n}\n'})}),"\n",(0,a.jsx)(t.h3,{id:"4-backend-trace-context-propagation",children:"4. Backend Trace Context Propagation"}),"\n",(0,a.jsx)(t.h4,{id:"postgresql-sql-comments",children:"PostgreSQL (SQL Comments)"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-go",children:'// Inject trace context as SQL comment\nfunc addTraceContextToQuery(ctx context.Context, query string) string {\n\tspanCtx := trace.SpanContextFromContext(ctx)\n\tif !spanCtx.IsValid() {\n\t\treturn query\n\t}\n\n\tcomment := fmt.Sprintf(\n\t\t"/* traceparent=\'%s\' */",\n\t\tspanCtx.TraceID().String(),\n\t)\n\n\treturn comment + " " + query\n}\n\n// Usage\nquery := "SELECT * FROM users WHERE id = $1"\ntracedQuery := addTraceContextToQuery(ctx, query)\n// Result: /* traceparent=\'0af765...\' */ SELECT * FROM users WHERE id = $1\n'})}),"\n",(0,a.jsx)(t.h4,{id:"redis-tags",children:"Redis (Tags)"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-go",children:'// Add trace context to Redis commands\nfunc executeWithTracing(ctx context.Context, cmd string, args ...interface{}) error {\n\tspanCtx := trace.SpanContextFromContext(ctx)\n\n\t// Add trace_id as tag\n\tif spanCtx.IsValid() {\n\t\targs = append(args, "trace_id", spanCtx.TraceID().String())\n\t}\n\n\treturn redisClient.Do(ctx, cmd, args...)\n}\n'})}),"\n",(0,a.jsx)(t.h3,{id:"5-testing-tracing",children:"5. Testing Tracing"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-go",children:'// plugins/core/tracing/tracing_test.go\npackage tracing_test\n\nimport (\n\t"context"\n\t"testing"\n\n\t"github.com/jrepp/prism-data-layer/plugins/core/tracing"\n\t"go.opentelemetry.io/otel"\n\t"go.opentelemetry.io/otel/sdk/trace"\n\t"go.opentelemetry.io/otel/sdk/trace/tracetest"\n\t"google.golang.org/grpc/metadata"\n)\n\nfunc TestTraceContextPropagation(t *testing.T) {\n\t// Create in-memory span recorder\n\tsr := tracetest.NewSpanRecorder()\n\ttp := trace.NewTracerProvider(trace.WithSpanProcessor(sr))\n\totel.SetTracerProvider(tp)\n\n\t// Create parent span\n\tctx := context.Background()\n\ttracer := tp.Tracer("test")\n\tctx, parentSpan := tracer.Start(ctx, "parent")\n\tdefer parentSpan.End()\n\n\t// Inject trace context into metadata\n\tctx = tracing.InjectTraceContext(ctx)\n\n\t// Simulate gRPC call - extract on receiver side\n\tmd, _ := metadata.FromOutgoingContext(ctx)\n\treceiverCtx := metadata.NewIncomingContext(context.Background(), md)\n\treceiverCtx = tracing.ExtractTraceContext(receiverCtx)\n\n\t// Create child span in receiver\n\t_, childSpan := tracer.Start(receiverCtx, "child")\n\tchildSpan.End()\n\n\t// Verify trace lineage\n\tspans := sr.Ended()\n\tif len(spans) != 2 {\n\t\tt.Fatalf("Expected 2 spans, got %d", len(spans))\n\t}\n\n\tparentTraceID := spans[0].SpanContext().TraceID()\n\tchildTraceID := spans[1].SpanContext().TraceID()\n\n\tif parentTraceID != childTraceID {\n\t\tt.Errorf("Child span has different trace ID: parent=%s, child=%s",\n\t\t\tparentTraceID, childTraceID)\n\t}\n\n\tif spans[1].Parent().SpanID() != spans[0].SpanContext().SpanID() {\n\t\tt.Error("Child span not linked to parent")\n\t}\n}\n'})}),"\n",(0,a.jsx)(t.h2,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,a.jsx)(t.h3,{id:"1-custom-tracing-implementation",children:"1. Custom Tracing Implementation"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Pros"}),": Full control, minimal dependencies"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Cons"}),": Reinventing the wheel, no ecosystem, hard to maintain"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Rejected"}),": OpenTelemetry is industry standard"]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"2-jaeger-only-no-opentelemetry",children:"2. Jaeger-Only (No OpenTelemetry)"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Pros"}),": Simpler, direct Jaeger integration"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Cons"}),": Vendor lock-in, no metrics/logs correlation"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Rejected"}),": OpenTelemetry provides vendor neutrality"]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"3-no-plugin-tracing",children:"3. No Plugin Tracing"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Pros"}),": Simpler plugin implementation"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Cons"}),": No visibility into plugin internals, hard to debug"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Rejected"}),": Plugin performance is critical to debug"]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"4-separate-trace-ids-per-component",children:"4. Separate Trace IDs per Component"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Pros"}),": Simpler (no context propagation)"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Cons"}),": Can't correlate proxy and plugin spans"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Rejected"}),": End-to-end correlation essential"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"consequences",children:"Consequences"}),"\n",(0,a.jsx)(t.h3,{id:"positive",children:"Positive"}),"\n",(0,a.jsxs)(t.p,{children:["\u2705 ",(0,a.jsx)(t.strong,{children:"Complete Visibility"}),": Full request path from client to backend\n\u2705 ",(0,a.jsx)(t.strong,{children:"Bottleneck Identification"}),": Know exactly where time is spent\n\u2705 ",(0,a.jsx)(t.strong,{children:"Cross-Language Tracing"}),": Rust proxy + Go plugins seamlessly connected\n\u2705 ",(0,a.jsx)(t.strong,{children:"Production Debugging"}),": Trace sampling captures errors and slow requests\n\u2705 ",(0,a.jsx)(t.strong,{children:"Plugin Core Simplicity"}),": Automatic tracing via interceptor, minimal plugin code"]}),"\n",(0,a.jsx)(t.h3,{id:"negative",children:"Negative"}),"\n",(0,a.jsxs)(t.p,{children:["\u274c ",(0,a.jsx)(t.strong,{children:"Resource Overhead"}),": Tracing adds CPU/memory cost (~2-5%)"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.em,{children:"Mitigation"}),": Adaptive sampling (1% normal requests)"]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["\u274c ",(0,a.jsx)(t.strong,{children:"Complexity"}),": Developers must understand trace context propagation"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.em,{children:"Mitigation"}),": Plugin core library handles propagation automatically"]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["\u274c ",(0,a.jsx)(t.strong,{children:"Storage Cost"}),": Traces require storage (Jaeger/Tempo backend)"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.em,{children:"Mitigation"}),": Retention policies (7 days default)"]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"neutral",children:"Neutral"}),"\n",(0,a.jsxs)(t.p,{children:["\u26aa ",(0,a.jsx)(t.strong,{children:"Learning Curve"}),": Team must learn OpenTelemetry concepts"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Industry-standard skill, valuable beyond Prism"}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["\u26aa ",(0,a.jsx)(t.strong,{children:"Backend-Specific Propagation"}),": Each backend (PostgreSQL, Redis) needs custom trace injection"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"One-time implementation per backend type"}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,a.jsx)(t.h3,{id:"deployment-configuration",children:"Deployment Configuration"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:'# docker-compose.yaml\nservices:\n  jaeger:\n    image: jaegertracing/all-in-one:latest\n    ports:\n      - "16686:16686"  # Jaeger UI\n      - "6831:6831/udp"  # Jaeger agent (UDP)\n    environment:\n      COLLECTOR_ZIPKIN_HOST_PORT: ":9411"\n\n  prism-proxy:\n    image: prism/proxy:latest\n    environment:\n      OTEL_EXPORTER_JAEGER_AGENT_HOST: jaeger\n      OTEL_EXPORTER_JAEGER_AGENT_PORT: 6831\n      OTEL_SERVICE_NAME: prism-proxy\n    depends_on:\n      - jaeger\n\n  postgres-plugin:\n    image: prism/plugin-postgres:latest\n    environment:\n      OTEL_EXPORTER_JAEGER_AGENT_HOST: jaeger\n      OTEL_EXPORTER_JAEGER_AGENT_PORT: 6831\n      OTEL_SERVICE_NAME: prism-plugin-postgres\n    depends_on:\n      - jaeger\n'})}),"\n",(0,a.jsx)(t.h3,{id:"trace-example-jaeger-ui",children:"Trace Example (Jaeger UI)"}),"\n",(0,a.jsx)(t.p,{children:"Trace ID: 0af7651916cd43dd8448eb211c80319c\nDuration: 142ms\nSpans: 7"}),"\n",(0,a.jsx)(t.p,{children:"prism-proxy: handle_data_request [142ms]\n\u251c\u2500 prism-proxy: auth.verify [3ms]\n\u251c\u2500 prism-proxy: routing.select_plugin [1ms]\n\u251c\u2500 prism-proxy: plugin.execute [137ms]\n\u2502  \u2502\n\u2502  \u2514\u2500 prism-plugin-postgres: Execute [136ms]\n\u2502     \u251c\u2500 prism-plugin-postgres: pool.acquire [2ms]\n\u2502     \u2514\u2500 prism-plugin-postgres: postgres.query [134ms]\n\u2502        \u2514\u2500 postgresql: SELECT * FROM users WHERE id = $1 [132ms]"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-text",children:"\n## References\n\n- [ADR-008: Observability Strategy](/adr/adr-008) - High-level observability architecture\n- [OpenTelemetry Specification](https://opentelemetry.io/docs/specs/otel/)\n- [W3C Trace Context](https://www.w3.org/TR/trace-context/)\n- [OpenTelemetry Rust](https://github.com/open-telemetry/opentelemetry-rust)\n- [OpenTelemetry Go](https://github.com/open-telemetry/opentelemetry-go)\n- [Tracing in Rust with Tokio](https://tokio.rs/tokio/topics/tracing)\n- RFC-008: Plugin Architecture - Plugin core library design\n\n## Revision History\n\n- 2025-10-09: Initial draft and acceptance\n\n"})})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var r=n(96540);const a={},i=r.createContext(a);function s(e){const t=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);