"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[99764],{28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var s=r(96540);const t={},i=s.createContext(t);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(i.Provider,{value:n},e.children)}},69948:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"rfc-034","title":"RFC-034: Robust Process Manager Package Inspired by Kubelet","description":"Summary","source":"@site/../docs-cms/rfcs/RFC-034-robust-process-manager.md","sourceDirName":".","slug":"/rfc-034","permalink":"/prism-data-layer/rfc/rfc-034","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/rfcs/RFC-034-robust-process-manager.md","tags":[{"inline":true,"label":"process-management","permalink":"/prism-data-layer/rfc/tags/process-management"},{"inline":true,"label":"concurrency","permalink":"/prism-data-layer/rfc/tags/concurrency"},{"inline":true,"label":"lifecycle","permalink":"/prism-data-layer/rfc/tags/lifecycle"},{"inline":true,"label":"kubelet","permalink":"/prism-data-layer/rfc/tags/kubelet"},{"inline":true,"label":"reliability","permalink":"/prism-data-layer/rfc/tags/reliability"}],"version":"current","frontMatter":{"title":"RFC-034: Robust Process Manager Package Inspired by Kubelet","status":"Proposed","author":"Claude Code","created":"2025-10-14T00:00:00.000Z","updated":"2025-10-14T00:00:00.000Z","tags":["process-management","concurrency","lifecycle","kubelet","reliability"],"id":"rfc-034","project_id":"prism-data-access","doc_uuid":"824358fe-8a2d-4838-8976-ae447cd697b4"},"sidebar":"rfcSidebar","previous":{"title":"Claim Check Pattern for Large Payloads \u2022 RFC-033","permalink":"/prism-data-layer/rfc/rfc-033"},"next":{"title":"Pattern Process Launcher with Bulkhead Isolation \u2022 RFC-035","permalink":"/prism-data-layer/rfc/rfc-035"}}');var t=r(74848),i=r(28453);const o={title:"RFC-034: Robust Process Manager Package Inspired by Kubelet",status:"Proposed",author:"Claude Code",created:new Date("2025-10-14T00:00:00.000Z"),updated:new Date("2025-10-14T00:00:00.000Z"),tags:["process-management","concurrency","lifecycle","kubelet","reliability"],id:"rfc-034",project_id:"prism-data-access",doc_uuid:"824358fe-8a2d-4838-8976-ae447cd697b4"},a="RFC-034: Robust Process Manager Package Inspired by Kubelet",c={},l=[{value:"Summary",id:"summary",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Kubelet&#39;s Process Management: Key Insights",id:"kubelets-process-management-key-insights",level:2},{value:"Architecture Overview",id:"architecture-overview",level:3},{value:"Key Design Patterns",id:"key-design-patterns",level:3},{value:"Pattern 1: Goroutine-Per-Process with Buffered Channels",id:"pattern-1-goroutine-per-process-with-buffered-channels",level:4},{value:"Pattern 2: State Machine with Immutable Transitions",id:"pattern-2-state-machine-with-immutable-transitions",level:4},{value:"Pattern 3: Pending + Active Update Model",id:"pattern-3-pending--active-update-model",level:4},{value:"Pattern 4: Context Cancellation for Interruption",id:"pattern-4-context-cancellation-for-interruption",level:4},{value:"Pattern 5: Work Queue with Exponential Backoff",id:"pattern-5-work-queue-with-exponential-backoff",level:4},{value:"Pattern 6: Graceful Termination with Grace Period",id:"pattern-6-graceful-termination-with-grace-period",level:4},{value:"Pattern 7: Orphan Cleanup via SyncKnownPods",id:"pattern-7-orphan-cleanup-via-syncknownpods",level:4},{value:"Proposed Package: <code>pkg/procmgr</code>",id:"proposed-package-pkgprocmgr",level:2},{value:"Core Types",id:"core-types",level:3},{value:"Core API",id:"core-api",level:3},{value:"Configuration Options",id:"configuration-options",level:3},{value:"Work Queue with Backoff",id:"work-queue-with-backoff",level:3},{value:"Implementation Phases",id:"implementation-phases",level:2},{value:"Phase 1: Core Process Manager (Week 1)",id:"phase-1-core-process-manager-week-1",level:3},{value:"Phase 2: Work Queue and Backoff (Week 2)",id:"phase-2-work-queue-and-backoff-week-2",level:3},{value:"Phase 3: Graceful Termination (Week 3)",id:"phase-3-graceful-termination-week-3",level:3},{value:"Phase 4: Orphan Cleanup and Metrics (Week 4)",id:"phase-4-orphan-cleanup-and-metrics-week-4",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Example 1: Backend Driver Management",id:"example-1-backend-driver-management",level:3},{value:"Example 2: Worker Pool Management",id:"example-2-worker-pool-management",level:3},{value:"Example 3: Plugin Hot Reload",id:"example-3-plugin-hot-reload",level:3},{value:"Metrics and Observability",id:"metrics-and-observability",level:2},{value:"Prometheus Metrics",id:"prometheus-metrics",level:3},{value:"Logging",id:"logging",level:3},{value:"Health Checks",id:"health-checks",level:3},{value:"Testing Strategy",id:"testing-strategy",level:2},{value:"Unit Tests",id:"unit-tests",level:3},{value:"Integration Tests",id:"integration-tests",level:3},{value:"Load Tests",id:"load-tests",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Alternatives Considered",id:"alternatives-considered",level:2},{value:"Alternative 1: errgroup.Group",id:"alternative-1-errgroupgroup",level:3},{value:"Alternative 2: golang.org/x/sync/semaphore",id:"alternative-2-golangorgxsyncsemaphore",level:3},{value:"Alternative 3: github.com/oklog/run",id:"alternative-3-githubcomoklogrun",level:3},{value:"Open Questions",id:"open-questions",level:2},{value:"References",id:"references",level:2},{value:"Appendix A: Kubelet Architecture Diagram",id:"appendix-a-kubelet-architecture-diagram",level:2},{value:"Appendix B: State Transition Diagram",id:"appendix-b-state-transition-diagram",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"rfc-034-robust-process-manager-package-inspired-by-kubelet",children:"RFC-034: Robust Process Manager Package Inspired by Kubelet"})}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"This RFC proposes a robust process management package for Prism inspired by Kubernetes Kubelet's pod worker system. The package will manage 0 or more concurrent processes with proper lifecycle management, graceful termination, state tracking, and error recovery. While Kubelet manages container/pod lifecycles, our package will manage backend driver process lifecycles (plugins, adapters, workers) with similar guarantees around state transitions, termination handling, and resource cleanup."}),"\n",(0,t.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,t.jsx)(n.p,{children:"Prism requires robust process management for:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Backend Driver Processes"}),": Each backend driver (Redis, NATS, Kafka, PostgreSQL, MemStore) runs as a managed process with start, sync, terminating, and terminated phases"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Plugin Lifecycle"}),": Hot-reload capability requires graceful termination and restart of plugin processes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Worker Pools"}),": Pattern implementations (multicast registry, consumer, producer) spawn worker goroutines that need coordination"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Concurrent Operations"}),": Multiple processes must run concurrently without interference, with proper isolation and state management"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Graceful Shutdown"}),": System shutdown must cleanly terminate all processes with timeout handling"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Current Gap"}),": We lack a unified process management system. Each component reinvents lifecycle management, leading to:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Inconsistent termination handling (some processes block, others leak)"}),"\n",(0,t.jsx)(n.li,{children:"Race conditions during startup/shutdown"}),"\n",(0,t.jsx)(n.li,{children:"No visibility into process state (running? terminating? stuck?)"}),"\n",(0,t.jsx)(n.li,{children:"Difficult debugging when processes hang"}),"\n",(0,t.jsx)(n.li,{children:"No standard pattern for retries and backoff"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"kubelets-process-management-key-insights",children:"Kubelet's Process Management: Key Insights"}),"\n",(0,t.jsx)(n.h3,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,t.jsxs)(n.p,{children:["Kubelet's ",(0,t.jsx)(n.code,{children:"pod_workers.go"})," (~1700 lines) implements a sophisticated state machine for managing pod lifecycles. Key components:"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"1. Per-Process Goroutine with Channel Communication"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"type podWorkers struct {\n    podUpdates      map[types.UID]chan struct{}       // One channel per process\n    podSyncStatuses map[types.UID]*podSyncStatus      // State tracking\n    podLock         sync.Mutex                         // Protects all state\n    workQueue       queue.WorkQueue                    // Retry with backoff\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"2. Four Lifecycle States"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"type PodWorkerState int\n\nconst (\n    SyncPod        PodWorkerState = iota  // Starting and running\n    TerminatingPod                        // Stopping containers\n    TerminatedPod                         // Cleanup resources\n)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"3. State Tracking Per Process"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"type podSyncStatus struct {\n    ctx           context.Context\n    cancelFn      context.CancelFunc\n    working       bool\n    pendingUpdate *UpdatePodOptions\n    activeUpdate  *UpdatePodOptions\n\n    // Lifecycle timestamps\n    syncedAt      time.Time\n    startedAt     time.Time\n    terminatingAt time.Time\n    terminatedAt  time.Time\n\n    // Termination metadata\n    gracePeriod   int64\n    deleted       bool\n    evicted       bool\n    finished      bool\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"key-design-patterns",children:"Key Design Patterns"}),"\n",(0,t.jsx)(n.h4,{id:"pattern-1-goroutine-per-process-with-buffered-channels",children:"Pattern 1: Goroutine-Per-Process with Buffered Channels"}),"\n",(0,t.jsx)(n.p,{children:"Each process gets its own goroutine and update channel:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'// Spawn a worker goroutine\ngo func() {\n    defer runtime.HandleCrash()\n    defer klog.V(3).InfoS("Process worker has stopped", "procUID", uid)\n    p.processWorkerLoop(uid, outCh)\n}()\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Process isolation: one process failure doesn't affect others"}),"\n",(0,t.jsx)(n.li,{children:"Non-blocking updates: buffered channel prevents publisher blocking"}),"\n",(0,t.jsx)(n.li,{children:"Clean shutdown: close channel to signal termination"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"pattern-2-state-machine-with-immutable-transitions",children:"Pattern 2: State Machine with Immutable Transitions"}),"\n",(0,t.jsx)(n.p,{children:"State transitions are one-way and immutable:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"[SyncPod] \u2192 [TerminatingPod] \u2192 [TerminatedPod] \u2192 [Finished]\n     \u2191             \u2193                   \u2193\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         (only via SyncKnownPods purge)\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Key Rules"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Once terminating, cannot return to sync"}),"\n",(0,t.jsx)(n.li,{children:"Grace period can only decrease, never increase"}),"\n",(0,t.jsx)(n.li,{children:"Finished processes ignored until purged"}),"\n",(0,t.jsx)(n.li,{children:"State transitions hold lock briefly, sync operations do not"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"pattern-3-pending--active-update-model",children:"Pattern 3: Pending + Active Update Model"}),"\n",(0,t.jsx)(n.p,{children:"Two update slots prevent losing state:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"// Pending: queued update waiting for worker\npendingUpdate *UpdatePodOptions\n\n// Active: currently processing update (visible to all)\nactiveUpdate  *UpdatePodOptions\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Flow"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["New update arrives \u2192 store in ",(0,t.jsx)(n.code,{children:"pendingUpdate"})]}),"\n",(0,t.jsxs)(n.li,{children:["Worker goroutine wakes \u2192 move ",(0,t.jsx)(n.code,{children:"pendingUpdate"})," to ",(0,t.jsx)(n.code,{children:"activeUpdate"})]}),"\n",(0,t.jsxs)(n.li,{children:["Process sync \u2192 ",(0,t.jsx)(n.code,{children:"activeUpdate"})," is source of truth"]}),"\n",(0,t.jsxs)(n.li,{children:["Another update arrives while processing \u2192 overwrites ",(0,t.jsx)(n.code,{children:"pendingUpdate"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Worker always processes latest state"}),"\n",(0,t.jsx)(n.li,{children:"Intermediate updates can be skipped (optimization)"}),"\n",(0,t.jsx)(n.li,{children:"Active update visible for health checks"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"pattern-4-context-cancellation-for-interruption",children:"Pattern 4: Context Cancellation for Interruption"}),"\n",(0,t.jsx)(n.p,{children:"Each process has a context for cancellation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'// Initialize context for process\nif status.ctx == nil || status.ctx.Err() == context.Canceled {\n    status.ctx, status.cancelFn = context.WithCancel(context.Background())\n}\n\n// Cancel on termination request\nif (becameTerminating || wasGracePeriodShortened) && status.cancelFn != nil {\n    klog.V(3).InfoS("Cancelling current sync", "procUID", uid)\n    status.cancelFn()\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Long-running sync operations can be interrupted"}),"\n",(0,t.jsx)(n.li,{children:"Faster response to termination signals"}),"\n",(0,t.jsx)(n.li,{children:"Graceful unwinding of nested operations"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"pattern-5-work-queue-with-exponential-backoff",children:"Pattern 5: Work Queue with Exponential Backoff"}),"\n",(0,t.jsx)(n.p,{children:"Failed syncs requeue with backoff:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"func (p *podWorkers) completeWork(podUID types.UID, phaseTransition bool, syncErr error) {\n    switch {\n    case phaseTransition:\n        p.workQueue.Enqueue(podUID, 0)  // Immediate\n    case syncErr == nil:\n        p.workQueue.Enqueue(podUID, wait.Jitter(p.resyncInterval, 0.5))\n    case isTransientError(syncErr):\n        p.workQueue.Enqueue(podUID, wait.Jitter(1*time.Second, 0.5))\n    default:\n        p.workQueue.Enqueue(podUID, wait.Jitter(p.backOffPeriod, 0.5))\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Transient errors retry quickly"}),"\n",(0,t.jsx)(n.li,{children:"Persistent errors back off exponentially"}),"\n",(0,t.jsx)(n.li,{children:"Phase transitions bypass queue for immediate action"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"pattern-6-graceful-termination-with-grace-period",children:"Pattern 6: Graceful Termination with Grace Period"}),"\n",(0,t.jsx)(n.p,{children:"Termination is multi-phase with configurable grace period:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"// Phase 1: SyncTerminatingPod - stop containers\nerr = p.podSyncer.SyncTerminatingPod(ctx, pod, status, gracePeriod, statusFn)\n\n// Phase 2: SyncTerminatedPod - cleanup resources\nerr = p.podSyncer.SyncTerminatedPod(ctx, pod, status)\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Grace Period Rules"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Default from pod spec: ",(0,t.jsx)(n.code,{children:"pod.Spec.TerminationGracePeriodSeconds"})]}),"\n",(0,t.jsx)(n.li,{children:"Can be overridden (eviction, force delete)"}),"\n",(0,t.jsx)(n.li,{children:"Can only decrease, never increase"}),"\n",(0,t.jsx)(n.li,{children:"Minimum 1 second enforced"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"pattern-7-orphan-cleanup-via-syncknownpods",children:"Pattern 7: Orphan Cleanup via SyncKnownPods"}),"\n",(0,t.jsx)(n.p,{children:"Periodic reconciliation removes finished processes:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"func (p *podWorkers) SyncKnownPods(desiredPods []*v1.Pod) map[types.UID]PodWorkerSync {\n    for uid, status := range p.podSyncStatuses {\n        _, knownPod := known[uid]\n        orphan := !knownPod\n\n        if status.restartRequested || orphan {\n            if p.removeTerminatedWorker(uid, status, orphan) {\n                continue  // Removed, don't return\n            }\n        }\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Bounded memory: finished processes eventually purged"}),"\n",(0,t.jsx)(n.li,{children:"Restart detection: same UID can be reused after purge"}),"\n",(0,t.jsx)(n.li,{children:"Orphan termination: processes not in desired set are stopped"}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"proposed-package-pkgprocmgr",children:["Proposed Package: ",(0,t.jsx)(n.code,{children:"pkg/procmgr"})]}),"\n",(0,t.jsx)(n.h3,{id:"core-types",children:"Core Types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'package procmgr\n\nimport (\n    "context"\n    "sync"\n    "time"\n)\n\n// ProcessState represents the lifecycle state of a managed process\ntype ProcessState int\n\nconst (\n    // ProcessStateStarting - process is initializing\n    ProcessStateStarting ProcessState = iota\n    // ProcessStateSyncing - process is running and healthy\n    ProcessStateSyncing\n    // ProcessStateTerminating - process is shutting down\n    ProcessStateTerminating\n    // ProcessStateTerminated - process has stopped, awaiting cleanup\n    ProcessStateTerminated\n    // ProcessStateFinished - process fully cleaned up\n    ProcessStateFinished\n)\n\n// ProcessID uniquely identifies a managed process\ntype ProcessID string\n\n// ProcessUpdate contains state changes for a process\ntype ProcessUpdate struct {\n    ID              ProcessID\n    UpdateType      UpdateType\n    StartTime       time.Time\n    Config          interface{}  // Process-specific config\n    TerminateOptions *TerminateOptions\n}\n\n// UpdateType specifies the kind of update\ntype UpdateType int\n\nconst (\n    UpdateTypeCreate UpdateType = iota\n    UpdateTypeUpdate\n    UpdateTypeSync\n    UpdateTypeTerminate\n)\n\n// TerminateOptions control process termination\ntype TerminateOptions struct {\n    CompletedCh      chan<- struct{}\n    Evict            bool\n    GracePeriodSecs  *int64\n    StatusFunc       ProcessStatusFunc\n}\n\n// ProcessStatusFunc is called to update process status on termination\ntype ProcessStatusFunc func(status *ProcessStatus)\n\n// ProcessStatus tracks runtime state of a process\ntype ProcessStatus struct {\n    State         ProcessState\n    Healthy       bool\n    LastSync      time.Time\n    ErrorCount    int\n    LastError     error\n    RestartCount  int\n}\n\n// ProcessSyncer defines the interface for process lifecycle hooks\ntype ProcessSyncer interface {\n    // SyncProcess starts/updates the process\n    SyncProcess(ctx context.Context, updateType UpdateType, config interface{}) (terminal bool, error)\n\n    // SyncTerminatingProcess stops the process\n    SyncTerminatingProcess(ctx context.Context, config interface{}, gracePeriodSecs *int64, statusFn ProcessStatusFunc) error\n\n    // SyncTerminatedProcess cleans up resources\n    SyncTerminatedProcess(ctx context.Context, config interface{}) error\n}\n\n// ProcessManager manages 0 or more concurrent processes\ntype ProcessManager struct {\n    mu sync.Mutex\n\n    // Process tracking\n    processUpdates  map[ProcessID]chan struct{}\n    processStatuses map[ProcessID]*processStatus\n\n    // Configuration\n    syncer         ProcessSyncer\n    resyncInterval time.Duration\n    backOffPeriod  time.Duration\n    workQueue      WorkQueue\n\n    // Metrics\n    metrics ProcessManagerMetrics\n}\n\n// Internal state tracking per process\ntype processStatus struct {\n    ctx       context.Context\n    cancelFn  context.CancelFunc\n\n    working   bool\n    pending   *ProcessUpdate\n    active    *ProcessUpdate\n\n    // Lifecycle timestamps\n    syncedAt      time.Time\n    startedAt     time.Time\n    terminatingAt time.Time\n    terminatedAt  time.Time\n    finishedAt    time.Time\n\n    // Termination metadata\n    gracePeriod   int64\n    evicted       bool\n    finished      bool\n\n    // Health tracking\n    errorCount    int\n    lastError     error\n    restartCount  int\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"core-api",children:"Core API"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"// NewProcessManager creates a new process manager\nfunc NewProcessManager(opts ...Option) *ProcessManager\n\n// UpdateProcess submits a process update\nfunc (pm *ProcessManager) UpdateProcess(update ProcessUpdate)\n\n// SyncKnownProcesses reconciles desired vs actual processes\nfunc (pm *ProcessManager) SyncKnownProcesses(desiredIDs []ProcessID) map[ProcessID]ProcessStatus\n\n// GetProcessStatus returns current status of a process\nfunc (pm *ProcessManager) GetProcessStatus(id ProcessID) (*ProcessStatus, bool)\n\n// IsProcessTerminated checks if process has terminated\nfunc (pm *ProcessManager) IsProcessTerminated(id ProcessID) bool\n\n// IsProcessFinished checks if process cleanup completed\nfunc (pm *ProcessManager) IsProcessFinished(id ProcessID) bool\n\n// Shutdown gracefully stops all processes\nfunc (pm *ProcessManager) Shutdown(ctx context.Context) error\n"})}),"\n",(0,t.jsx)(n.h3,{id:"configuration-options",children:"Configuration Options"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"type Option func(*ProcessManager)\n\n// WithResyncInterval sets periodic resync interval\nfunc WithResyncInterval(d time.Duration) Option\n\n// WithBackOffPeriod sets error backoff period\nfunc WithBackOffPeriod(d time.Duration) Option\n\n// WithMetricsCollector enables metrics\nfunc WithMetricsCollector(mc MetricsCollector) Option\n\n// WithLogger sets custom logger\nfunc WithLogger(logger Logger) Option\n"})}),"\n",(0,t.jsx)(n.h3,{id:"work-queue-with-backoff",children:"Work Queue with Backoff"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"// WorkQueue manages process work items with backoff\ntype WorkQueue interface {\n    Enqueue(id ProcessID, delay time.Duration)\n    Dequeue() (ProcessID, bool)\n    Len() int\n}\n\n// workQueue implements WorkQueue with priority queue\ntype workQueue struct {\n    mu       sync.Mutex\n    items    []*workItem\n    notifyCh chan struct{}\n}\n\ntype workItem struct {\n    id       ProcessID\n    readyAt  time.Time\n    priority int\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"implementation-phases",children:"Implementation Phases"}),"\n",(0,t.jsx)(n.h3,{id:"phase-1-core-process-manager-week-1",children:"Phase 1: Core Process Manager (Week 1)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Deliverables"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Process manager struct with state tracking"}),"\n",(0,t.jsx)(n.li,{children:"Per-process goroutine with channel communication"}),"\n",(0,t.jsx)(n.li,{children:"State machine with immutable transitions"}),"\n",(0,t.jsx)(n.li,{children:"Pending + active update model"}),"\n",(0,t.jsx)(n.li,{children:"Context cancellation support"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Tests"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Create/update/terminate single process"}),"\n",(0,t.jsx)(n.li,{children:"Concurrent operations on multiple processes"}),"\n",(0,t.jsx)(n.li,{children:"State transition validation"}),"\n",(0,t.jsx)(n.li,{children:"Context cancellation during sync"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"phase-2-work-queue-and-backoff-week-2",children:"Phase 2: Work Queue and Backoff (Week 2)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Deliverables"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Priority work queue implementation"}),"\n",(0,t.jsx)(n.li,{children:"Exponential backoff on errors"}),"\n",(0,t.jsx)(n.li,{children:"Jitter to prevent thundering herd"}),"\n",(0,t.jsx)(n.li,{children:"Immediate requeue on phase transitions"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Tests"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Backoff increases on repeated failures"}),"\n",(0,t.jsx)(n.li,{children:"Transient vs persistent error handling"}),"\n",(0,t.jsx)(n.li,{children:"Phase transitions bypass backoff"}),"\n",(0,t.jsx)(n.li,{children:"Queue ordering correctness"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"phase-3-graceful-termination-week-3",children:"Phase 3: Graceful Termination (Week 3)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Deliverables"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Multi-phase termination (terminating \u2192 terminated)"}),"\n",(0,t.jsx)(n.li,{children:"Configurable grace period"}),"\n",(0,t.jsx)(n.li,{children:"Grace period decrease-only enforcement"}),"\n",(0,t.jsx)(n.li,{children:"Completion notification channels"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Tests"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Graceful shutdown within grace period"}),"\n",(0,t.jsx)(n.li,{children:"Force kill after grace period expires"}),"\n",(0,t.jsx)(n.li,{children:"Grace period cannot increase"}),"\n",(0,t.jsx)(n.li,{children:"Completion channel closed on termination"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"phase-4-orphan-cleanup-and-metrics-week-4",children:"Phase 4: Orphan Cleanup and Metrics (Week 4)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Deliverables"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"SyncKnownProcesses reconciliation"}),"\n",(0,t.jsx)(n.li,{children:"Orphan detection and cleanup"}),"\n",(0,t.jsx)(n.li,{children:"Finished process purging"}),"\n",(0,t.jsx)(n.li,{children:"Prometheus metrics integration"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Tests"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Orphaned processes terminated"}),"\n",(0,t.jsx)(n.li,{children:"Finished processes purged after TTL"}),"\n",(0,t.jsx)(n.li,{children:"Metrics exported correctly"}),"\n",(0,t.jsx)(n.li,{children:"Memory doesn't grow unbounded"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,t.jsx)(n.h3,{id:"example-1-backend-driver-management",children:"Example 1: Backend Driver Management"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'// Define driver lifecycle\ntype driverSyncer struct {\n    drivers map[ProcessID]backend.Driver\n}\n\nfunc (ds *driverSyncer) SyncProcess(ctx context.Context, updateType UpdateType, config interface{}) (bool, error) {\n    driverConfig := config.(*DriverConfig)\n    driver, ok := ds.drivers[driverConfig.ID]\n\n    if !ok {\n        // Create new driver\n        driver, err := backend.NewDriver(driverConfig)\n        if err != nil {\n            return false, fmt.Errorf("create driver: %w", err)\n        }\n        ds.drivers[driverConfig.ID] = driver\n    }\n\n    // Start driver\n    if err := driver.Start(ctx); err != nil {\n        return false, fmt.Errorf("start driver: %w", err)\n    }\n\n    // Check if driver reached terminal state\n    if driver.State() == backend.StateFailed {\n        return true, fmt.Errorf("driver failed")\n    }\n\n    return false, nil\n}\n\nfunc (ds *driverSyncer) SyncTerminatingProcess(ctx context.Context, config interface{}, gracePeriodSecs *int64, statusFn ProcessStatusFunc) error {\n    driverConfig := config.(*DriverConfig)\n    driver := ds.drivers[driverConfig.ID]\n\n    // Stop driver with grace period\n    timeout := time.Duration(*gracePeriodSecs) * time.Second\n    return driver.StopWithTimeout(ctx, timeout)\n}\n\nfunc (ds *driverSyncer) SyncTerminatedProcess(ctx context.Context, config interface{}) error {\n    driverConfig := config.(*DriverConfig)\n    driver := ds.drivers[driverConfig.ID]\n\n    // Cleanup resources\n    if err := driver.Cleanup(); err != nil {\n        return fmt.Errorf("cleanup: %w", err)\n    }\n\n    delete(ds.drivers, driverConfig.ID)\n    return nil\n}\n\n// Usage\nfunc main() {\n    syncer := &driverSyncer{drivers: make(map[ProcessID]backend.Driver)}\n    pm := procmgr.NewProcessManager(\n        procmgr.WithSyncer(syncer),\n        procmgr.WithResyncInterval(30*time.Second),\n        procmgr.WithBackOffPeriod(5*time.Second),\n    )\n\n    // Start Redis driver\n    pm.UpdateProcess(procmgr.ProcessUpdate{\n        ID:         "redis-driver",\n        UpdateType: procmgr.UpdateTypeCreate,\n        Config:     &DriverConfig{Type: "redis", DSN: "localhost:6379"},\n    })\n\n    // Start NATS driver\n    pm.UpdateProcess(procmgr.ProcessUpdate{\n        ID:         "nats-driver",\n        UpdateType: procmgr.UpdateTypeCreate,\n        Config:     &DriverConfig{Type: "nats", DSN: "nats://localhost:4222"},\n    })\n\n    // Graceful shutdown\n    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\n    defer cancel()\n    pm.Shutdown(ctx)\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"example-2-worker-pool-management",children:"Example 2: Worker Pool Management"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"// Worker pool with dynamic scaling\ntype workerPoolSyncer struct {\n    pools map[ProcessID]*WorkerPool\n}\n\nfunc (wps *workerPoolSyncer) SyncProcess(ctx context.Context, updateType UpdateType, config interface{}) (bool, error) {\n    poolConfig := config.(*PoolConfig)\n    pool, ok := wps.pools[poolConfig.ID]\n\n    if !ok {\n        // Create new pool\n        pool = NewWorkerPool(poolConfig.NumWorkers)\n        wps.pools[poolConfig.ID] = pool\n    } else {\n        // Scale pool\n        pool.Scale(poolConfig.NumWorkers)\n    }\n\n    // Start workers\n    return false, pool.Start(ctx)\n}\n\nfunc (wps *workerPoolSyncer) SyncTerminatingProcess(ctx context.Context, config interface{}, gracePeriodSecs *int64, statusFn ProcessStatusFunc) error {\n    poolConfig := config.(*PoolConfig)\n    pool := wps.pools[poolConfig.ID]\n\n    // Drain work queue\n    pool.Drain()\n\n    // Stop workers with timeout\n    timeout := time.Duration(*gracePeriodSecs) * time.Second\n    return pool.StopWithTimeout(ctx, timeout)\n}\n\nfunc (wps *workerPoolSyncer) SyncTerminatedProcess(ctx context.Context, config interface{}) error {\n    poolConfig := config.(*PoolConfig)\n    delete(wps.pools, poolConfig.ID)\n    return nil\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"example-3-plugin-hot-reload",children:"Example 3: Plugin Hot Reload"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'// Hot reload plugin without downtime\nfunc reloadPlugin(pm *ProcessManager, pluginID ProcessID, newConfig *PluginConfig) error {\n    // Step 1: Check current state\n    status, ok := pm.GetProcessStatus(pluginID)\n    if !ok {\n        return fmt.Errorf("plugin %s not found", pluginID)\n    }\n\n    // Step 2: Graceful termination with callback\n    completedCh := make(chan struct{})\n    pm.UpdateProcess(procmgr.ProcessUpdate{\n        ID:         pluginID,\n        UpdateType: procmgr.UpdateTypeTerminate,\n        TerminateOptions: &procmgr.TerminateOptions{\n            CompletedCh:     completedCh,\n            GracePeriodSecs: ptr.Int64(10),\n        },\n    })\n\n    // Step 3: Wait for termination\n    select {\n    case <-completedCh:\n        // Old plugin terminated\n    case <-time.After(15 * time.Second):\n        return fmt.Errorf("plugin termination timeout")\n    }\n\n    // Step 4: Wait for cleanup\n    for {\n        if pm.IsProcessFinished(pluginID) {\n            break\n        }\n        time.Sleep(100 * time.Millisecond)\n    }\n\n    // Step 5: Start new version\n    pm.UpdateProcess(procmgr.ProcessUpdate{\n        ID:         pluginID,\n        UpdateType: procmgr.UpdateTypeCreate,\n        Config:     newConfig,\n    })\n\n    return nil\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"metrics-and-observability",children:"Metrics and Observability"}),"\n",(0,t.jsx)(n.h3,{id:"prometheus-metrics",children:"Prometheus Metrics"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"// Process lifecycle metrics\nprocess_state_total{id, state} counter\nprocess_sync_duration_seconds{id, type} histogram\nprocess_termination_duration_seconds{id} histogram\nprocess_error_total{id, type} counter\nprocess_restart_total{id} counter\n\n// Queue metrics\nwork_queue_depth gauge\nwork_queue_add_total counter\nwork_queue_retry_total counter\nwork_queue_backoff_duration_seconds histogram\n"})}),"\n",(0,t.jsx)(n.h3,{id:"logging",children:"Logging"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:'INFO  Process starting                            id=redis-driver config=<redacted>\nINFO  Process synced successfully                  id=redis-driver duration=125ms\nWARN  Process sync failed (transient error)       id=redis-driver error="connection refused" retry_in=1s\nERROR Process sync failed (persistent error)      id=redis-driver error="auth failed" backoff=5s\nINFO  Process termination requested               id=redis-driver grace_period=10s\nINFO  Process terminating                         id=redis-driver containers_stopped=2\nINFO  Process terminated successfully             id=redis-driver duration=3.2s\nINFO  Process cleanup completed                   id=redis-driver\n'})}),"\n",(0,t.jsx)(n.h3,{id:"health-checks",children:"Health Checks"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"// Health check endpoint\ntype HealthCheck struct {\n    TotalProcesses    int\n    RunningProcesses  int\n    TerminatingProcesses int\n    FailedProcesses   int\n    Processes         map[ProcessID]ProcessHealth\n}\n\ntype ProcessHealth struct {\n    State        ProcessState\n    Healthy      bool\n    Uptime       time.Duration\n    LastSync     time.Time\n    ErrorCount   int\n    RestartCount int\n}\n\nfunc (pm *ProcessManager) Health() HealthCheck {\n    pm.mu.Lock()\n    defer pm.mu.Unlock()\n\n    health := HealthCheck{\n        Processes: make(map[ProcessID]ProcessHealth),\n    }\n\n    for id, status := range pm.processStatuses {\n        health.TotalProcesses++\n\n        if status.State() == ProcessStateSyncing {\n            health.RunningProcesses++\n        } else if status.State() == ProcessStateTerminating {\n            health.TerminatingProcesses++\n        }\n\n        if status.errorCount > 5 {\n            health.FailedProcesses++\n        }\n\n        health.Processes[id] = ProcessHealth{\n            State:        status.State(),\n            Healthy:      status.errorCount < 5,\n            Uptime:       time.Since(status.startedAt),\n            LastSync:     status.active.StartTime,\n            ErrorCount:   status.errorCount,\n            RestartCount: status.restartCount,\n        }\n    }\n\n    return health\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"testing-strategy",children:"Testing Strategy"}),"\n",(0,t.jsx)(n.h3,{id:"unit-tests",children:"Unit Tests"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'func TestProcessManager_CreateProcess(t *testing.T) {\n    syncer := &mockSyncer{}\n    pm := procmgr.NewProcessManager(procmgr.WithSyncer(syncer))\n\n    pm.UpdateProcess(procmgr.ProcessUpdate{\n        ID:         "test-1",\n        UpdateType: procmgr.UpdateTypeCreate,\n        Config:     &TestConfig{},\n    })\n\n    // Wait for sync\n    time.Sleep(100 * time.Millisecond)\n\n    status, ok := pm.GetProcessStatus("test-1")\n    require.True(t, ok)\n    assert.Equal(t, procmgr.ProcessStateSyncing, status.State)\n    assert.Equal(t, 1, syncer.syncCalled)\n}\n\nfunc TestProcessManager_GracefulTermination(t *testing.T) {\n    syncer := &mockSyncer{syncDuration: 5 * time.Second}\n    pm := procmgr.NewProcessManager(procmgr.WithSyncer(syncer))\n\n    pm.UpdateProcess(procmgr.ProcessUpdate{\n        ID:         "test-1",\n        UpdateType: procmgr.UpdateTypeCreate,\n        Config:     &TestConfig{},\n    })\n\n    // Terminate with grace period\n    completedCh := make(chan struct{})\n    pm.UpdateProcess(procmgr.ProcessUpdate{\n        ID:         "test-1",\n        UpdateType: procmgr.UpdateTypeTerminate,\n        TerminateOptions: &procmgr.TerminateOptions{\n            CompletedCh:     completedCh,\n            GracePeriodSecs: ptr.Int64(10),\n        },\n    })\n\n    // Should complete within grace period\n    select {\n    case <-completedCh:\n        // Success\n    case <-time.After(15 * time.Second):\n        t.Fatal("termination timeout")\n    }\n\n    assert.True(t, pm.IsProcessTerminated("test-1"))\n}\n\nfunc TestProcessManager_ConcurrentProcesses(t *testing.T) {\n    syncer := &mockSyncer{}\n    pm := procmgr.NewProcessManager(procmgr.WithSyncer(syncer))\n\n    // Create 100 processes concurrently\n    var wg sync.WaitGroup\n    for i := 0; i < 100; i++ {\n        wg.Add(1)\n        go func(id int) {\n            defer wg.Done()\n            pm.UpdateProcess(procmgr.ProcessUpdate{\n                ID:         ProcessID(fmt.Sprintf("test-%d", id)),\n                UpdateType: procmgr.UpdateTypeCreate,\n                Config:     &TestConfig{},\n            })\n        }(i)\n    }\n    wg.Wait()\n\n    // All should be created\n    time.Sleep(1 * time.Second)\n    for i := 0; i < 100; i++ {\n        status, ok := pm.GetProcessStatus(ProcessID(fmt.Sprintf("test-%d", i)))\n        assert.True(t, ok)\n        assert.Equal(t, procmgr.ProcessStateSyncing, status.State)\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"integration-tests",children:"Integration Tests"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'func TestProcessManager_RealBackendDriver(t *testing.T) {\n    // Start real Redis container\n    redis := testcontainers.RunRedis(t)\n    defer redis.Stop()\n\n    // Create process manager with real driver\n    syncer := &driverSyncer{drivers: make(map[ProcessID]backend.Driver)}\n    pm := procmgr.NewProcessManager(procmgr.WithSyncer(syncer))\n\n    // Start Redis driver\n    pm.UpdateProcess(procmgr.ProcessUpdate{\n        ID:         "redis-driver",\n        UpdateType: procmgr.UpdateTypeCreate,\n        Config: &DriverConfig{\n            Type: "redis",\n            DSN:  redis.ConnectionString(),\n        },\n    })\n\n    // Wait for driver to be healthy\n    require.Eventually(t, func() bool {\n        status, ok := pm.GetProcessStatus("redis-driver")\n        return ok && status.State == procmgr.ProcessStateSyncing && status.Healthy\n    }, 5*time.Second, 100*time.Millisecond)\n\n    // Use driver\n    driver := syncer.drivers["redis-driver"]\n    err := driver.Set("key", []byte("value"))\n    require.NoError(t, err)\n\n    // Graceful shutdown\n    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n    defer cancel()\n    err = pm.Shutdown(ctx)\n    require.NoError(t, err)\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"load-tests",children:"Load Tests"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'func TestProcessManager_HighChurn(t *testing.T) {\n    syncer := &mockSyncer{}\n    pm := procmgr.NewProcessManager(procmgr.WithSyncer(syncer))\n\n    // Churn: create and destroy processes rapidly\n    for i := 0; i < 1000; i++ {\n        id := ProcessID(fmt.Sprintf("test-%d", i))\n\n        // Create\n        pm.UpdateProcess(procmgr.ProcessUpdate{\n            ID:         id,\n            UpdateType: procmgr.UpdateTypeCreate,\n            Config:     &TestConfig{},\n        })\n\n        // Terminate after 10ms\n        time.Sleep(10 * time.Millisecond)\n        pm.UpdateProcess(procmgr.ProcessUpdate{\n            ID:         id,\n            UpdateType: procmgr.UpdateTypeTerminate,\n        })\n    }\n\n    // All should eventually finish\n    require.Eventually(t, func() bool {\n        synced := pm.SyncKnownProcesses([]ProcessID{})\n        return len(synced) == 0\n    }, 30*time.Second, 100*time.Millisecond)\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Resource Limits"}),": Process manager should enforce CPU/memory limits per process"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Privilege Separation"}),": Processes run with minimal privileges"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Signal Handling"}),": Proper SIGTERM/SIGKILL handling for Unix processes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Audit Logging"}),": All process lifecycle events logged for security audits"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Deadlock Detection"}),": Timeout enforcement prevents hung processes"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Lock Contention"}),": State lock held briefly, sync operations run without lock"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Channel Buffering"}),": Buffered channels (size 1) prevent publisher blocking"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Work Queue Priority"}),": Phase transitions bypass queue for immediate execution"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Jitter"}),": Random jitter prevents thundering herd on backoff retry"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory Bounds"}),": Finished processes purged after TTL to prevent unbounded growth"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,t.jsx)(n.h3,{id:"alternative-1-errgroupgroup",children:"Alternative 1: errgroup.Group"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Pros"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Built-in concurrency management"}),"\n",(0,t.jsx)(n.li,{children:"Automatic error propagation"}),"\n",(0,t.jsx)(n.li,{children:"Simple API"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Cons"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"No state tracking (starting, terminating, terminated)"}),"\n",(0,t.jsx)(n.li,{children:"No graceful termination with grace period"}),"\n",(0,t.jsx)(n.li,{children:"No retry/backoff on failure"}),"\n",(0,t.jsx)(n.li,{children:"No process-level isolation (one failure stops all)"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Verdict"}),": Too simplistic for our needs."]}),"\n",(0,t.jsx)(n.h3,{id:"alternative-2-golangorgxsyncsemaphore",children:"Alternative 2: golang.org/x/sync/semaphore"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Pros"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Resource limiting (max concurrent processes)"}),"\n",(0,t.jsx)(n.li,{children:"Lightweight"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Cons"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"No lifecycle management"}),"\n",(0,t.jsx)(n.li,{children:"No state machine"}),"\n",(0,t.jsx)(n.li,{children:"No termination handling"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Verdict"}),": Complementary tool, not a replacement."]}),"\n",(0,t.jsx)(n.h3,{id:"alternative-3-githubcomoklogrun",children:"Alternative 3: github.com/oklog/run"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Pros"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Actor-based concurrency"}),"\n",(0,t.jsx)(n.li,{children:"Graceful shutdown support"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Cons"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"No state tracking"}),"\n",(0,t.jsx)(n.li,{children:"No retry/backoff"}),"\n",(0,t.jsx)(n.li,{children:"No per-process isolation"}),"\n",(0,t.jsx)(n.li,{children:"All actors share one context"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Verdict"}),": Good for simple cases, insufficient for complex lifecycle management."]}),"\n",(0,t.jsx)(n.h2,{id:"open-questions",children:"Open Questions"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Process Dependencies"}),": Should process manager support dependency graphs (process A must start before process B)?"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Health Checks"}),": Should health checks be built-in or delegated to the syncer?"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Resource Limits"}),": Should cgroups/ulimits be enforced by process manager?"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Checkpointing"}),": Should process state be persisted for restart recovery?"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dynamic Configuration"}),": Should processes support hot config reload without restart?"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/pod_workers.go",children:"Kubernetes Kubelet pod_workers.go"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/",children:"Kubernetes Pod Lifecycle Documentation"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://go.dev/blog/context",children:"Go Context Cancellation Patterns"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://medium.com/@pinkudebnath/graceful-shutdown-of-golang-servers-using-context-and-os-signals-cc1fa2c55e97",children:"Graceful Shutdown Patterns in Go"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/",children:"Exponential Backoff and Jitter"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"appendix-a-kubelet-architecture-diagram",children:"Appendix A: Kubelet Architecture Diagram"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"                              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                              \u2502  UpdatePod()    \u2502\n                              \u2502  (Public API)   \u2502\n                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                       \u2502\n                              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                              \u2502  podSyncStatus  \u2502\n                              \u2502  (State Store)  \u2502\n                              \u2502  - pending      \u2502\n                              \u2502  - active       \u2502\n                              \u2502  - timestamps   \u2502\n                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                       \u2502\n                              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                              \u2502  podUpdates     \u2502\n                              \u2502  chan struct{}  \u2502\n                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                       \u2502\n                              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                              \u2502 podWorkerLoop() \u2502\n                              \u2502  (Goroutine)    \u2502\n                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                       \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502                  \u2502                  \u2502\n          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502    SyncPod       \u2502 \u2502 SyncTermina-\u2502 \u2502 SyncTerminated  \u2502\n          \u2502  (Start/Update)  \u2502 \u2502  tingPod    \u2502 \u2502      Pod        \u2502\n          \u2502                  \u2502 \u2502  (Stop)     \u2502 \u2502   (Cleanup)     \u2502\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502                  \u2502                  \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                       \u2502\n                              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                              \u2502  completeWork() \u2502\n                              \u2502  (Requeue)      \u2502\n                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                       \u2502\n                              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                              \u2502   workQueue     \u2502\n                              \u2502  (Backoff)      \u2502\n                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(n.h2,{id:"appendix-b-state-transition-diagram",children:"Appendix B: State Transition Diagram"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                         \u2502  Not Exists          \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502 UpdatePod(Create)\n                                \u25bc\n                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                         \u2502  SyncPod             \u2502\n                         \u2502  (Starting/Running)  \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502 Termination Requested\n                                \u2502 (Delete, Evict, Failed)\n                                \u25bc\n                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                         \u2502  TerminatingPod      \u2502\n                         \u2502  (Stopping)          \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502 Containers Stopped\n                                \u25bc\n                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                         \u2502  TerminatedPod       \u2502\n                         \u2502  (Cleanup)           \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502 Cleanup Complete\n                                \u25bc\n                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                         \u2502  Finished            \u2502\n                         \u2502  (Awaiting Purge)    \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502 SyncKnownPods()\n                                \u2502 (Orphan or Restart)\n                                \u25bc\n                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                         \u2502  Not Exists          \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status"}),": Proposed\n",(0,t.jsx)(n.strong,{children:"Next Steps"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Review RFC with team"}),"\n",(0,t.jsx)(n.li,{children:"Prototype core types and state machine"}),"\n",(0,t.jsx)(n.li,{children:"Implement Phase 1 deliverables"}),"\n",(0,t.jsx)(n.li,{children:"Integration with existing backend drivers"}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);