"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[35311],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var i=t(96540);const a={},r=i.createContext(a);function s(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(r.Provider,{value:n},e.children)}},85434:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"rfc-010","title":"Admin Protocol with OIDC Authentication","description":"Abstract","source":"@site/../docs-cms/rfcs/rfc-010-admin-protocol-oidc.md","sourceDirName":".","slug":"/rfc-010","permalink":"/prism-data-layer/rfc/rfc-010","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/rfcs/rfc-010-admin-protocol-oidc.md","tags":[{"inline":true,"label":"admin","permalink":"/prism-data-layer/rfc/tags/admin"},{"inline":true,"label":"oidc","permalink":"/prism-data-layer/rfc/tags/oidc"},{"inline":true,"label":"authentication","permalink":"/prism-data-layer/rfc/tags/authentication"},{"inline":true,"label":"grpc","permalink":"/prism-data-layer/rfc/tags/grpc"},{"inline":true,"label":"protocol","permalink":"/prism-data-layer/rfc/tags/protocol"}],"version":"current","frontMatter":{"author":"Platform Team","created":"2025-10-09T00:00:00.000Z","doc_uuid":"24c10e4b-e663-47a9-9f4b-c8afff40f8ef","id":"rfc-010","project_id":"prism-data-layer","status":"Proposed","tags":["admin","oidc","authentication","grpc","protocol"],"title":"Admin Protocol with OIDC Authentication","updated":"2025-10-09T00:00:00.000Z"},"sidebar":"rfcSidebar","previous":{"title":"Distributed Reliability Data Patterns \u2022 RFC-009","permalink":"/prism-data-layer/rfc/rfc-009"},"next":{"title":"Data Proxy Authentication (Input/Output) \u2022 RFC-011","permalink":"/prism-data-layer/rfc/rfc-011"}}');var a=t(74848),r=t(28453);const s={author:"Platform Team",created:new Date("2025-10-09T00:00:00.000Z"),doc_uuid:"24c10e4b-e663-47a9-9f4b-c8afff40f8ef",id:"rfc-010",project_id:"prism-data-layer",status:"Proposed",tags:["admin","oidc","authentication","grpc","protocol"],title:"Admin Protocol with OIDC Authentication",updated:new Date("2025-10-09T00:00:00.000Z")},o=void 0,c={},l=[{value:"Abstract",id:"abstract",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Protocol Overview",id:"protocol-overview",level:2},{value:"Architecture",id:"architecture",level:3},{value:"OIDC Authentication Flow",id:"oidc-authentication-flow",level:2},{value:"Token Acquisition",id:"token-acquisition",level:3},{value:"JWT Structure",id:"jwt-structure",level:3},{value:"Token Validation",id:"token-validation",level:3},{value:"Request/Response Flows",id:"requestresponse-flows",level:2},{value:"Namespace Creation Flow",id:"namespace-creation-flow",level:3},{value:"Session Monitoring Flow",id:"session-monitoring-flow",level:3},{value:"Backend Health Check Flow",id:"backend-health-check-flow",level:3},{value:"Session Management",id:"session-management",level:2},{value:"Session Lifecycle",id:"session-lifecycle",level:3},{value:"Session Establishment",id:"session-establishment",level:3},{value:"gRPC Protocol Specification",id:"grpc-protocol-specification",level:2},{value:"Service Definition",id:"service-definition",level:3},{value:"Metadata Requirements",id:"metadata-requirements",level:3},{value:"apiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: prism-proxy\nspec:\ntemplate:\nspec:\ncontainers:\n- name: proxy\nimage: prism/proxy\nports:\n- containerPort: 8980\nname: data\n- containerPort: 8981\nname: admin\nenv:\n- name: PRISM_OIDC_ISSUER\nvalueFrom:\nsecretKeyRef:\nname: prism-oidc\nkey: issuer\n- name: PRISM_OIDC_AUDIENCE\nvalueFrom:\nsecretKeyRef:\nname: prism-oidc\nkey: audience",id:"apiversion-appsv1kind-deploymentmetadataname-prism-proxyspectemplatespeccontainers--name-proxyimage-prismproxyports--containerport-8980name-data--containerport-8981name-adminenv--name-prism_oidc_issuervaluefromsecretkeyrefname-prism-oidckey-issuer--name-prism_oidc_audiencevaluefromsecretkeyrefname-prism-oidckey-audience",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",jwtvalidator:"jwtvalidator",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",rbacservice:"rbacservice",string:"string",strong:"strong",ul:"ul",utc:"utc",uuid:"uuid",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"abstract",children:"Abstract"}),"\n",(0,a.jsx)(n.p,{children:"This RFC specifies the complete Admin Protocol for Prism, including OIDC-based authentication with provable identity, request/response flows, session management, and operational procedures. The Admin API enables platform teams to manage configurations, monitor sessions, check backend health, and perform operational tasks with strong authentication and audit trails."}),"\n",(0,a.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,a.jsx)(n.p,{children:"Platform teams require secure, authenticated access to Prism administration with:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Provable Identity"}),": OIDC tokens with claims from identity provider"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Role-Based Access"}),": Different permission levels (admin, operator, viewer)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Audit Trail"}),": Every administrative action logged with actor identity"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Session Management"}),": Long-lived sessions for interactive use, short-lived for automation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Network Isolation"}),": Admin API on separate port, internal-only access"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Goals:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Define complete Admin gRPC protocol"}),"\n",(0,a.jsx)(n.li,{children:"Specify OIDC authentication flow with token acquisition"}),"\n",(0,a.jsx)(n.li,{children:"Document request/response patterns with sequence diagrams"}),"\n",(0,a.jsx)(n.li,{children:"Establish session lifecycle and management"}),"\n",(0,a.jsx)(n.li,{children:"Enable audit logging for compliance"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Non-Goals:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Data plane authentication (covered in RFC-011)"}),"\n",(0,a.jsx)(n.li,{children:"User-facing authentication (application responsibility)"}),"\n",(0,a.jsx)(n.li,{children:"Multi-cluster admin (single cluster scope)"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"protocol-overview",children:"Protocol Overview"}),"\n",(0,a.jsx)(n.h3,{id:"architecture",children:"Architecture"}),"\n",(0,a.jsx)(n.p,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                      Admin Workflow                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"}),"\n",(0,a.jsx)(n.p,{children:"Administrator \u2192 OIDC Provider \u2192 Admin CLI/UI \u2192 Prism Admin API \u2192 Backends\n(1)            (2)              (3)              (4)"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Request identity token"}),"\n",(0,a.jsx)(n.li,{children:"Receive JWT with claims"}),"\n",(0,a.jsx)(n.li,{children:"Present JWT in gRPC metadata"}),"\n",(0,a.jsx)(n.li,{children:"Authorized operations"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n### Ports and Endpoints\n\n- **Data Plane**: Port 8980 (gRPC, public)\n- **Admin API**: Port 8981 (gRPC, internal-only)\n- **Metrics**: Port 9090 (Prometheus, internal-only)\n\n### Protocol Stack\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Admin Client (CLI/UI/Automation)               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n                 \u2502 gRPC/HTTP2 + TLS\n                 \u2502 Authorization: Bearer <jwt>\n                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Prism Admin Service (:8981)                    \u2502\n\u2502                                                \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 Authentication Middleware                \u2502 \u2502\n\u2502  \u2502 - JWT validation                         \u2502 \u2502\n\u2502  \u2502 - Claims extraction                      \u2502 \u2502\n\u2502  \u2502 - RBAC policy check                      \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                                                \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 AdminService Implementation              \u2502 \u2502\n\u2502  \u2502 - Configuration management               \u2502 \u2502\n\u2502  \u2502 - Session monitoring                     \u2502 \u2502\n\u2502  \u2502 - Backend health                         \u2502 \u2502\n\u2502  \u2502 - Operational commands                   \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                                                \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 Audit Logger                             \u2502 \u2502\n\u2502  \u2502 - Records actor + operation + result     \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,a.jsx)(n.h2,{id:"oidc-authentication-flow",children:"OIDC Authentication Flow"}),"\n",(0,a.jsx)(n.h3,{id:"token-acquisition",children:"Token Acquisition"}),"\n",(0,a.jsx)(n.mermaid,{value:'sequenceDiagram\n    participant Admin as Administrator\n    participant CLI as Admin CLI\n    participant OIDC as OIDC Provider<br/>(Okta/Auth0/Google)\n    participant API as Prism Admin API\n\n    Note over Admin,API: Initial Authentication\n\n    Admin->>CLI: prismctl namespace list\n    CLI->>CLI: Check token cache<br/>~/.prism/token\n\n    alt Token missing or expired\n        CLI->>OIDC: Device Code Flow:<br/>POST /oauth/device/code\n        OIDC--\x3e>CLI: device_code, user_code,<br/>verification_uri\n\n        CLI->>Admin: Open browser to:<br/>https://idp.example.com/activate<br/>Enter code: ABCD-1234\n\n        Admin->>OIDC: Navigate to verification_uri<br/>Enter user_code\n        OIDC->>Admin: Show consent screen\n        Admin->>OIDC: Approve scopes:<br/>- admin:read<br/>- admin:write\n\n        loop Poll for token (max 5 min)\n            CLI->>OIDC: POST /oauth/token<br/>{device_code, grant_type}\n            alt User approved\n                OIDC--\x3e>CLI: access_token (JWT),<br/>refresh_token, expires_in\n            else Still pending\n                OIDC--\x3e>CLI: {error: "authorization_pending"}\n            end\n        end\n\n        CLI->>CLI: Cache token to ~/.prism/token\n    end\n\n    Note over CLI,API: Authenticated Request\n\n    CLI->>API: gRPC: ListNamespaces()<br/>metadata:<br/>  authorization: Bearer eyJhbG...\n    API->>API: Validate JWT signature<br/>Check expiry<br/>Extract claims\n\n    alt JWT valid\n        API->>API: Check RBAC:<br/>user.email has admin:read?\n        API--\x3e>CLI: ListNamespacesResponse\n        API->>API: Audit log: alice@company.com<br/>listed namespaces\n    else JWT invalid/expired\n        API--\x3e>CLI: Unauthenticated (16)\n        CLI->>OIDC: Refresh token\n    end'}),"\n",(0,a.jsx)(n.h3,{id:"jwt-structure",children:"JWT Structure"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n  "header": {\n    "alg": "RS256",\n    "typ": "JWT",\n    "kid": "key-2024-10"\n  },\n  "payload": {\n    "iss": "https://idp.example.com",\n    "sub": "user:alice@company.com",\n    "aud": "prismctl-api",\n    "exp": 1696867200,\n    "iat": 1696863600,\n    "email": "alice@company.com",\n    "email_verified": true,\n    "groups": ["platform-team", "admins"],\n    "scope": "admin:read admin:write admin:operational"\n  },\n  "signature": "..."\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"token-validation",children:"Token Validation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"use jsonwebtoken::{decode, DecodingKey, Validation};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Claims {\n    pub sub: String,\n    pub email: String,\n    pub email_verified: bool,\n    pub groups: Vec<String>,\n    pub scope: String,\n    pub exp: u64,\n    pub iat: u64,\n}\n\npub struct JwtValidator {\n    issuer: String,\n    audience: String,\n    jwks_client: JwksClient,\n}\n\nimpl JwtValidator {\n    pub async fn validate_token(&self, token: &str) -> Result<Claims> {\n        // Decode header to get key ID\n        let header = decode_header(token)?;\n        let kid = header.kid.ok_or(Error::MissingKeyId)?;\n\n        // Fetch public key from JWKS endpoint\n        let jwk = self.jwks_client.get_key(&kid).await?;\n        let decoding_key = DecodingKey::from_jwk(&jwk)?;\n\n        // Validate signature and claims\n        let mut validation = Validation::new(jsonwebtoken::Algorithm::RS256);\n        validation.set_issuer(&[&self.issuer]);\n        validation.set_audience(&[&self.audience]);\n        validation.validate_exp = true;\n\n        let token_data = decode::<Claims>(token, &decoding_key, &validation)?;\n\n        // Additional validation\n        if !token_data.claims.email_verified {\n            return Err(Error::EmailNotVerified);\n        }\n\n        Ok(token_data.claims)\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"requestresponse-flows",children:"Request/Response Flows"}),"\n",(0,a.jsx)(n.h3,{id:"namespace-creation-flow",children:"Namespace Creation Flow"}),"\n",(0,a.jsx)(n.mermaid,{value:'sequenceDiagram\n    participant CLI as Admin CLI\n    participant Auth as Auth Middleware\n    participant Service as AdminService\n    participant Store as Config Store<br/>(Postgres)\n    participant Audit as Audit Logger\n\n    Note over CLI,Audit: Create Namespace Request\n\n    CLI->>Auth: CreateNamespace()<br/>metadata: authorization: Bearer JWT<br/>body: {name: "analytics", ...}\n\n    Auth->>Auth: Validate JWT\n    Auth->>Auth: Extract claims:<br/>email: alice@company.com<br/>groups: ["platform-team"]\n\n    Auth->>Auth: Check RBAC:<br/>Does alice have admin:write?\n\n    alt Authorized\n        Auth->>Service: Forward request with<br/>actor: alice@company.com\n\n        Service->>Store: BEGIN TRANSACTION\n        Service->>Store: INSERT INTO namespaces<br/>(name, description, quota, ...)\n\n        alt Namespace created\n            Store--\x3e>Service: Success\n            Service->>Store: INSERT INTO audit_log<br/>(actor, operation, namespace, ...)\n            Service->>Store: COMMIT\n\n            Service->>Audit: Log success:<br/>{actor: alice, operation: CreateNamespace,<br/>namespace: analytics, success: true}\n\n            Service--\x3e>CLI: CreateNamespaceResponse<br/>{namespace: {...}, created_at: ...}\n\n        else Namespace exists\n            Store--\x3e>Service: UniqueViolation error\n            Service->>Store: ROLLBACK\n\n            Service->>Audit: Log failure:<br/>{actor: alice, operation: CreateNamespace,<br/>namespace: analytics, success: false,<br/>error: "already exists"}\n\n            Service--\x3e>CLI: AlreadyExists (6)\n        end\n\n    else Not authorized\n        Auth->>Audit: Log denial:<br/>{actor: alice, operation: CreateNamespace,<br/>decision: deny, reason: "insufficient permissions"}\n\n        Auth--\x3e>CLI: PermissionDenied (7)\n    end'}),"\n",(0,a.jsx)(n.h3,{id:"session-monitoring-flow",children:"Session Monitoring Flow"}),"\n",(0,a.jsx)(n.mermaid,{value:'sequenceDiagram\n    participant CLI as Admin CLI\n    participant API as Admin API\n    participant SessionMgr as Session Manager\n    participant Metrics as Metrics Store\n\n    CLI->>API: ListSessions()<br/>{namespace: "user-api", status: ACTIVE}\n\n    API->>API: Authorize request\n\n    API->>SessionMgr: Query active sessions\n    SessionMgr->>SessionMgr: Filter by namespace + status\n\n    loop For each session\n        SessionMgr->>Metrics: Get session metrics<br/>(requests, bytes, last_activity)\n        Metrics--\x3e>SessionMgr: SessionMetrics\n    end\n\n    SessionMgr--\x3e>API: List of SessionInfo<br/>[{session_id, client_id, metrics}, ...]\n\n    API->>API: Audit log: alice listed sessions\n\n    API--\x3e>CLI: ListSessionsResponse<br/>{sessions: [...], total_count: 42}\n\n    CLI->>CLI: Format as table\n    CLI--\x3e>CLI: Display to admin'}),"\n",(0,a.jsx)(n.h3,{id:"backend-health-check-flow",children:"Backend Health Check Flow"}),"\n",(0,a.jsx)(n.mermaid,{value:'sequenceDiagram\n    participant CLI as Admin CLI\n    participant API as Admin API\n    participant HealthCheck as Health Checker\n    participant PG as Postgres\n    participant Kafka as Kafka\n    participant NATS as NATS\n\n    CLI->>API: GetBackendStatus()<br/>{backend_type: "all"}\n\n    API->>API: Authorize request\n\n    par Check Postgres\n        API->>HealthCheck: Check Postgres\n        HealthCheck->>PG: SELECT 1\n        alt Healthy\n            PG--\x3e>HealthCheck: Success (< 100ms)\n            HealthCheck--\x3e>API: HEALTHY\n        else Degraded\n            PG--\x3e>HealthCheck: Success (> 500ms)\n            HealthCheck--\x3e>API: DEGRADED\n        else Unhealthy\n            PG--xHealthCheck: Connection timeout\n            HealthCheck--\x3e>API: UNHEALTHY\n        end\n    and Check Kafka\n        API->>HealthCheck: Check Kafka\n        HealthCheck->>Kafka: List topics\n        Kafka--\x3e>HealthCheck: Success\n        HealthCheck--\x3e>API: HEALTHY\n    and Check NATS\n        API->>HealthCheck: Check NATS\n        HealthCheck->>NATS: Ping\n        NATS--\x3e>HealthCheck: Pong\n        HealthCheck--\x3e>API: HEALTHY\n    end\n\n    API->>API: Aggregate results\n    API->>API: Audit log: alice checked backend health\n\n    API--\x3e>CLI: GetBackendStatusResponse<br/>{<br/>  backends: [<br/>    {type: "postgres", status: HEALTHY, latency_ms: 2.3},<br/>    {type: "kafka", status: HEALTHY, latency_ms: 5.1},<br/>    {type: "nats", status: HEALTHY, latency_ms: 1.2}<br/>  ]<br/>}\n\n    CLI->>CLI: Format health summary\n    CLI--\x3e>CLI: Display to admin'}),"\n",(0,a.jsx)(n.h2,{id:"session-management",children:"Session Management"}),"\n",(0,a.jsx)(n.h3,{id:"session-lifecycle",children:"Session Lifecycle"}),"\n",(0,a.jsx)(n.p,{children:"Admin sessions support both interactive use (CLI) and automation (CI/CD):"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Interactive Session:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Acquire OIDC token via device code flow"}),"\n",(0,a.jsxs)(n.li,{children:["Token cached to ",(0,a.jsx)(n.code,{children:"~/.prism/token"})]}),"\n",(0,a.jsx)(n.li,{children:"Token expires after 1 hour (refresh_token extends to 7 days)"}),"\n",(0,a.jsx)(n.li,{children:"Automatic token refresh on expiry"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Automation Session:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Service account with client_credentials grant"}),"\n",(0,a.jsx)(n.li,{children:"Token expires after 1 hour (no refresh token)"}),"\n",(0,a.jsx)(n.li,{children:"Must re-authenticate for new token"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"session-establishment",children:"Session Establishment"}),"\n",(0,a.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant User as Administrator\n    participant CLI as Admin CLI\n    participant OIDC as OIDC Provider\n    participant API as Admin API\n\n    Note over User,API: First-time Setup\n\n    User->>CLI: prismctl login\n    CLI->>OIDC: Device code flow\n    OIDC--\x3e>CLI: device_code, verification_uri\n\n    CLI->>User: Please visit:<br/>https://idp.example.com/activate<br/>and enter code: WXYZ-5678\n\n    User->>OIDC: Complete authentication\n\n    CLI->>OIDC: Poll for token\n    OIDC--\x3e>CLI: access_token, refresh_token\n\n    CLI->>CLI: Save to ~/.prism/token:<br/>{<br/>  access_token,<br/>  refresh_token,<br/>  expires_at: <timestamp><br/>}\n\n    CLI--\x3e>User: \u2713 Authenticated as alice@company.com<br/>Token expires in 1 hour\n\n    Note over User,API: Subsequent Commands\n\n    User->>CLI: prismctl namespace list\n    CLI->>CLI: Load ~/.prism/token\n    CLI->>CLI: Check expiry\n\n    alt Token valid\n        CLI->>API: ListNamespaces()<br/>Authorization: Bearer <access_token>\n        API--\x3e>CLI: Response\n    else Token expired\n        CLI->>OIDC: POST /oauth/token<br/>{grant_type: refresh_token, ...}\n        OIDC--\x3e>CLI: New access_token\n        CLI->>CLI: Update ~/.prism/token\n        CLI->>API: ListNamespaces()<br/>Authorization: Bearer <new_token>\n        API--\x3e>CLI: Response\n    end"}),"\n",(0,a.jsx)(n.h2,{id:"grpc-protocol-specification",children:"gRPC Protocol Specification"}),"\n",(0,a.jsx)(n.h3,{id:"service-definition",children:"Service Definition"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-protobuf",children:'syntax = "proto3";\n\npackage prism.admin.v1;\n\nimport "google/protobuf/timestamp.proto";\nimport "google/protobuf/duration.proto";\nimport "google/protobuf/empty.proto";\n\nservice AdminService {\n  // Configuration Management\n  rpc ListConfigs(ListConfigsRequest) returns (ListConfigsResponse);\n  rpc GetConfig(GetConfigRequest) returns (GetConfigResponse);\n  rpc CreateConfig(CreateConfigRequest) returns (CreateConfigResponse);\n  rpc UpdateConfig(UpdateConfigRequest) returns (UpdateConfigResponse);\n  rpc DeleteConfig(DeleteConfigRequest) returns (DeleteConfigResponse);\n\n  // Namespace Management\n  rpc ListNamespaces(ListNamespacesRequest) returns (ListNamespacesResponse);\n  rpc CreateNamespace(CreateNamespaceRequest) returns (CreateNamespaceResponse);\n  rpc UpdateNamespace(UpdateNamespaceRequest) returns (UpdateNamespaceResponse);\n  rpc DeleteNamespace(DeleteNamespaceRequest) returns (DeleteNamespaceResponse);\n  rpc GetNamespace(GetNamespaceRequest) returns (GetNamespaceResponse);\n\n  // Session Management\n  rpc ListSessions(ListSessionsRequest) returns (ListSessionsResponse);\n  rpc GetSession(GetSessionRequest) returns (GetSessionResponse);\n  rpc TerminateSession(TerminateSessionRequest) returns (TerminateSessionResponse);\n\n  // Backend Health\n  rpc GetBackendStatus(GetBackendStatusRequest) returns (GetBackendStatusResponse);\n  rpc ListBackends(ListBackendsRequest) returns (ListBackendsResponse);\n\n  // Operational Commands\n  rpc SetMaintenanceMode(SetMaintenanceModeRequest) returns (SetMaintenanceModeResponse);\n  rpc DrainConnections(DrainConnectionsRequest) returns (DrainConnectionsResponse);\n  rpc GetMetrics(GetMetricsRequest) returns (GetMetricsResponse);\n\n  // Audit\n  rpc GetAuditLog(GetAuditLogRequest) returns (stream AuditLogEntry);\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"metadata-requirements",children:"Metadata Requirements"}),"\n",(0,a.jsx)(n.p,{children:"All requests must include:"}),"\n",(0,a.jsxs)(n.p,{children:["authorization: Bearer <jwt_token>\nrequest-id: ",(0,a.jsx)(n.uuid,{children:"  // Optional but recommended"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n### Error Codes\n\nStandard gRPC status codes:\n\n- `OK (0)`: Success\n- `INVALID_ARGUMENT (3)`: Invalid request parameters\n- `NOT_FOUND (5)`: Resource not found\n- `ALREADY_EXISTS (6)`: Resource already exists\n- `PERMISSION_DENIED (7)`: Insufficient permissions\n- `UNAUTHENTICATED (16)`: Missing or invalid JWT\n- `INTERNAL (13)`: Server error\n\n## RBAC Policy\n\n### Roles\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"roles:\nadmin:\ndescription: Full administrative access\npermissions:\n- admin:read\n- admin:write\n- admin:operational\n- admin:audit"}),"\n",(0,a.jsx)(n.p,{children:"operator:\ndescription: Operational tasks, read-only config\npermissions:\n- admin:read\n- admin:operational"}),"\n",(0,a.jsx)(n.p,{children:"viewer:\ndescription: Read-only access\npermissions:\n- admin:read"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n### Permission Mapping\n\n| Operation | Required Permission |\n|-----------|-------------------|\n| ListNamespaces | `admin:read` |\n| CreateNamespace | `admin:write` |\n| UpdateNamespace | `admin:write` |\n| DeleteNamespace | `admin:write` |\n| ListSessions | `admin:read` |\n| TerminateSession | `admin:operational` |\n| GetBackendStatus | `admin:read` |\n| SetMaintenanceMode | `admin:operational` |\n| DrainConnections | `admin:operational` |\n| GetAuditLog | `admin:audit` |\n\n### Authorization Middleware\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"use tonic::{Request, Status};\nuse tonic::metadata::MetadataMap;"}),"\n",(0,a.jsxs)(n.p,{children:["pub struct AuthInterceptor {\njwt_validator: Arc",(0,a.jsxs)(n.jwtvalidator,{children:[",\nrbac: Arc",(0,a.jsx)(n.rbacservice,{children:",\n}"})]})]}),"\n",(0,a.jsx)(n.p,{children:'impl AuthInterceptor {\npub async fn intercept(&self, mut req: Request<()>) -> Result<Request<()>, Status> {\n// Extract JWT from metadata\nlet token = req.metadata()\n.get("authorization")\n.and_then(|v| v.to_str().ok())\n.and_then(|s| s.strip_prefix("Bearer "))\n.ok_or_else(|| Status::unauthenticated("Missing authorization header"))?;'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'    // Validate JWT\n    let claims = self.jwt_validator.validate_token(token).await\n        .map_err(|e| Status::unauthenticated(format!("Invalid token: {}", e)))?;\n\n    // Extract required permission from method\n    let method = req.uri().path();\n    let required_permission = self.method_to_permission(method);\n\n    // Check RBAC\n    if !self.rbac.has_permission(&claims, &required_permission).await {\n        return Err(Status::permission_denied(format!(\n            "User {} lacks permission {}",\n            claims.email, required_permission\n        )));\n    }\n\n    // Inject claims into request extensions\n    req.extensions_mut().insert(claims);\n\n    Ok(req)\n}\n\nfn method_to_permission(&self, method: &str) -> String {\n    match method {\n        "/prism.admin.v1.AdminService/CreateNamespace" => "admin:write",\n        "/prism.admin.v1.AdminService/ListNamespaces" => "admin:read",\n        "/prism.admin.v1.AdminService/SetMaintenanceMode" => "admin:operational",\n        "/prism.admin.v1.AdminService/GetAuditLog" => "admin:audit",\n        _ => "admin:read",\n    }.to_string()\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"}"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n## Audit Logging\n\n### Audit Entry Structure\n\n"})}),"\n",(0,a.jsxs)(n.p,{children:["#[derive(Debug, Serialize)]\npub struct AuditLogEntry {\npub id: Uuid,\npub timestamp: DateTime",(0,a.jsxs)(n.utc,{children:[",\npub actor: String,              // Claims.email\npub actor_groups: Vec",(0,a.jsxs)(n.string,{children:[',  // Claims.groups\npub operation: String,           // "CreateNamespace"\npub resource_type: String,       // "namespace"\npub resource_id: String,         // "analytics"\npub namespace: Option',(0,a.jsxs)(n.string,{children:[",\npub request_id: Option",(0,a.jsxs)(n.string,{children:[",\npub success: bool,\npub error: Option",(0,a.jsx)(n.string,{children:",\npub metadata: serde_json::Value,\n}"})]})]})]})]})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n### Storage\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"CREATE TABLE admin_audit_log (\nid UUID PRIMARY KEY,\ntimestamp TIMESTAMPTZ NOT NULL,\nactor VARCHAR(255) NOT NULL,\nactor_groups TEXT[] NOT NULL,\noperation VARCHAR(255) NOT NULL,\nresource_type VARCHAR(100) NOT NULL,\nresource_id VARCHAR(255) NOT NULL,\nnamespace VARCHAR(255),\nrequest_id VARCHAR(100),\nsuccess BOOLEAN NOT NULL,\nerror TEXT,\nmetadata JSONB,"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"INDEX idx_audit_timestamp ON admin_audit_log(timestamp DESC),\nINDEX idx_audit_actor ON admin_audit_log(actor),\nINDEX idx_audit_operation ON admin_audit_log(operation),\nINDEX idx_audit_namespace ON admin_audit_log(namespace)\n"})}),"\n",(0,a.jsx)(n.p,{children:");"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n## Security Considerations\n\n### Network Isolation\n\n"})}),"\n",(0,a.jsx)(n.h1,{id:"kubernetes-networkpolicy",children:"Kubernetes NetworkPolicy"}),"\n",(0,a.jsx)(n.p,{children:"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\nname: prismctl-policy\nspec:\npodSelector:\nmatchLabels:\napp: prism-proxy\ningress:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["from:\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"podSelector:\nmatchLabels:\nrole: admin  # Only admin pods\nports:"}),"\n",(0,a.jsx)(n.li,{children:"protocol: TCP\nport: 8981"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n### Rate Limiting\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"use governor::{Quota, RateLimiter};"}),"\n",(0,a.jsxs)(n.p,{children:["pub struct RateLimitInterceptor {\nlimiter: Arc<RateLimiter",(0,a.jsx)(n.string,{children:">,  // Key: actor email\n}"})]}),"\n",(0,a.jsx)(n.p,{children:"impl RateLimitInterceptor {\npub fn new() -> Self {\n// 100 requests per minute per user\nlet quota = Quota::per_minute(NonZeroU32::new(100).unwrap());\nSelf {\nlimiter: Arc::new(RateLimiter::keyed(quota)),\n}\n}"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'pub async fn check(&self, claims: &Claims) -> Result<(), Status> {\n    if self.limiter.check_key(&claims.email).is_err() {\n        return Err(Status::resource_exhausted(format!(\n            "Rate limit exceeded for {}",\n            claims.email\n        )));\n    }\n    Ok(())\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"}"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n### TLS Configuration\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"use tonic::transport::{Server, ServerTlsConfig};"}),"\n",(0,a.jsx)(n.p,{children:"let tls_config = ServerTlsConfig::new()\n.identity(Identity::from_pem(cert_pem, key_pem))\n.client_ca_root(Certificate::from_pem(ca_pem));"}),"\n",(0,a.jsx)(n.p,{children:'Server::builder()\n.tls_config(tls_config)?\n.add_service(AdminServiceServer::new(admin_service))\n.serve("[::]:8981".parse()?)\n.await?;'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n## Deployment\n\n### Docker Compose\n\n"})}),"\n",(0,a.jsxs)(n.p,{children:['services:\nprism-proxy:\nimage: prism/proxy:latest\nports:\n- "8980:8980"  # Data plane\n- "8981:8981"  # Admin API (bind to internal network only)\nenvironment:\nPRISM_ADMIN_PORT: 8981\nPRISM_OIDC_ISSUER: ',(0,a.jsx)(n.a,{href:"https://idp.example.com",children:"https://idp.example.com"}),"\nPRISM_OIDC_AUDIENCE: prismctl-api\nPRISM_OIDC_JWKS_URI: ",(0,a.jsx)(n.a,{href:"https://idp.example.com/.well-known/jwks.json",children:"https://idp.example.com/.well-known/jwks.json"}),"\nnetworks:\n- internal  # Admin API not exposed publicly"]}),"\n",(0,a.jsx)(n.p,{children:"networks:\ninternal:\ninternal: true"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n### Kubernetes\n\n"})}),"\n",(0,a.jsx)(n.h2,{id:"apiversion-appsv1kind-deploymentmetadataname-prism-proxyspectemplatespeccontainers--name-proxyimage-prismproxyports--containerport-8980name-data--containerport-8981name-adminenv--name-prism_oidc_issuervaluefromsecretkeyrefname-prism-oidckey-issuer--name-prism_oidc_audiencevaluefromsecretkeyrefname-prism-oidckey-audience",children:"apiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: prism-proxy\nspec:\ntemplate:\nspec:\ncontainers:\n- name: proxy\nimage: prism/proxy:latest\nports:\n- containerPort: 8980\nname: data\n- containerPort: 8981\nname: admin\nenv:\n- name: PRISM_OIDC_ISSUER\nvalueFrom:\nsecretKeyRef:\nname: prism-oidc\nkey: issuer\n- name: PRISM_OIDC_AUDIENCE\nvalueFrom:\nsecretKeyRef:\nname: prism-oidc\nkey: audience"}),"\n",(0,a.jsx)(n.p,{children:"apiVersion: v1\nkind: Service\nmetadata:\nname: prismctl\nspec:\ntype: ClusterIP  # Internal only\nselector:\napp: prism-proxy\nports:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"port: 8981\ntargetPort: 8981\nname: admin"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"\n## Testing\n\n### Integration Tests\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"func TestAdminProtocol(t *testing.T) {\n// Start mock OIDC server\noidcServer := mockoidc.NewServer(t)\ndefer oidcServer.Close()"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'// Start Prism Admin API\nadminAPI := startAdminAPI(t, oidcServer.URL)\ndefer adminAPI.Close()\n\n// Acquire token\ntoken, err := oidcServer.AcquireToken(\n    "alice@example.com",\n    []string{"admin:read", "admin:write"},\n)\nrequire.NoError(t, err)\n\n// Create namespace\nconn, err := grpc.Dial(adminAPI.Address(),\n    grpc.WithTransportCredentials(insecure.NewCredentials()),\n    grpc.WithPerRPCCredentials(BearerToken{token}),\n)\nrequire.NoError(t, err)\ndefer conn.Close()\n\nclient := admin.NewAdminServiceClient(conn)\nresp, err := client.CreateNamespace(context.Background(), &admin.CreateNamespaceRequest{\n    Name: "test-namespace",\n    Description: "Test namespace",\n})\nrequire.NoError(t, err)\nassert.Equal(t, "test-namespace", resp.Namespace.Name)\n'})}),"\n",(0,a.jsx)(n.p,{children:"}"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:'\n## Open Questions\n\n1. **OIDC Provider Choice**: Support multiple providers (Okta, Auth0, Google, Azure AD)?\n   - **Feedback**: Yes, support AWS Cognito, Azure AD, Google, Okta, Auth0, and Dex\n   - Multi-provider support enables flexibility across different organizational setups\n   - Implementation approach:\n     - OIDC discovery endpoint (`.well-known/openid-configuration`) for automatic configuration\n     - Provider-specific configuration overrides for edge cases\n     - Common JWT validation logic across all providers\n   - **Provider Matrix**:\n     - **AWS Cognito**: User pools, federated identities, integrates with AWS IAM\n     - **Azure AD**: Enterprise identity, conditional access policies, group claims\n     - **Google Workspace**: Google SSO, organization-wide policies\n     - **Okta**: Enterprise SSO, MFA, rich group/role management\n     - **Auth0**: Developer-friendly, custom rules, social logins\n     - **Dex**: Self-hosted, LDAP/SAML connector, Kubernetes-native\n   - **Recommended**: Start with Dex (self-hosted, testing) and one enterprise provider (Okta/Azure AD)\n\n2. **Token Caching**: How long to cache validated JWTs before re-validating?\n   - **Feedback**: Is that up to us? Make it configurable, default to 24 hours. Do we have support for refreshing tokens?\n   - **Token Validation Caching**:\n     - Validated JWTs can be cached to reduce JWKS fetches and validation overhead\n     - Cache keyed by token hash, value contains validated claims\n     - **Recommended**: Cache until token expiry (not beyond), configurable max TTL\n     - Default: Cache for min(token.exp - now, 24 hours)\n   - **JWKS Caching**:\n     - Public keys from JWKS endpoint should be cached aggressively\n     - **Recommended**: Cache for 24 hours with background refresh\n     - Invalidate on signature validation failure (key rotation)\n   - **Refresh Token Support**:\n     - Yes, implement refresh token flow for long-lived CLI sessions\n     - Flow: When access_token expires, use refresh_token to get new access_token\n     - Refresh tokens stored securely in `~/.prism/token` (mode 0600)\n     - Configuration:\n       ```\n       token_cache:\n         jwt_validation_ttl: 24h  # How long to cache validated JWTs\n         jwks_cache_ttl: 24h      # How long to cache public keys\n         auto_refresh: true       # Automatically refresh expired tokens\n       ```text\n   - **Security Trade-offs**:\n     - Longer caching = better performance, but delayed revocation\n     - Shorter caching = more validation overhead, but faster revocation response\n     - **Recommended**: Default 24h for trusted environments, 1h for high-security\n\n3. **Offline Access**: Support for offline token validation (signed JWTs)?\n   - **Feedback**: Yes, discuss how, tradeoffs, and tech needed\n   - **Offline Validation Benefits**:\n     - No dependency on OIDC provider for every request (reduces latency)\n     - Proxy continues working during identity provider outage\n     - Reduces load on identity provider\n   - **How to Implement**:\n     - Cache JWKS (public keys) locally with periodic refresh\n     - Validate JWT signature using cached public keys\n     - Check standard claims (iss, aud, exp, nbf) locally\n     - **No online validation** = Can\'t check real-time revocation\n   - **Technology Stack**:\n     ```\n     use jsonwebtoken::{decode, DecodingKey, Validation, Algorithm};\n     use reqwest::Client;\n\n     pub struct OfflineValidator {\n         jwks_cache: Arc<RwLock<HashMap<String, Jwk>>>,\n         issuer: String,\n         audience: String,\n     }\n\n     impl OfflineValidator {\n         pub async fn validate(&self, token: &str) -> Result<Claims> {\n             let header = decode_header(token)?;\n             let kid = header.kid.ok_or(Error::MissingKeyId)?;\n\n             // Use cached key\n             let jwks = self.jwks_cache.read().await;\n             let jwk = jwks.get(&kid).ok_or(Error::UnknownKey)?;\n\n             // Validate offline (no network call)\n             let key = DecodingKey::from_jwk(jwk)?;\n             let mut validation = Validation::new(Algorithm::RS256);\n             validation.set_issuer(&[&self.issuer]);\n             validation.set_audience(&[&self.audience]);\n\n             let token_data = decode::<Claims>(token, &key, &validation)?;\n             Ok(token_data.claims)\n         }\n\n         // Periodic background refresh of JWKS\n         pub async fn refresh_jwks(&self) -> Result<()> {\n             let jwks_uri = format!("{}/.well-known/jwks.json", self.issuer);\n             let jwks: JwkSet = reqwest::get(&jwks_uri).await?.json().await?;\n\n             let mut cache = self.jwks_cache.write().await;\n             for jwk in jwks.keys {\n                 if let Some(kid) = &jwk.common.key_id {\n                     cache.insert(kid.clone(), jwk);\n                 }\n             }\n             Ok(())\n         }\n     }\n     ```text\n   - **Trade-offs**:\n     - \u2705 **Pros**: Lower latency, no OIDC dependency per-request, better availability\n     - \u274c **Cons**: Can\'t detect real-time revocation, stale keys if JWKS refresh fails\n   - **Security Considerations**:\n     - **Risk**: Revoked tokens remain valid until expiry\n     - **Mitigation**:\n       - Use short-lived access tokens (1 hour)\n       - Implement token revocation list (check periodically)\n       - Alert on JWKS refresh failures\n   - **Recommended**: Enable offline validation with 1-hour token expiry and background JWKS refresh every 6 hours\n\n4. **Multi-Tenancy**: How to map OIDC tenants to Prism namespaces?\n   - **Feedback**: Provide some options with tradeoffs\n   - **Option 1: Group-Based Mapping**\n     - Use OIDC group claims to authorize namespace access\n     - Example: Group `platform-team` \u2192 Can access all namespaces\n     - Example: Group `team-analytics` \u2192 Can access `analytics` namespace\n     - Configuration:\n       ```\n       namespace_access:\n         analytics:\n           groups: ["team-analytics", "platform-team"]\n         user-profiles:\n           groups: ["team-users", "platform-team"]\n       ```text\n     - **Pros**: Simple, leverages existing IdP groups, easy to understand\n     - **Cons**: Tight coupling to IdP group structure, requires group sync\n   - **Option 2: Claim-Based Mapping**\n     - Custom JWT claims define namespace access\n     - Example: `"namespaces": ["analytics", "user-profiles"]`\n     - IdP adds custom claims during token issuance\n     - Configuration:\n       ```\n       let authorized_namespaces = claims.custom\n           .get("namespaces")\n           .and_then(|v| v.as_array())\n           .map(|arr| arr.iter().filter_map(|v| v.as_str()).collect())\n           .unwrap_or_default();\n       ```text\n     - **Pros**: Explicit, no group interpretation needed, flexible\n     - **Cons**: Requires custom IdP configuration, claim size limits\n   - **Option 3: Dynamic RBAC with External Policy**\n     - JWT provides identity, external policy engine (OPA/Cedar) decides access\n     - Policy checks: `allow if user.email in namespace.allowed_users`\n     - Configuration:\n       ```\n       # OPA policy\n       allow {\n           input.user.email == "alice@company.com"\n           input.namespace == "analytics"\n       }\n\n       allow {\n           "platform-team" in input.user.groups\n       }\n       ```text\n     - **Pros**: Most flexible, centralized policy management, audit trail\n     - **Cons**: Additional dependency (OPA), higher latency, more complex\n   - **Option 4: Tenant-Scoped OIDC Providers**\n     - Each tenant has separate OIDC provider/application\n     - Token issuer determines namespace access\n     - Example: `iss: https://tenant-analytics.idp.com` \u2192 `analytics` namespace\n     - Configuration:\n       ```\n       namespaces:\n         analytics:\n           oidc_issuer: https://tenant-analytics.idp.com\n         user-profiles:\n           oidc_issuer: https://tenant-users.idp.com\n       ```text\n     - **Pros**: Strong isolation, tenant-specific policies, clear boundaries\n     - **Cons**: Complex setup, multiple IdP integrations, higher overhead\n   - **Comparison Table**:\n     | Approach | Complexity | Flexibility | Isolation | Performance |\n     |----------|-----------|------------|-----------|-------------|\n     | Group-Based | Low | Medium | Low | High |\n     | Claim-Based | Medium | High | Medium | High |\n     | External Policy | High | Very High | Medium | Medium |\n     | Tenant-Scoped | Very High | Low | Very High | Medium |\n   - **Recommended**: Start with **Group-Based** for simplicity, evolve to **External Policy (OPA)** for enterprise multi-tenancy\n\n5. **Service Accounts**: Best practices for automation tokens?\n   - **Feedback**: Include some recommendations and tradeoffs\n   - **Recommendation 1: OAuth2 Client Credentials Flow**\n     - Service accounts use client_id/client_secret to obtain tokens\n     - No user interaction required (headless authentication)\n     - Flow:\n       ```\n       curl -X POST https://idp.example.com/oauth/token \\\n         -H "Content-Type: application/x-www-form-urlencoded" \\\n         -d "grant_type=client_credentials" \\\n         -d "client_id=prism-ci-service" \\\n         -d "client_secret=<secret>" \\\n         -d "scope=admin:read admin:write"\n       ```text\n     - Configuration:\n       ```\n       # CI/CD environment\n       PRISM_CLIENT_ID=prism-ci-service\n       PRISM_CLIENT_SECRET=<secret>\n\n       # CLI auto-detects and uses client credentials\n       prismctl --auth=client-credentials namespace list\n       ```text\n     - **Pros**: Standard OAuth2 flow, widely supported, short-lived tokens\n     - **Cons**: Secret management required, no refresh tokens (must re-authenticate)\n   - **Recommendation 2: Long-Lived API Keys**\n     - Prism issues API keys directly (bypass OIDC for service accounts)\n     - Keys stored in database, validated by Prism (not IdP)\n     - Flow:\n       ```\n       # Generate key (admin operation)\n       prismctl serviceaccount create ci-deploy --scopes admin:write\n       # Returns: prism_key_abc123...\n\n       # Use key\n       export PRISM_API_KEY=prism_key_abc123...\n       prismctl namespace create prod-analytics\n       ```text\n     - Configuration:\n       ```\n       CREATE TABLE service_accounts (\n           id UUID PRIMARY KEY,\n           name VARCHAR(255) NOT NULL,\n           key_hash VARCHAR(255) NOT NULL,  -- bcrypt hash\n           scopes TEXT[] NOT NULL,\n           created_at TIMESTAMPTZ NOT NULL,\n           expires_at TIMESTAMPTZ,\n           last_used_at TIMESTAMPTZ\n       );\n       ```text\n     - **Pros**: Simple, no IdP dependency, fine-grained scopes\n     - **Cons**: Not standard OAuth2, custom implementation, key rotation complexity\n   - **Recommendation 3: Kubernetes Service Account Tokens**\n     - For K8s deployments, use projected service account tokens\n     - Tokens automatically rotated by Kubernetes\n     - Flow:\n       ```\n       # Pod spec\n       volumes:\n       - name: prism-token\n         projected:\n           sources:\n           - serviceAccountToken:\n               audience: prism-admin-api\n               expirationSeconds: 3600\n               path: token\n\n       # Mount at /var/run/secrets/prism/token\n       # CLI auto-detects and uses\n       ```text\n     - **Pros**: Automatic rotation, no secret management, K8s-native\n     - **Cons**: K8s-only, requires TokenRequest API, audience configuration\n   - **Recommendation 4: Short-Lived Tokens with Secure Storage**\n     - Store client credentials in secret manager (Vault/AWS Secrets Manager)\n     - Fetch credentials at runtime, obtain token, use, discard\n     - Configuration:\n       ```\n       # Fetch from Vault\n       export PRISM_CLIENT_SECRET=$(vault kv get -field=secret prism/ci-service)\n\n       # Obtain token (automatically by CLI)\n       prismctl namespace list\n       ```text\n     - **Pros**: Secrets never stored on disk, audit trail in secret manager\n     - **Cons**: Dependency on secret manager, additional latency\n   - **Comparison Table**:\n     | Approach | Security | Ease of Use | Rotation | K8s Native |\n     |----------|---------|------------|----------|-----------|\n     | Client Credentials | Medium | High | Manual | No |\n     | API Keys | Low-Medium | Very High | Manual | No |\n     | K8s SA Tokens | High | High | Automatic | Yes |\n     | Secret Manager | High | Medium | Automatic | No |\n   - **Recommended Practices**:\n     - \u2705 Use **Client Credentials** for general automation (CI/CD, scripts)\n     - \u2705 Use **K8s SA Tokens** for in-cluster automation (CronJobs, Operators)\n     - \u2705 Use **Secret Manager** for high-security environments\n     - \u274c Avoid long-lived API keys unless absolutely necessary\n     - \u2705 Implement token rotation (max 90 days)\n     - \u2705 Audit service account usage regularly\n     - \u2705 Use least-privilege scopes (e.g., `admin:read` for monitoring)\n\n## References\n\n- [OAuth 2.0 Device Authorization Grant](https://datatracker.ietf.org/doc/html/rfc8628)\n- [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html)\n- [JSON Web Token (JWT)](https://datatracker.ietf.org/doc/html/rfc7519)\n- [gRPC Authentication](https://grpc.io/docs/guides/auth/)\n- ADR-007: Authentication and Authorization\n- ADR-027: Admin API via gRPC\n- RFC-003: Admin Interface for Prism\n\n## Revision History\n\n- 2025-10-09: Initial draft with OIDC flows and sequence diagrams\n- 2025-10-09: Expanded open questions with feedback on multi-provider support (AWS/Azure/Google/Okta/Auth0/Dex), token caching (24h default with refresh token support), offline validation with JWKS caching, multi-tenancy mapping options (group/claim/OPA/tenant-scoped), and service account best practices (client credentials/API keys/K8s tokens/secret manager)\n\n'})})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);