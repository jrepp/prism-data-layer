"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[94554],{22074:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"adr-021","title":"Rust Structured Logging with Tracing","description":"Context","source":"@site/../docs-cms/adr/adr-021-rust-structured-logging.md","sourceDirName":".","slug":"/adr-021","permalink":"/prism-data-layer/adr/adr-021","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/adr-021-rust-structured-logging.md","tags":[{"inline":true,"label":"rust","permalink":"/prism-data-layer/adr/tags/rust"},{"inline":true,"label":"logging","permalink":"/prism-data-layer/adr/tags/logging"},{"inline":true,"label":"observability","permalink":"/prism-data-layer/adr/tags/observability"},{"inline":true,"label":"tracing","permalink":"/prism-data-layer/adr/tags/tracing"},{"inline":true,"label":"debugging","permalink":"/prism-data-layer/adr/tags/debugging"}],"version":"current","frontMatter":{"date":"2025-10-07T00:00:00.000Z","deciders":"Core Team","doc_uuid":"4cc3d02b-4023-431c-9dea-84d2d1c3e7c0","id":"adr-021","project_id":"prism-data-layer","status":"Accepted","tags":["rust","logging","observability","tracing","debugging"],"title":"Rust Structured Logging with Tracing"},"sidebar":"adrSidebar","previous":{"title":"Rust Testing Strategy \u2022 ADR-020","permalink":"/prism-data-layer/adr/adr-020"},"next":{"title":"Dynamic Client Configuration System \u2022 ADR-022","permalink":"/prism-data-layer/adr/adr-022"}}');var i=r(74848),s=r(28453);const a={date:new Date("2025-10-07T00:00:00.000Z"),deciders:"Core Team",doc_uuid:"4cc3d02b-4023-431c-9dea-84d2d1c3e7c0",id:"adr-021",project_id:"prism-data-layer",status:"Accepted",tags:["rust","logging","observability","tracing","debugging"],title:"Rust Structured Logging with Tracing"},c=void 0,l={},o=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Why tracing",id:"why-tracing",level:3},{value:"Architecture",id:"architecture",level:3}];function d(e){const n={backend:"backend",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",putresponse:"putresponse",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,i.jsx)(n.p,{children:"Prism proxy requires production-grade logging and observability:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Structured logging for machine parsing"}),"\n",(0,i.jsx)(n.li,{children:"Distributed tracing for request flows"}),"\n",(0,i.jsx)(n.li,{children:"Span context for debugging"}),"\n",(0,i.jsx)(n.li,{children:"High performance (minimal overhead on hot path)"}),"\n",(0,i.jsx)(n.li,{children:"Integration with OpenTelemetry"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,i.jsxs)(n.p,{children:["Use ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"tracing"})})," ecosystem for structured logging and distributed tracing:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"tracing"})," for instrumentation"]})," (spans, events, fields)"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"tracing-subscriber"})," for collection and formatting"]})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"tracing-opentelemetry"})," for distributed tracing"]})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Structured fields over string formatting"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Span context for request correlation"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"rationale",children:"Rationale"}),"\n",(0,i.jsx)(n.h3,{id:"why-tracing",children:"Why tracing"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"tracing"})," is the Rust standard for structured, contextual logging:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use tracing::{info, warn, error, instrument};\n\n#[instrument(skip(backend), fields(namespace = %namespace))]\nasync fn handle_put(namespace: &str, items: Vec<Item>, backend: &Backend) -> Result<()> {\n    info!(item_count = items.len(), "processing put request");\n\n    match backend.put(namespace, items).await {\n        Ok(_) => {\n            info!("put request completed successfully");\n            Ok(())\n        }\n        Err(e) => {\n            error!(error = %e, "put request failed");\n            Err(e)\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Structured by default"}),": Key-value pairs, not string formatting"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Span context"}),": Automatic request correlation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Zero-cost when disabled"}),": Compile-time filtering"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"OpenTelemetry integration"}),": Distributed tracing"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Async-aware"}),": Tracks spans across await points"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rich ecosystem"}),": formatters, filters, subscribers"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"architecture",children:"Architecture"}),"\n",(0,i.jsx)(n.p,{children:"Application Code\n\u2502\n\u251c\u2500 tracing::info!()      \u2500\u2510\n\u251c\u2500 tracing::error!()      \u2502 Events\n\u251c\u2500 #[instrument]          \u2502 + Spans\n\u2502                         \u2502\n\u25bc                         \u2502\nTracing Subscriber           \u2502\n\u2502                         \u2502\n\u251c\u2500 Layer: fmt (console)  \u2500\u2518\n\u251c\u2500 Layer: json (file)\n\u2514\u2500 Layer: opentelemetry (Jaeger/Tempo)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"\n### Subscriber Configuration\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"use tracing_subscriber::{fmt, EnvFilter, layer::SubscriberExt, util::SubscriberInitExt};"}),"\n",(0,i.jsx)(n.p,{children:'fn init_tracing() -> Result<()> {\nlet env_filter = EnvFilter::try_from_default_env()\n.or_else(|_| EnvFilter::try_new("info"))?;'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"let fmt_layer = fmt::layer()\n    .with_target(true)\n    .with_level(true)\n    .json();  // JSON output for production\n\n// For development: .pretty() or .compact()\n\ntracing_subscriber::registry()\n    .with(env_filter)\n    .with(fmt_layer)\n    .init();\n\nOk(())\n"})}),"\n",(0,i.jsx)(n.p,{children:"}"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"\n### Structured Events\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"use tracing::{info, warn, error, debug};"}),"\n",(0,i.jsx)(n.p,{children:'// Structured fields\ninfo!(\nnamespace = "production",\nitem_count = 42,\nduration_ms = 123,\n"request completed"\n);'}),"\n",(0,i.jsx)(n.p,{children:'// Error with context\nerror!(\nerror = %err,\nerror_debug = ?err,  // Debug representation\nnamespace = %namespace,\nretry_count = retries,\n"backend operation failed"\n);'}),"\n",(0,i.jsx)(n.p,{children:'// Debug with expensive computation (only evaluated if enabled)\ndebug!(\nitems = ?items,  // Debug representation\n"processing items"\n);'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"\n### Span Instrumentation\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"use tracing::{info_span, instrument, Instrument};"}),"\n",(0,i.jsxs)(n.p,{children:["// Automatic instrumentation with #[instrument]\n#[instrument(skip(backend), fields(namespace = %req.namespace))]\nasync fn handle_request(req: PutRequest, backend: Arc",(0,i.jsxs)(n.backend,{children:[") -> Result",(0,i.jsx)(n.putresponse,{children:' {\ninfo!("handling request");'})]})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'let result = backend.put(req.items).await?;\n\ninfo!(items_written = result.count, "request completed");\nOk(PutResponse { success: true })\n'})}),"\n",(0,i.jsx)(n.p,{children:"}"}),"\n",(0,i.jsx)(n.p,{children:'// Manual span\nasync fn manual_span_example() {\nlet span = info_span!("operation", operation = "migrate");\nasync {\ninfo!("starting migration");\n// ... work ...\ninfo!("migration complete");\n}\n.instrument(span)\n.await;\n}'}),"\n",(0,i.jsx)(n.p,{children:'// Span fields can be set dynamically\nlet span = info_span!("request", user_id = tracing::field::Empty);\nspan.record("user_id", &user_id);'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"\n### OpenTelemetry Integration\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"use opentelemetry::global;\nuse tracing_opentelemetry::OpenTelemetryLayer;\nuse opentelemetry_jaeger::JaegerPipeline;"}),"\n",(0,i.jsx)(n.p,{children:"async fn init_tracing_with_otel() -> Result<()> {\n// Configure OpenTelemetry exporter\nglobal::set_text_map_propagator(opentelemetry_jaeger::Propagator::new());"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'let tracer = opentelemetry_jaeger::new_pipeline()\n    .with_service_name("prism-proxy")\n    .install_batch(opentelemetry::runtime::Tokio)?;\n\nlet otel_layer = OpenTelemetryLayer::new(tracer);\n\nlet fmt_layer = fmt::layer().json();\n\ntracing_subscriber::registry()\n    .with(EnvFilter::from_default_env())\n    .with(fmt_layer)\n    .with(otel_layer)\n    .init();\n\nOk(())\n'})}),"\n",(0,i.jsx)(n.p,{children:"}"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"\n### Log Levels and Filtering\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"// Set via environment variable\n// RUST_LOG=prism_proxy=debug,sqlx=warn"}),"\n",(0,i.jsx)(n.p,{children:'// Or programmatically\nlet filter = EnvFilter::new("prism_proxy=debug")\n.add_directive("sqlx=warn".parse()?)\n.add_directive("tonic=info".parse()?);'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"\n### Performance: Conditional Logging\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"use tracing::Level;"}),"\n",(0,i.jsx)(n.p,{children:'// Only evaluate expensive computation if debug enabled\nif tracing::level_enabled!(Level::DEBUG) {\ndebug!(expensive_data = ?compute_expensive_debug_info(), "debug info");\n}'}),"\n",(0,i.jsx)(n.p,{children:'// Or use span guards for hot paths\nlet _span = info_span!("hot_path").entered();\n// Span only recorded if info level enabled'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"\n### Alternatives Considered\n\n1. **`log` crate**\n   - Pros: Simpler API, widely used\n   - Cons: No span context, no async support, less structured\n   - Rejected: tracing is superior for async and structured logging\n\n2. **`slog`**\n   - Pros: Mature, fast, structured\n   - Cons: More complex, less async integration\n   - Rejected: tracing is now the ecosystem standard\n\n3. **Custom logging**\n   - Pros: Full control\n   - Cons: Complex, reinventing the wheel\n   - Rejected: tracing ecosystem is battle-tested\n\n## Consequences\n\n### Positive\n\n- **Structured by default**: All logs are machine-parsable\n- **Span context**: Automatic request correlation\n- **Zero-cost abstraction**: No overhead when disabled\n- **OpenTelemetry integration**: Distributed tracing\n- **Async-aware**: Proper async span tracking\n- **Rich ecosystem**: Many formatters and exporters\n\n### Negative\n\n- **Learning curve**: More complex than simple logging\n- **Verbosity**: `#[instrument]` adds code\n- **Compile times**: Heavy macro usage can slow compilation\n\n### Neutral\n\n- Must configure subscriber at startup\n- Requires thoughtful span design\n\n## Implementation Notes\n\n### Dependencies\n\n"})}),"\n",(0,i.jsx)(n.p,{children:'[dependencies]\ntracing = "0.1"\ntracing-subscriber = { version = "0.3", features = ["json", "env-filter"] }\ntracing-opentelemetry = "0.22"\nopentelemetry = { version = "0.21", features = ["trace"] }\nopentelemetry-jaeger = { version = "0.20", features = ["rt-tokio"] }'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:'\n### Standard Fields\n\nAlways include:\n- `service.name`: "prism-proxy"\n- `service.version`: from Cargo.toml\n- `environment`: "production", "staging", "development"\n\n'})}),"\n",(0,i.jsx)(n.p,{children:"fn init_tracing() -> Result<()> {\ntracing_subscriber::registry()\n.with(EnvFilter::from_default_env())\n.with(\nfmt::layer()\n.json()\n.with_current_span(true)\n.with_span_list(true)\n)\n.init();"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Ok(())\n"})}),"\n",(0,i.jsx)(n.p,{children:"}"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"\n### Logging Guidelines\n\n**DO:**\n- Use `#[instrument]` on handler functions\n- Add structured fields, not string interpolation\n- Use appropriate log levels\n- Include error context with `error = %e`\n- Measure duration with spans\n\n**DON'T:**\n- Log in tight loops (use sample or aggregate)\n- Log sensitive data (PII, credentials)\n- Use string formatting (`format!()`) for fields\n- Over-instrument (every function doesn't need a span)\n\n### Testing with Tracing\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"#[cfg(test)]\nmod tests {\nuse tracing_subscriber::layer::SubscriberExt;\nuse tracing_subscriber::util::SubscriberInitExt;"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"#[tokio::test]\nasync fn test_with_tracing() {\n    // Initialize test subscriber\n    let subscriber = tracing_subscriber::registry()\n        .with(tracing_subscriber::fmt::layer().pretty());\n\n    tracing::subscriber::with_default(subscriber, || {\n        // Test code with tracing\n    });\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"}"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"\n## References\n\n- [tracing documentation](https://docs.rs/tracing)\n- [tracing-subscriber documentation](https://docs.rs/tracing-subscriber)\n- [tracing-opentelemetry](https://docs.rs/tracing-opentelemetry)\n- [Tokio Tracing Guide](https://tokio.rs/tokio/topics/tracing)\n- ADR-001: Rust for the Proxy\n- ADR-008: Observability Strategy\n- ADR-017: Go Structured Logging (parallel Go patterns)\n\n## Revision History\n\n- 2025-10-07: Initial draft and acceptance\n\n"})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>c});var t=r(96540);const i={},s=t.createContext(i);function a(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);