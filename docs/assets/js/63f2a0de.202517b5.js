"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[3388],{7252:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"rfc-025","title":"Pattern SDK Architecture - Backend Drivers and Concurrency Primitives","description":"Summary","source":"@site/../docs-cms/rfcs/rfc-025-pattern-sdk-architecture.md","sourceDirName":".","slug":"/rfc-025","permalink":"/prism-data-layer/rfc/rfc-025","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/rfcs/rfc-025-pattern-sdk-architecture.md","tags":[{"inline":true,"label":"patterns","permalink":"/prism-data-layer/rfc/tags/patterns"},{"inline":true,"label":"sdk","permalink":"/prism-data-layer/rfc/tags/sdk"},{"inline":true,"label":"architecture","permalink":"/prism-data-layer/rfc/tags/architecture"},{"inline":true,"label":"concurrency","permalink":"/prism-data-layer/rfc/tags/concurrency"},{"inline":true,"label":"drivers","permalink":"/prism-data-layer/rfc/tags/drivers"},{"inline":true,"label":"go","permalink":"/prism-data-layer/rfc/tags/go"}],"version":"current","frontMatter":{"author":"Platform Team","created":"2025-10-09T00:00:00.000Z","doc_uuid":"7c2e9e58-5e31-4245-a18e-d3858ee571cb","id":"rfc-025","project_id":"prism-data-layer","status":"Proposed","tags":["patterns","sdk","architecture","concurrency","drivers","go"],"title":"Pattern SDK Architecture - Backend Drivers and Concurrency Primitives","updated":"2025-10-09T00:00:00.000Z"},"sidebar":"rfcSidebar","previous":{"title":"Distributed Session Store Pattern - Cross-Region Session Management \u2022 RFC-024","permalink":"/prism-data-layer/rfc/rfc-024"},"next":{"title":"POC 1 - KeyValue with MemStore Implementation Plan (Original) \u2022 RFC-026","permalink":"/prism-data-layer/rfc/rfc-026"}}');var i=r(74848),s=r(28453);const a={author:"Platform Team",created:new Date("2025-10-09T00:00:00.000Z"),doc_uuid:"7c2e9e58-5e31-4245-a18e-d3858ee571cb",id:"rfc-025",project_id:"prism-data-layer",status:"Proposed",tags:["patterns","sdk","architecture","concurrency","drivers","go"],title:"Pattern SDK Architecture - Backend Drivers and Concurrency Primitives",updated:new Date("2025-10-09T00:00:00.000Z")},o="RFC-025: Pattern SDK Architecture",c={},l=[{value:"Summary",id:"summary",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Why &quot;Pattern&quot; not &quot;Plugin&quot;?",id:"why-pattern-not-plugin",level:3},{value:"Current Problem",id:"current-problem",level:3},{value:"Design Principles",id:"design-principles",level:2},{value:"1. Pattern Layer is the Star",id:"1-pattern-layer-is-the-star",level:3},{value:"2. Backend Drivers are Primitives",id:"2-backend-drivers-are-primitives",level:3},{value:"3. Concurrency Primitives are Reusable",id:"3-concurrency-primitives-are-reusable",level:3},{value:"Architecture",id:"architecture",level:2},{value:"Three-Layer Stack",id:"three-layer-stack",level:3},{value:"Pattern SDK File Structure",id:"pattern-sdk-file-structure",level:3},{value:"Concurrency Primitives",id:"concurrency-primitives",level:2},{value:"1. Worker Pool Pattern",id:"1-worker-pool-pattern",level:3},{value:"2. Fan-Out Pattern",id:"2-fan-out-pattern",level:3},{value:"3. Pipeline Pattern",id:"3-pipeline-pattern",level:3},{value:"4. Circuit Breaker Pattern",id:"4-circuit-breaker-pattern",level:3},{value:"5. Bulkhead Pattern",id:"5-bulkhead-pattern",level:3},{value:"Backend Driver Layer - Modular Design",id:"backend-driver-layer---modular-design",level:2},{value:"Critical Requirement: Independent Linkable Units",id:"critical-requirement-independent-linkable-units",level:3},{value:"Module Structure",id:"module-structure",level:3},{value:"Driver go.mod Example",id:"driver-gomod-example",level:3},{value:"Pattern go.mod Example (Only Imports What It Needs)",id:"pattern-gomod-example-only-imports-what-it-needs",level:3},{value:"Build Tags for Optional Features",id:"build-tags-for-optional-features",level:3},{value:"Driver Interface Definitions (Core SDK)",id:"driver-interface-definitions-core-sdk",level:3},{value:"Driver Registration Pattern (Dependency Inversion)",id:"driver-registration-pattern-dependency-inversion",level:3},{value:"Redis Driver Example",id:"redis-driver-example",level:3},{value:"Driver Bindings",id:"driver-bindings",level:3},{value:"Pattern Implementation Example",id:"pattern-implementation-example",level:2},{value:"Multicast Registry Pattern",id:"multicast-registry-pattern",level:3},{value:"Pattern Lifecycle Management",id:"pattern-lifecycle-management",level:2},{value:"Design Principles",id:"design-principles-1",level:3},{value:"Slot Configuration and Interface Matching",id:"slot-configuration-and-interface-matching",level:3},{value:"Pattern Lifecycle Structure",id:"pattern-lifecycle-structure",level:3},{value:"Pattern Implementation with Lifecycle",id:"pattern-implementation-with-lifecycle",level:3},{value:"Graceful Shutdown Flow",id:"graceful-shutdown-flow",level:3},{value:"Configuration Example",id:"configuration-example",level:3},{value:"Configuration Example",id:"configuration-example-1",level:2},{value:"Pattern Configuration",id:"pattern-configuration",level:3},{value:"Production Deployment Patterns",id:"production-deployment-patterns",level:2},{value:"Binary Size Comparison (Real Numbers)",id:"binary-size-comparison-real-numbers",level:3},{value:"Container Image Optimization",id:"container-image-optimization",level:3},{value:"Performance Optimization Strategies",id:"performance-optimization-strategies",level:3},{value:"1. Zero-Copy Operations",id:"1-zero-copy-operations",level:4},{value:"2. Object Pooling for Hot Paths",id:"2-object-pooling-for-hot-paths",level:4},{value:"3. Connection Pool Tuning Per Pattern",id:"3-connection-pool-tuning-per-pattern",level:4},{value:"Observability Middleware",id:"observability-middleware",level:3},{value:"Kubernetes Deployment",id:"kubernetes-deployment",level:3},{value:"Migration Path",id:"migration-path",level:2},{value:"Phase 1: Modular Driver Architecture (Week 1)",id:"phase-1-modular-driver-architecture-week-1",level:3},{value:"Phase 2: Concurrency Primitives (Week 2)",id:"phase-2-concurrency-primitives-week-2",level:3},{value:"Phase 3: Pattern Migration (Week 3)",id:"phase-3-pattern-migration-week-3",level:3},{value:"Phase 4: Observability &amp; Production (Week 4)",id:"phase-4-observability--production-week-4",level:3},{value:"Success Metrics",id:"success-metrics",level:3},{value:"Related Documents",id:"related-documents",level:2},{value:"Revision History",id:"revision-history",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"rfc-025-pattern-sdk-architecture",children:"RFC-025: Pattern SDK Architecture"})}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"Define the Pattern SDK architecture with clear separation between:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pattern Layer"}),": Complex business logic implementing data access patterns (Multicast Registry, Session Store, CDC, etc.)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Backend Driver Layer"}),": Shared Go drivers and bindings for all backend systems"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Concurrency Primitives"}),": Reusable Go channel patterns for robust multi-threaded pattern implementations"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Insight"}),': The pattern layer is where the innovation happens. Patterns are not simple "plugins" - they are sophisticated compositions of multiple backends with complex multi-threaded business logic solving real distributed systems problems.']}),"\n",(0,i.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,i.jsx)(n.h3,{id:"why-pattern-not-plugin",children:'Why "Pattern" not "Plugin"?'}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:'"Plugin" undersells the complexity and innovation'}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u274c ",(0,i.jsx)(n.strong,{children:"Plugin"}),": Suggests simple adapter or wrapper"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Pattern"}),": Captures the sophistication and composition"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Patterns are architectural solutions"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"Pattern: Multicast Registry\n\u251c\u2500\u2500 Business Logic: Identity registration, metadata enrichment, multicast publish\n\u251c\u2500\u2500 Backend Composition:\n\u2502   \u251c\u2500\u2500 Registry Backend (KeyValue with Scan) - stores identities\n\u2502   \u251c\u2500\u2500 Messaging Backend (PubSub) - delivers multicasts\n\u2502   \u2514\u2500\u2500 Durability Backend (Queue) - persists events\n\u251c\u2500\u2500 Concurrency: Worker pool for fan-out, circuit breakers for backends\n\u2514\u2500\u2500 Innovation: Same client API works with Redis+NATS, Postgres+Kafka, DynamoDB+SNS\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:'This is not a "plugin" - it\'s a distributed pattern implementation.'})}),"\n",(0,i.jsx)(n.h3,{id:"current-problem",children:"Current Problem"}),"\n",(0,i.jsx)(n.p,{children:"Without clear SDK architecture:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Code Duplication"}),": Each pattern reimplements worker pools, circuit breakers, backend connections"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Inconsistent Patterns"}),": No standard way to implement fan-out, bulkheading, retry logic"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Backend Coupling"}),": Patterns tightly coupled to specific backend implementations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"No Reuse"}),": Redis driver written for one pattern can't be used by another"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"design-principles",children:"Design Principles"}),"\n",(0,i.jsx)(n.h3,{id:"1-pattern-layer-is-the-star",children:"1. Pattern Layer is the Star"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Patterns solve business problems"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Multicast Registry: Service discovery + pub/sub"}),"\n",(0,i.jsx)(n.li,{children:"Session Store: Distributed state management"}),"\n",(0,i.jsx)(n.li,{children:"CDC: Change data capture and replication"}),"\n",(0,i.jsx)(n.li,{children:"Saga: Distributed transaction coordination"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Patterns compose backends"})," to implement solutions."]}),"\n",(0,i.jsx)(n.h3,{id:"2-backend-drivers-are-primitives",children:"2. Backend Drivers are Primitives"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Backend drivers are low-level"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// Backend driver = thin wrapper around native client\ntype RedisDriver struct {\n    client *redis.ClusterClient\n}\n\nfunc (d *RedisDriver) Get(ctx context.Context, key string) (string, error) {\n    return d.client.Get(ctx, key).Result()\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Patterns use drivers"})," to implement high-level operations:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// Pattern = business logic using multiple drivers\ntype MulticastRegistryPattern struct {\n    registry  *RedisDriver    // KeyValue backend\n    messaging *NATSDriver     // PubSub backend\n    workers   *WorkerPool     // Concurrency primitive\n}\n\nfunc (p *MulticastRegistryPattern) PublishMulticast(event Event) error {\n    // Step 1: Get subscribers from registry\n    subscribers, err := p.registry.Scan(ctx, "subscriber:*")\n\n    // Step 2: Fan-out to messaging backend via worker pool\n    return p.workers.FanOut(subscribers, func(sub Subscriber) error {\n        return p.messaging.Publish(sub.Topic, event)\n    })\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"3-concurrency-primitives-are-reusable",children:"3. Concurrency Primitives are Reusable"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Patterns need robust multi-threading"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Worker pools for parallel operations"}),"\n",(0,i.jsx)(n.li,{children:"Circuit breakers for fault tolerance"}),"\n",(0,i.jsx)(n.li,{children:"Bulkheads for resource isolation"}),"\n",(0,i.jsx)(n.li,{children:"Pipelines for stream processing"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"SDK provides battle-tested implementations"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,i.jsx)(n.h3,{id:"three-layer-stack",children:"Three-Layer Stack"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        PATTERN LAYER                             \u2502\n\u2502                  (Complex Business Logic)                        \u2502\n\u2502                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 Multicast        \u2502  \u2502 Session Store    \u2502  \u2502 CDC Pattern   \u2502 \u2502\n\u2502  \u2502 Registry Pattern \u2502  \u2502 Pattern          \u2502  \u2502               \u2502 \u2502\n\u2502  \u2502                  \u2502  \u2502                  \u2502  \u2502               \u2502 \u2502\n\u2502  \u2502 - Register       \u2502  \u2502 - Create         \u2502  \u2502 - Capture     \u2502 \u2502\n\u2502  \u2502 - Enumerate      \u2502  \u2502 - Get/Set        \u2502  \u2502 - Transform   \u2502 \u2502\n\u2502  \u2502 - Multicast      \u2502  \u2502 - Replicate      \u2502  \u2502 - Deliver     \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502\n            Uses concurrency primitives + backend drivers\n                             \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   CONCURRENCY PRIMITIVES                         \u2502\n\u2502                  (Reusable Go Patterns)                          \u2502\n\u2502                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u2502\n\u2502  \u2502 Worker Pool  \u2502  \u2502 Fan-Out      \u2502  \u2502 Pipeline     \u2502          \u2502\n\u2502  \u2502              \u2502  \u2502              \u2502  \u2502              \u2502          \u2502\n\u2502  \u2502 - Dispatch   \u2502  \u2502 - Broadcast  \u2502  \u2502 - Stage      \u2502          \u2502\n\u2502  \u2502 - Collect    \u2502  \u2502 - Gather     \u2502  \u2502 - Transform  \u2502          \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n\u2502                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u2502\n\u2502  \u2502 Circuit      \u2502  \u2502 Bulkhead     \u2502  \u2502 Retry        \u2502          \u2502\n\u2502  \u2502 Breaker      \u2502  \u2502              \u2502  \u2502              \u2502          \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502\n                 Uses backend drivers\n                             \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   BACKEND DRIVER LAYER                           \u2502\n\u2502              (Shared Go Clients + Interface Bindings)            \u2502\n\u2502                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u2502\n\u2502  \u2502 Redis Driver \u2502  \u2502 Postgres     \u2502  \u2502 Kafka Driver \u2502          \u2502\n\u2502  \u2502              \u2502  \u2502 Driver       \u2502  \u2502              \u2502          \u2502\n\u2502  \u2502 - Get/Set    \u2502  \u2502              \u2502  \u2502 - Produce    \u2502          \u2502\n\u2502  \u2502 - Scan       \u2502  \u2502 - Query      \u2502  \u2502 - Consume    \u2502          \u2502\n\u2502  \u2502 - Pub/Sub    \u2502  \u2502 - Subscribe  \u2502  \u2502 - Commit     \u2502          \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n\u2502                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u2502\n\u2502  \u2502 NATS Driver  \u2502  \u2502 ClickHouse   \u2502  \u2502 S3 Driver    \u2502          \u2502\n\u2502  \u2502              \u2502  \u2502 Driver       \u2502  \u2502              \u2502          \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,i.jsx)(n.h3,{id:"pattern-sdk-file-structure",children:"Pattern SDK File Structure"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"pattern-sdk/\n\u251c\u2500\u2500 README.md                          # SDK overview\n\u251c\u2500\u2500 go.mod                             # Go module definition\n\u2502\n\u251c\u2500\u2500 patterns/                          # PATTERN LAYER (innovation spotlight)\n\u2502   \u251c\u2500\u2500 multicast_registry/            # Multicast Registry pattern\n\u2502   \u2502   \u251c\u2500\u2500 pattern.go                 # Main pattern implementation\n\u2502   \u2502   \u251c\u2500\u2500 registry.go                # Identity registration logic\n\u2502   \u2502   \u251c\u2500\u2500 multicast.go               # Multicast publish logic\n\u2502   \u2502   \u251c\u2500\u2500 config.go                  # Pattern configuration\n\u2502   \u2502   \u2514\u2500\u2500 pattern_test.go            # Pattern tests\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 session_store/                 # Session Store pattern\n\u2502   \u2502   \u251c\u2500\u2500 pattern.go                 # Distributed session management\n\u2502   \u2502   \u251c\u2500\u2500 replication.go             # Cross-region replication\n\u2502   \u2502   \u251c\u2500\u2500 sharding.go                # Consistent hashing\n\u2502   \u2502   \u2514\u2500\u2500 pattern_test.go\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 cdc/                           # Change Data Capture pattern\n\u2502   \u2502   \u251c\u2500\u2500 pattern.go                 # CDC implementation\n\u2502   \u2502   \u251c\u2500\u2500 capture.go                 # Change capture logic\n\u2502   \u2502   \u251c\u2500\u2500 transform.go               # Event transformation\n\u2502   \u2502   \u2514\u2500\u2500 pattern_test.go\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 saga/                          # Saga pattern (future)\n\u2502       \u2514\u2500\u2500 pattern.go\n\u2502\n\u251c\u2500\u2500 concurrency/                       # CONCURRENCY PRIMITIVES\n\u2502   \u251c\u2500\u2500 worker_pool.go                 # Worker pool pattern\n\u2502   \u251c\u2500\u2500 fan_out.go                     # Fan-out/fan-in\n\u2502   \u251c\u2500\u2500 pipeline.go                    # Pipeline stages\n\u2502   \u251c\u2500\u2500 circuit_breaker.go             # Circuit breaker\n\u2502   \u251c\u2500\u2500 bulkhead.go                    # Bulkhead isolation\n\u2502   \u251c\u2500\u2500 retry.go                       # Retry with backoff\n\u2502   \u2514\u2500\u2500 concurrency_test.go\n\u2502\n\u251c\u2500\u2500 drivers/                           # BACKEND DRIVER LAYER\n\u2502   \u251c\u2500\u2500 redis/                         # Redis backend driver\n\u2502   \u2502   \u251c\u2500\u2500 driver.go                  # Redis driver implementation\n\u2502   \u2502   \u251c\u2500\u2500 cluster.go                 # Cluster support\n\u2502   \u2502   \u251c\u2500\u2500 pubsub.go                  # Redis Pub/Sub\n\u2502   \u2502   \u251c\u2500\u2500 bindings.go                # Interface bindings\n\u2502   \u2502   \u2514\u2500\u2500 driver_test.go\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 postgres/                      # PostgreSQL backend driver\n\u2502   \u2502   \u251c\u2500\u2500 driver.go                  # Postgres driver\n\u2502   \u2502   \u251c\u2500\u2500 query.go                   # Query execution\n\u2502   \u2502   \u251c\u2500\u2500 subscribe.go               # LISTEN/NOTIFY\n\u2502   \u2502   \u251c\u2500\u2500 bindings.go                # Interface bindings\n\u2502   \u2502   \u2514\u2500\u2500 driver_test.go\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 kafka/                         # Kafka backend driver\n\u2502   \u2502   \u251c\u2500\u2500 driver.go                  # Kafka driver\n\u2502   \u2502   \u251c\u2500\u2500 producer.go                # Kafka producer\n\u2502   \u2502   \u251c\u2500\u2500 consumer.go                # Kafka consumer\n\u2502   \u2502   \u251c\u2500\u2500 bindings.go                # Interface bindings\n\u2502   \u2502   \u2514\u2500\u2500 driver_test.go\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 nats/                          # NATS backend driver\n\u2502   \u2502   \u251c\u2500\u2500 driver.go\n\u2502   \u2502   \u251c\u2500\u2500 bindings.go\n\u2502   \u2502   \u2514\u2500\u2500 driver_test.go\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 clickhouse/                    # ClickHouse backend driver\n\u2502   \u2502   \u251c\u2500\u2500 driver.go\n\u2502   \u2502   \u251c\u2500\u2500 bindings.go\n\u2502   \u2502   \u2514\u2500\u2500 driver_test.go\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 s3/                            # S3 backend driver\n\u2502   \u2502   \u251c\u2500\u2500 driver.go\n\u2502   \u2502   \u251c\u2500\u2500 bindings.go\n\u2502   \u2502   \u2514\u2500\u2500 driver_test.go\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 interfaces.go                  # Interface definitions (from MEMO-006)\n\u2502\n\u251c\u2500\u2500 auth/                              # Authentication (existing)\n\u2502   \u2514\u2500\u2500 token_validator.go\n\u2502\n\u251c\u2500\u2500 authz/                             # Authorization (existing)\n\u2502   \u251c\u2500\u2500 authorizer.go\n\u2502   \u251c\u2500\u2500 topaz_client.go\n\u2502   \u251c\u2500\u2500 vault_client.go\n\u2502   \u2514\u2500\u2500 audit_logger.go\n\u2502\n\u251c\u2500\u2500 observability/                     # Observability (existing)\n\u2502   \u251c\u2500\u2500 metrics.go\n\u2502   \u251c\u2500\u2500 tracing.go\n\u2502   \u2514\u2500\u2500 logging.go\n\u2502\n\u2514\u2500\u2500 testing/                           # Testing utilities (existing)\n    \u251c\u2500\u2500 mocks.go\n    \u2514\u2500\u2500 testcontainers.go\n"})}),"\n",(0,i.jsx)(n.h2,{id:"concurrency-primitives",children:"Concurrency Primitives"}),"\n",(0,i.jsx)(n.h3,{id:"1-worker-pool-pattern",children:"1. Worker Pool Pattern"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Case"}),": Parallel execution of independent tasks with bounded concurrency."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// concurrency/worker_pool.go\npackage concurrency\n\nimport (\n    "context"\n    "sync"\n)\n\n// WorkerPool manages a pool of workers for parallel task execution\ntype WorkerPool struct {\n    workers   int\n    taskQueue chan Task\n    wg        sync.WaitGroup\n    errors    chan error\n}\n\ntype Task func(ctx context.Context) error\n\n// NewWorkerPool creates a worker pool with specified worker count\nfunc NewWorkerPool(workers int) *WorkerPool {\n    return &WorkerPool{\n        workers:   workers,\n        taskQueue: make(chan Task, workers*2),\n        errors:    make(chan error, workers),\n    }\n}\n\n// Start begins worker goroutines\nfunc (wp *WorkerPool) Start(ctx context.Context) {\n    for i := 0; i < wp.workers; i++ {\n        wp.wg.Add(1)\n        go wp.worker(ctx)\n    }\n}\n\n// Submit adds a task to the queue\nfunc (wp *WorkerPool) Submit(task Task) {\n    wp.taskQueue <- task\n}\n\n// Wait blocks until all tasks complete\nfunc (wp *WorkerPool) Wait() []error {\n    close(wp.taskQueue)\n    wp.wg.Wait()\n    close(wp.errors)\n\n    // Collect all errors\n    var errs []error\n    for err := range wp.errors {\n        errs = append(errs, err)\n    }\n    return errs\n}\n\nfunc (wp *WorkerPool) worker(ctx context.Context) {\n    defer wp.wg.Done()\n\n    for task := range wp.taskQueue {\n        if err := task(ctx); err != nil {\n            wp.errors <- err\n        }\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pattern Usage Example"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// patterns/multicast_registry/multicast.go\n\nfunc (p *MulticastRegistryPattern) PublishMulticast(ctx context.Context, event Event) error {\n    // Get all subscribers\n    subscribers, err := p.registry.GetSubscribers(ctx, event.Topic)\n    if err != nil {\n        return err\n    }\n\n    // Create worker pool for parallel delivery\n    pool := concurrency.NewWorkerPool(10)\n    pool.Start(ctx)\n\n    // Submit delivery tasks\n    for _, sub := range subscribers {\n        subscriber := sub // Capture loop variable\n        pool.Submit(func(ctx context.Context) error {\n            return p.messaging.Publish(ctx, subscriber.Endpoint, event)\n        })\n    }\n\n    // Wait for all deliveries\n    errs := pool.Wait()\n    if len(errs) > 0 {\n        return fmt.Errorf("multicast failed: %d/%d deliveries failed", len(errs), len(subscribers))\n    }\n\n    return nil\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"2-fan-out-pattern",children:"2. Fan-Out Pattern"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Case"}),": Broadcast operation to multiple destinations, gather results."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// concurrency/fan_out.go\npackage concurrency\n\nimport (\n    "context"\n    "sync"\n)\n\ntype Result struct {\n    Index int\n    Value interface{}\n    Error error\n}\n\n// FanOut executes function against all inputs in parallel, gathers results\nfunc FanOut(ctx context.Context, inputs []interface{}, fn func(context.Context, interface{}) (interface{}, error)) []Result {\n    results := make([]Result, len(inputs))\n    var wg sync.WaitGroup\n\n    for i, input := range inputs {\n        wg.Add(1)\n        go func(index int, inp interface{}) {\n            defer wg.Done()\n\n            value, err := fn(ctx, inp)\n            results[index] = Result{\n                Index: index,\n                Value: value,\n                Error: err,\n            }\n        }(i, input)\n    }\n\n    wg.Wait()\n    return results\n}\n\n// FanOutWithLimit executes with bounded concurrency\nfunc FanOutWithLimit(ctx context.Context, inputs []interface{}, limit int, fn func(context.Context, interface{}) (interface{}, error)) []Result {\n    results := make([]Result, len(inputs))\n    semaphore := make(chan struct{}, limit)\n    var wg sync.WaitGroup\n\n    for i, input := range inputs {\n        wg.Add(1)\n        go func(index int, inp interface{}) {\n            defer wg.Done()\n\n            // Acquire semaphore slot\n            semaphore <- struct{}{}\n            defer func() { <-semaphore }()\n\n            value, err := fn(ctx, inp)\n            results[index] = Result{\n                Index: index,\n                Value: value,\n                Error: err,\n            }\n        }(i, input)\n    }\n\n    wg.Wait()\n    return results\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pattern Usage Example"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// patterns/session_store/replication.go\n\nfunc (p *SessionStorePattern) ReplicateToRegions(ctx context.Context, session SessionData) error {\n    regions := p.config.ReplicationRegions\n\n    // Fan-out to all regions in parallel\n    results := concurrency.FanOut(ctx, toInterfaces(regions), func(ctx context.Context, r interface{}) (interface{}, error) {\n        region := r.(string)\n        return nil, p.drivers[region].Set(ctx, session.SessionID, session)\n    })\n\n    // Check for failures\n    var failed []string\n    for _, result := range results {\n        if result.Error != nil {\n            region := regions[result.Index]\n            failed = append(failed, region)\n        }\n    }\n\n    if len(failed) > 0 {\n        return fmt.Errorf("replication failed to regions: %v", failed)\n    }\n\n    return nil\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"3-pipeline-pattern",children:"3. Pipeline Pattern"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Case"}),": Stream processing with multiple transformation stages."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// concurrency/pipeline.go\npackage concurrency\n\nimport (\n    "context"\n)\n\ntype Stage func(context.Context, <-chan interface{}) <-chan interface{}\n\n// Pipeline creates a processing pipeline with multiple stages\nfunc Pipeline(ctx context.Context, input <-chan interface{}, stages ...Stage) <-chan interface{} {\n    output := input\n\n    for _, stage := range stages {\n        output = stage(ctx, output)\n    }\n\n    return output\n}\n\n// Generator creates initial input channel from slice\nfunc Generator(ctx context.Context, values []interface{}) <-chan interface{} {\n    out := make(chan interface{})\n\n    go func() {\n        defer close(out)\n        for _, v := range values {\n            select {\n            case out <- v:\n            case <-ctx.Done():\n                return\n            }\n        }\n    }()\n\n    return out\n}\n\n// Collector gathers pipeline output into slice\nfunc Collector(ctx context.Context, input <-chan interface{}) []interface{} {\n    var results []interface{}\n\n    for v := range input {\n        results = append(results, v)\n    }\n\n    return results\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pattern Usage Example"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// patterns/cdc/pattern.go\n\nfunc (p *CDCPattern) ProcessChanges(ctx context.Context, changes []Change) error {\n    // Stage 1: Filter relevant changes\n    filter := func(ctx context.Context, in <-chan interface{}) <-chan interface{} {\n        out := make(chan interface{})\n        go func() {\n            defer close(out)\n            for v := range in {\n                change := v.(Change)\n                if p.shouldProcess(change) {\n                    out <- change\n                }\n            }\n        }()\n        return out\n    }\n\n    // Stage 2: Transform to events\n    transform := func(ctx context.Context, in <-chan interface{}) <-chan interface{} {\n        out := make(chan interface{})\n        go func() {\n            defer close(out)\n            for v := range in {\n                change := v.(Change)\n                event := p.transformToEvent(change)\n                out <- event\n            }\n        }()\n        return out\n    }\n\n    // Stage 3: Deliver to destination\n    deliver := func(ctx context.Context, in <-chan interface{}) <-chan interface{} {\n        out := make(chan interface{})\n        go func() {\n            defer close(out)\n            for v := range in {\n                event := v.(Event)\n                p.destination.Publish(ctx, event)\n                out <- event\n            }\n        }()\n        return out\n    }\n\n    // Build pipeline\n    input := concurrency.Generator(ctx, toInterfaces(changes))\n    output := concurrency.Pipeline(ctx, input, filter, transform, deliver)\n\n    // Collect results\n    results := concurrency.Collector(ctx, output)\n\n    log.Printf("Processed %d changes", len(results))\n    return nil\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"4-circuit-breaker-pattern",children:"4. Circuit Breaker Pattern"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Case"}),": Fault tolerance - fail fast when backend is unhealthy."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// concurrency/circuit_breaker.go\npackage concurrency\n\nimport (\n    "context"\n    "errors"\n    "sync"\n    "time"\n)\n\nvar ErrCircuitOpen = errors.New("circuit breaker is open")\n\ntype State int\n\nconst (\n    StateClosed State = iota  // Normal operation\n    StateOpen                  // Failing, reject requests\n    StateHalfOpen             // Testing recovery\n)\n\ntype CircuitBreaker struct {\n    maxFailures  int\n    resetTimeout time.Duration\n\n    state        State\n    failures     int\n    lastFailTime time.Time\n    mu           sync.RWMutex\n}\n\nfunc NewCircuitBreaker(maxFailures int, resetTimeout time.Duration) *CircuitBreaker {\n    return &CircuitBreaker{\n        maxFailures:  maxFailures,\n        resetTimeout: resetTimeout,\n        state:        StateClosed,\n    }\n}\n\nfunc (cb *CircuitBreaker) Call(ctx context.Context, fn func() error) error {\n    cb.mu.RLock()\n    state := cb.state\n    cb.mu.RUnlock()\n\n    // Check if circuit is open\n    if state == StateOpen {\n        cb.mu.Lock()\n        if time.Since(cb.lastFailTime) > cb.resetTimeout {\n            // Try half-open state\n            cb.state = StateHalfOpen\n            cb.mu.Unlock()\n        } else {\n            cb.mu.Unlock()\n            return ErrCircuitOpen\n        }\n    }\n\n    // Execute function\n    err := fn()\n\n    cb.mu.Lock()\n    defer cb.mu.Unlock()\n\n    if err != nil {\n        cb.failures++\n        cb.lastFailTime = time.Now()\n\n        if cb.failures >= cb.maxFailures {\n            cb.state = StateOpen\n        }\n\n        return err\n    }\n\n    // Success - reset circuit\n    cb.failures = 0\n    cb.state = StateClosed\n    return nil\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pattern Usage Example"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// patterns/multicast_registry/pattern.go\n\ntype MulticastRegistryPattern struct {\n    registry  *drivers.RedisDriver\n    messaging *drivers.NATSDriver\n\n    // Circuit breakers for each backend\n    registryBreaker  *concurrency.CircuitBreaker\n    messagingBreaker *concurrency.CircuitBreaker\n}\n\nfunc (p *MulticastRegistryPattern) Register(ctx context.Context, identity Identity) error {\n    // Use circuit breaker to protect registry backend\n    return p.registryBreaker.Call(ctx, func() error {\n        return p.registry.Set(ctx, identity.ID, identity)\n    })\n}\n\nfunc (p *MulticastRegistryPattern) PublishMulticast(ctx context.Context, event Event) error {\n    // Use circuit breaker to protect messaging backend\n    return p.messagingBreaker.Call(ctx, func() error {\n        return p.messaging.Publish(ctx, event.Topic, event)\n    })\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"5-bulkhead-pattern",children:"5. Bulkhead Pattern"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Case"}),": Resource isolation - limit concurrent operations per backend."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// concurrency/bulkhead.go\npackage concurrency\n\nimport (\n    "context"\n    "errors"\n    "time"\n)\n\nvar ErrBulkheadFull = errors.New("bulkhead capacity exceeded")\n\ntype Bulkhead struct {\n    semaphore chan struct{}\n    timeout   time.Duration\n}\n\nfunc NewBulkhead(capacity int, timeout time.Duration) *Bulkhead {\n    return &Bulkhead{\n        semaphore: make(chan struct{}, capacity),\n        timeout:   timeout,\n    }\n}\n\nfunc (b *Bulkhead) Execute(ctx context.Context, fn func() error) error {\n    // Try to acquire slot\n    select {\n    case b.semaphore <- struct{}{}:\n        defer func() { <-b.semaphore }()\n        return fn()\n\n    case <-time.After(b.timeout):\n        return ErrBulkheadFull\n\n    case <-ctx.Done():\n        return ctx.Err()\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pattern Usage Example"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// patterns/session_store/pattern.go\n\ntype SessionStorePattern struct {\n    drivers map[string]*drivers.RedisDriver\n\n    // Bulkheads per region to prevent resource exhaustion\n    bulkheads map[string]*concurrency.Bulkhead\n}\n\nfunc (p *SessionStorePattern) GetSession(ctx context.Context, region, sessionID string) (*SessionData, error) {\n    bulkhead := p.bulkheads[region]\n\n    var session *SessionData\n    err := bulkhead.Execute(ctx, func() error {\n        var err error\n        session, err = p.drivers[region].Get(ctx, sessionID)\n        return err\n    })\n\n    return session, err\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"backend-driver-layer---modular-design",children:"Backend Driver Layer - Modular Design"}),"\n",(0,i.jsx)(n.h3,{id:"critical-requirement-independent-linkable-units",children:"Critical Requirement: Independent Linkable Units"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Problem"}),": Monolithic SDKs that import all drivers create bloated binaries with unnecessary dependencies."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Solution"}),": Each driver is a ",(0,i.jsx)(n.strong,{children:"separate Go module"})," that can be independently linked at compile time."]}),"\n",(0,i.jsx)(n.h3,{id:"module-structure",children:"Module Structure"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"Core SDK (no backend dependencies):\ngithub.com/prism/pattern-sdk/v1\n\u251c\u2500\u2500 interfaces/         # Interface definitions only\n\u251c\u2500\u2500 concurrency/        # Concurrency primitives\n\u251c\u2500\u2500 auth/              # Auth utilities\n\u251c\u2500\u2500 authz/             # Authorization utilities\n\u2514\u2500\u2500 patterns/          # Pattern implementations (import drivers as needed)\n\nSeparate driver modules (independently versioned):\ngithub.com/prism/pattern-sdk-drivers/redis/v1\ngithub.com/prism/pattern-sdk-drivers/postgres/v1\ngithub.com/prism/pattern-sdk-drivers/kafka/v1\ngithub.com/prism/pattern-sdk-drivers/nats/v1\ngithub.com/prism/pattern-sdk-drivers/clickhouse/v1\ngithub.com/prism/pattern-sdk-drivers/s3/v1\n"})}),"\n",(0,i.jsx)(n.h3,{id:"driver-gomod-example",children:"Driver go.mod Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// github.com/prism/pattern-sdk-drivers/redis/go.mod\nmodule github.com/prism/pattern-sdk-drivers/redis\n\ngo 1.21\n\nrequire (\n    github.com/go-redis/redis/v8 v8.11.5\n    github.com/prism/pattern-sdk v1.0.0  // Only core interfaces\n)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"pattern-gomod-example-only-imports-what-it-needs",children:"Pattern go.mod Example (Only Imports What It Needs)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// patterns/multicast-registry/go.mod\nmodule github.com/prism/patterns/multicast-registry\n\ngo 1.21\n\nrequire (\n    github.com/prism/pattern-sdk v1.0.0\n    github.com/prism/pattern-sdk-drivers/redis v1.2.0    // ONLY Redis\n    github.com/prism/pattern-sdk-drivers/nats v1.0.0     // ONLY NATS\n    // NO postgres, kafka, clickhouse, s3, etc.\n)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Result"}),": Binary only includes Redis and NATS client code. 90% size reduction vs monolithic approach."]}),"\n",(0,i.jsx)(n.h3,{id:"build-tags-for-optional-features",children:"Build Tags for Optional Features"}),"\n",(0,i.jsx)(n.p,{children:"Use Go build tags for optional driver features:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// drivers/redis/cluster.go\n// +build redis_cluster\n\npackage redis\n\n// Cluster-specific code only included when built with -tags redis_cluster\n"})}),"\n",(0,i.jsx)(n.p,{children:"Build commands:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Basic Redis support\ngo build -o pattern ./cmd/multicast-registry\n\n# Redis + Cluster support\ngo build -tags redis_cluster -o pattern ./cmd/multicast-registry\n\n# Multiple tags\ngo build -tags "redis_cluster postgres_replication kafka_sasl" -o pattern\n'})}),"\n",(0,i.jsx)(n.h3,{id:"driver-interface-definitions-core-sdk",children:"Driver Interface Definitions (Core SDK)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// github.com/prism/pattern-sdk/interfaces/drivers.go\npackage interfaces\n\nimport (\n    "context"\n)\n\n// KeyValueDriver provides key-value operations\ntype KeyValueDriver interface {\n    Get(ctx context.Context, key string) (string, error)\n    Set(ctx context.Context, key string, value string) error\n    Delete(ctx context.Context, key string) error\n    Exists(ctx context.Context, key string) (bool, error)\n}\n\n// KeyValueScanDriver provides scan operations\ntype KeyValueScanDriver interface {\n    KeyValueDriver\n    Scan(ctx context.Context, pattern string) ([]string, error)\n    ScanStream(ctx context.Context, pattern string) <-chan string\n}\n\n// PubSubDriver provides pub/sub operations\ntype PubSubDriver interface {\n    Publish(ctx context.Context, topic string, message []byte) error\n    Subscribe(ctx context.Context, topic string) (<-chan []byte, error)\n    Unsubscribe(ctx context.Context, topic string) error\n}\n\n// QueueDriver provides queue operations\ntype QueueDriver interface {\n    Enqueue(ctx context.Context, queue string, message []byte) error\n    Dequeue(ctx context.Context, queue string) ([]byte, error)\n    Acknowledge(ctx context.Context, queue string, messageID string) error\n}\n\n// TimeSeriesDriver provides time-series operations\ntype TimeSeriesDriver interface {\n    Append(ctx context.Context, series string, timestamp int64, value float64) error\n    Query(ctx context.Context, series string, start, end int64) ([]TimePoint, error)\n}\n\ntype TimePoint struct {\n    Timestamp int64\n    Value     float64\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"driver-registration-pattern-dependency-inversion",children:"Driver Registration Pattern (Dependency Inversion)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Problem"}),": Patterns shouldn't know about concrete driver types at compile time."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Solution"}),": Driver registration system with factory pattern."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// github.com/prism/pattern-sdk/interfaces/registry.go\npackage interfaces\n\nvar driverRegistry = make(map[string]DriverFactory)\n\ntype DriverFactory func(config map[string]interface{}) (Driver, error)\n\n// RegisterDriver registers a driver factory\nfunc RegisterDriver(name string, factory DriverFactory) {\n    driverRegistry[name] = factory\n}\n\n// NewDriver creates driver by name\nfunc NewDriver(name string, config map[string]interface{}) (Driver, error) {\n    factory, ok := driverRegistry[name]\n    if !ok {\n        return nil, fmt.Errorf("driver not found: %s", name)\n    }\n    return factory(config)\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Driver registers itself on import"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// github.com/prism/pattern-sdk-drivers/redis/driver.go\npackage redis\n\nimport (\n    "github.com/prism/pattern-sdk/interfaces"\n)\n\nfunc init() {\n    interfaces.RegisterDriver("redis", func(config map[string]interface{}) (interfaces.Driver, error) {\n        return NewRedisDriver(parseConfig(config))\n    })\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pattern imports driver (triggers registration)"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// patterns/multicast-registry/main.go\npackage main\n\nimport (\n    _ "github.com/prism/pattern-sdk-drivers/redis"  // Blank import registers driver\n    _ "github.com/prism/pattern-sdk-drivers/nats"   // Blank import registers driver\n\n    "github.com/prism/pattern-sdk/interfaces"\n)\n\nfunc main() {\n    // Create drivers by name from config\n    registry, _ := interfaces.NewDriver("redis", redisConfig)\n    messaging, _ := interfaces.NewDriver("nats", natsConfig)\n\n    pattern := NewMulticastRegistry(registry, messaging)\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Pattern code doesn't import concrete driver types"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Linker only includes imported drivers"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Easy to swap drivers via configuration"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Testability (mock drivers register with same name)"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"redis-driver-example",children:"Redis Driver Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// github.com/prism/pattern-sdk-drivers/redis/driver.go\npackage redis\n\nimport (\n    "context"\n    "fmt"\n    "sync"\n\n    "github.com/go-redis/redis/v8"\n    "github.com/prism/pattern-sdk/interfaces"\n)\n\ntype RedisDriver struct {\n    client *redis.ClusterClient\n    config Config\n\n    // Connection pooling\n    pool sync.Pool\n\n    // Metrics\n    metrics *DriverMetrics\n}\n\ntype Config struct {\n    Addresses       []string\n    Password        string\n    PoolSize        int\n    MaxRetries      int\n    ConnMaxIdleTime time.Duration\n    ConnMaxLifetime time.Duration\n}\n\ntype DriverMetrics struct {\n    OperationCount    *prometheus.CounterVec\n    OperationDuration *prometheus.HistogramVec\n    ErrorCount        *prometheus.CounterVec\n}\n\nfunc NewRedisDriver(config Config) (*RedisDriver, error) {\n    client := redis.NewClusterClient(&redis.ClusterOptions{\n        Addrs:    config.Addresses,\n        Password: config.Password,\n        PoolSize: config.PoolSize,\n    })\n\n    // Test connection\n    if err := client.Ping(context.Background()).Err(); err != nil {\n        return nil, fmt.Errorf("Redis connection failed: %w", err)\n    }\n\n    return &RedisDriver{\n        client: client,\n        config: config,\n    }, nil\n}\n\n// KeyValueDriver implementation\n\nfunc (d *RedisDriver) Get(ctx context.Context, key string) (string, error) {\n    return d.client.Get(ctx, key).Result()\n}\n\nfunc (d *RedisDriver) Set(ctx context.Context, key string, value string) error {\n    return d.client.Set(ctx, key, value, 0).Err()\n}\n\nfunc (d *RedisDriver) Delete(ctx context.Context, key string) error {\n    return d.client.Del(ctx, key).Err()\n}\n\nfunc (d *RedisDriver) Exists(ctx context.Context, key string) (bool, error) {\n    n, err := d.client.Exists(ctx, key).Result()\n    return n > 0, err\n}\n\n// KeyValueScanDriver implementation\n\nfunc (d *RedisDriver) Scan(ctx context.Context, pattern string) ([]string, error) {\n    var keys []string\n    iter := d.client.Scan(ctx, 0, pattern, 0).Iterator()\n\n    for iter.Next(ctx) {\n        keys = append(keys, iter.Val())\n    }\n\n    return keys, iter.Err()\n}\n\nfunc (d *RedisDriver) ScanStream(ctx context.Context, pattern string) <-chan string {\n    out := make(chan string)\n\n    go func() {\n        defer close(out)\n        iter := d.client.Scan(ctx, 0, pattern, 0).Iterator()\n\n        for iter.Next(ctx) {\n            select {\n            case out <- iter.Val():\n            case <-ctx.Done():\n                return\n            }\n        }\n    }()\n\n    return out\n}\n\n// PubSubDriver implementation\n\nfunc (d *RedisDriver) Publish(ctx context.Context, topic string, message []byte) error {\n    return d.client.Publish(ctx, topic, message).Err()\n}\n\nfunc (d *RedisDriver) Subscribe(ctx context.Context, topic string) (<-chan []byte, error) {\n    pubsub := d.client.Subscribe(ctx, topic)\n    ch := pubsub.Channel()\n\n    out := make(chan []byte)\n\n    go func() {\n        defer close(out)\n        for msg := range ch {\n            select {\n            case out <- []byte(msg.Payload):\n            case <-ctx.Done():\n                pubsub.Close()\n                return\n            }\n        }\n    }()\n\n    return out, nil\n}\n\nfunc (d *RedisDriver) Unsubscribe(ctx context.Context, topic string) error {\n    // Implementation depends on stored subscription references\n    return nil\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"driver-bindings",children:"Driver Bindings"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// drivers/redis/bindings.go\npackage redis\n\nimport (\n    "github.com/prism/pattern-sdk/drivers"\n)\n\n// Verify RedisDriver implements required interfaces\nvar (\n    _ drivers.KeyValueDriver     = (*RedisDriver)(nil)\n    _ drivers.KeyValueScanDriver = (*RedisDriver)(nil)\n    _ drivers.PubSubDriver       = (*RedisDriver)(nil)\n)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"pattern-implementation-example",children:"Pattern Implementation Example"}),"\n",(0,i.jsx)(n.h3,{id:"multicast-registry-pattern",children:"Multicast Registry Pattern"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// patterns/multicast_registry/pattern.go\npackage multicast_registry\n\nimport (\n    "context"\n    "fmt"\n\n    "github.com/prism/pattern-sdk/concurrency"\n    "github.com/prism/pattern-sdk/drivers"\n)\n\n// MulticastRegistryPattern implements the Multicast Registry pattern\ntype MulticastRegistryPattern struct {\n    // Backend drivers\n    registry  drivers.KeyValueScanDriver  // For identity registration\n    messaging drivers.PubSubDriver        // For multicast delivery\n\n    // Concurrency primitives\n    workerPool      *concurrency.WorkerPool\n    registryBreaker *concurrency.CircuitBreaker\n    messagingBreaker *concurrency.CircuitBreaker\n    bulkhead        *concurrency.Bulkhead\n\n    config Config\n}\n\ntype Config struct {\n    Workers          int\n    MaxFailures      int\n    ResetTimeout     time.Duration\n    BulkheadCapacity int\n}\n\nfunc NewPattern(registry drivers.KeyValueScanDriver, messaging drivers.PubSubDriver, config Config) *MulticastRegistryPattern {\n    return &MulticastRegistryPattern{\n        registry:         registry,\n        messaging:        messaging,\n        workerPool:       concurrency.NewWorkerPool(config.Workers),\n        registryBreaker:  concurrency.NewCircuitBreaker(config.MaxFailures, config.ResetTimeout),\n        messagingBreaker: concurrency.NewCircuitBreaker(config.MaxFailures, config.ResetTimeout),\n        bulkhead:         concurrency.NewBulkhead(config.BulkheadCapacity, 5*time.Second),\n        config:           config,\n    }\n}\n\n// Register registers identity with metadata\nfunc (p *MulticastRegistryPattern) Register(ctx context.Context, identity Identity) error {\n    return p.registryBreaker.Call(ctx, func() error {\n        key := fmt.Sprintf("identity:%s", identity.ID)\n        value := identity.Serialize()\n        return p.registry.Set(ctx, key, value)\n    })\n}\n\n// Enumerate lists all registered identities\nfunc (p *MulticastRegistryPattern) Enumerate(ctx context.Context, filter string) ([]Identity, error) {\n    var identities []Identity\n\n    err := p.registryBreaker.Call(ctx, func() error {\n        keys, err := p.registry.Scan(ctx, "identity:*")\n        if err != nil {\n            return err\n        }\n\n        for _, key := range keys {\n            value, err := p.registry.Get(ctx, key)\n            if err != nil {\n                continue\n            }\n\n            identity := ParseIdentity(value)\n            if p.matchesFilter(identity, filter) {\n                identities = append(identities, identity)\n            }\n        }\n\n        return nil\n    })\n\n    return identities, err\n}\n\n// PublishMulticast publishes event to all matching subscribers\nfunc (p *MulticastRegistryPattern) PublishMulticast(ctx context.Context, event Event) error {\n    // Step 1: Get subscribers (with circuit breaker)\n    var subscribers []Identity\n    err := p.registryBreaker.Call(ctx, func() error {\n        var err error\n        subscribers, err = p.Enumerate(ctx, event.Filter)\n        return err\n    })\n    if err != nil {\n        return fmt.Errorf("failed to enumerate subscribers: %w", err)\n    }\n\n    // Step 2: Fan-out to subscribers (with bulkhead + circuit breaker)\n    p.workerPool.Start(ctx)\n\n    for _, sub := range subscribers {\n        subscriber := sub\n        p.workerPool.Submit(func(ctx context.Context) error {\n            return p.bulkhead.Execute(ctx, func() error {\n                return p.messagingBreaker.Call(ctx, func() error {\n                    topic := subscriber.Metadata["topic"]\n                    return p.messaging.Publish(ctx, topic, event.Serialize())\n                })\n            })\n        })\n    }\n\n    // Step 3: Wait for all deliveries\n    errs := p.workerPool.Wait()\n    if len(errs) > 0 {\n        return fmt.Errorf("multicast failed: %d/%d deliveries failed", len(errs), len(subscribers))\n    }\n\n    return nil\n}\n\ntype Identity struct {\n    ID       string\n    Metadata map[string]string\n}\n\ntype Event struct {\n    Topic   string\n    Filter  string\n    Payload []byte\n}\n\nfunc (i Identity) Serialize() string {\n    // Implementation\n    return ""\n}\n\nfunc ParseIdentity(value string) Identity {\n    // Implementation\n    return Identity{}\n}\n\nfunc (p *MulticastRegistryPattern) matchesFilter(identity Identity, filter string) bool {\n    // Implementation\n    return true\n}\n\nfunc (e Event) Serialize() []byte {\n    // Implementation\n    return nil\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"pattern-lifecycle-management",children:"Pattern Lifecycle Management"}),"\n",(0,i.jsx)(n.h3,{id:"design-principles-1",children:"Design Principles"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Critical Requirements"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Slot Matching"}),": Backends validated against required interface unions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Lifecycle Isolation"}),": Pattern main isolated from program main"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Graceful Shutdown"}),": Bounded timeout for cleanup"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Signal Handling"}),": SDK intercepts OS signals (SIGTERM, SIGINT)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Validation First"}),": Fail fast if configuration invalid"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"slot-configuration-and-interface-matching",children:"Slot Configuration and Interface Matching"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pattern slots specify interface requirements"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# patterns/multicast-registry/pattern.yaml\npattern:\n  name: multicast-registry\n  version: v1.2.0\n\n  # Slots define backend requirements via interface unions\n  slots:\n    registry:\n      required_interfaces:\n        - keyvalue_basic      # MUST have Get/Set/Delete\n        - keyvalue_scan       # MUST have Scan operation\n      description: "Stores identity registry with scan capability"\n\n    messaging:\n      required_interfaces:\n        - pubsub_basic        # MUST have Publish/Subscribe\n      description: "Delivers multicast messages"\n\n    durability:\n      required_interfaces:\n        - queue_basic         # MUST have Enqueue/Dequeue\n      optional: true          # This slot is optional\n      description: "Persists events for replay"\n\n  # Pattern-specific settings\n  concurrency:\n    workers: 10\n    circuit_breaker:\n      max_failures: 5\n      reset_timeout: 30s\n    bulkhead:\n      capacity: 100\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"SDK validates slot configuration"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// pkg/lifecycle/slot_validator.go\npackage lifecycle\n\nimport (\n    "fmt"\n    "github.com/prism/pattern-sdk/interfaces"\n)\n\n// SlotConfig defines backend requirements for a pattern slot\ntype SlotConfig struct {\n    Name               string\n    RequiredInterfaces []string\n    Optional           bool\n    Description        string\n}\n\n// ValidateSlot checks if backend implements required interfaces\nfunc ValidateSlot(slot SlotConfig, backend interfaces.Driver) error {\n    // Check each required interface\n    for _, iface := range slot.RequiredInterfaces {\n        if !backend.Implements(iface) {\n            return fmt.Errorf(\n                "slot %s: backend %s does not implement required interface %s",\n                slot.Name,\n                backend.Name(),\n                iface,\n            )\n        }\n    }\n    return nil\n}\n\n// SlotMatcher validates all pattern slots against configured backends\ntype SlotMatcher struct {\n    slots    []SlotConfig\n    backends map[string]interfaces.Driver\n}\n\nfunc NewSlotMatcher(slots []SlotConfig) *SlotMatcher {\n    return &SlotMatcher{\n        slots:    slots,\n        backends: make(map[string]interfaces.Driver),\n    }\n}\n\n// FillSlot assigns backend to slot after validation\nfunc (sm *SlotMatcher) FillSlot(slotName string, backend interfaces.Driver) error {\n    // Find slot config\n    var slot *SlotConfig\n    for i := range sm.slots {\n        if sm.slots[i].Name == slotName {\n            slot = &sm.slots[i]\n            break\n        }\n    }\n\n    if slot == nil {\n        return fmt.Errorf("slot %s not defined in pattern", slotName)\n    }\n\n    // Validate backend implements required interfaces\n    if err := ValidateSlot(*slot, backend); err != nil {\n        return err\n    }\n\n    // Assign backend to slot\n    sm.backends[slotName] = backend\n    return nil\n}\n\n// Validate checks all non-optional slots are filled\nfunc (sm *SlotMatcher) Validate() error {\n    for _, slot := range sm.slots {\n        if slot.Optional {\n            continue\n        }\n\n        if _, ok := sm.backends[slot.Name]; !ok {\n            return fmt.Errorf("required slot %s not filled", slot.Name)\n        }\n    }\n    return nil\n}\n\n// GetBackends returns validated backend map\nfunc (sm *SlotMatcher) GetBackends() map[string]interfaces.Driver {\n    return sm.backends\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"pattern-lifecycle-structure",children:"Pattern Lifecycle Structure"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Separation of concerns"}),": Program main (SDK) vs Pattern main (business logic)"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// cmd/multicast-registry/main.go\npackage main\n\nimport (\n    "context"\n    "github.com/prism/pattern-sdk/lifecycle"\n    "github.com/prism/patterns/multicast-registry"\n)\n\nfunc main() {\n    // SDK handles: config loading, signal handling, graceful shutdown\n    lifecycle.Run(&multicast_registry.Pattern{})\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"SDK lifecycle manager"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// pkg/lifecycle/runner.go\npackage lifecycle\n\nimport (\n    "context"\n    "fmt"\n    "os"\n    "os/signal"\n    "syscall"\n    "time"\n\n    "go.uber.org/zap"\n)\n\n// Pattern defines the interface patterns must implement\ntype Pattern interface {\n    // Name returns pattern name\n    Name() string\n\n    // Initialize sets up pattern with validated backends\n    Initialize(ctx context.Context, config *Config, backends map[string]interface{}) error\n\n    // Start begins pattern execution\n    Start(ctx context.Context) error\n\n    // Shutdown performs graceful cleanup (bounded by timeout)\n    Shutdown(ctx context.Context) error\n\n    // HealthCheck reports pattern health\n    HealthCheck(ctx context.Context) error\n}\n\n// Config holds complete pattern configuration\ntype Config struct {\n    Pattern          PatternConfig\n    Slots            []SlotConfig\n    BackendConfigs   map[string]interface{}\n    GracefulTimeout  time.Duration\n    ShutdownTimeout  time.Duration\n}\n\n// Run executes pattern lifecycle with SDK management\nfunc Run(pattern Pattern) {\n    // Setup logger\n    logger, _ := zap.NewProduction()\n    defer logger.Sync()\n\n    // Load configuration\n    config, err := LoadConfig()\n    if err != nil {\n        logger.Fatal("Failed to load configuration", zap.Error(err))\n    }\n\n    // Create slot matcher\n    matcher := NewSlotMatcher(config.Slots)\n\n    // Initialize backends and fill slots\n    for slotName, backendConfig := range config.BackendConfigs {\n        backend, err := CreateBackend(backendConfig)\n        if err != nil {\n            logger.Fatal("Failed to create backend",\n                zap.String("slot", slotName),\n                zap.Error(err))\n        }\n\n        if err := matcher.FillSlot(slotName, backend); err != nil {\n            logger.Fatal("Slot validation failed",\n                zap.String("slot", slotName),\n                zap.Error(err))\n        }\n    }\n\n    // Validate all required slots filled\n    if err := matcher.Validate(); err != nil {\n        logger.Fatal("Slot configuration invalid", zap.Error(err))\n    }\n\n    // Get validated backends\n    backends := matcher.GetBackends()\n\n    // Create root context\n    ctx, cancel := context.WithCancel(context.Background())\n    defer cancel()\n\n    // Initialize pattern\n    if err := pattern.Initialize(ctx, config, backends); err != nil {\n        logger.Fatal("Pattern initialization failed", zap.Error(err))\n    }\n\n    // Setup signal handling\n    sigChan := make(chan os.Signal, 1)\n    signal.Notify(sigChan, syscall.SIGTERM, syscall.SIGINT)\n\n    // Start pattern\n    errChan := make(chan error, 1)\n    go func() {\n        if err := pattern.Start(ctx); err != nil {\n            errChan <- err\n        }\n    }()\n\n    logger.Info("Pattern started",\n        zap.String("pattern", pattern.Name()),\n        zap.Duration("graceful_timeout", config.GracefulTimeout))\n\n    // Wait for signal or error\n    select {\n    case sig := <-sigChan:\n        logger.Info("Received signal, initiating shutdown",\n            zap.String("signal", sig.String()))\n        handleShutdown(ctx, pattern, config, logger)\n\n    case err := <-errChan:\n        logger.Error("Pattern error, initiating shutdown", zap.Error(err))\n        handleShutdown(ctx, pattern, config, logger)\n    }\n}\n\n// handleShutdown performs graceful shutdown with bounded timeout\nfunc handleShutdown(ctx context.Context, pattern Pattern, config *Config, logger *zap.Logger) {\n    // Create shutdown context with timeout\n    shutdownCtx, cancel := context.WithTimeout(context.Background(), config.ShutdownTimeout)\n    defer cancel()\n\n    logger.Info("Starting graceful shutdown",\n        zap.Duration("timeout", config.ShutdownTimeout))\n\n    // Call pattern shutdown\n    shutdownErr := make(chan error, 1)\n    go func() {\n        shutdownErr <- pattern.Shutdown(shutdownCtx)\n    }()\n\n    // Wait for shutdown or timeout\n    select {\n    case err := <-shutdownErr:\n        if err != nil {\n            logger.Error("Shutdown completed with errors", zap.Error(err))\n            os.Exit(1)\n        }\n        logger.Info("Shutdown completed successfully")\n        os.Exit(0)\n\n    case <-shutdownCtx.Done():\n        logger.Warn("Shutdown timeout exceeded, forcing exit",\n            zap.Duration("timeout", config.ShutdownTimeout))\n        os.Exit(2)\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"pattern-implementation-with-lifecycle",children:"Pattern Implementation with Lifecycle"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Example pattern using SDK lifecycle"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// patterns/multicast-registry/pattern.go\npackage multicast_registry\n\nimport (\n    "context"\n    "fmt"\n    "sync"\n    "time"\n\n    "github.com/prism/pattern-sdk/concurrency"\n    "github.com/prism/pattern-sdk/interfaces"\n    "github.com/prism/pattern-sdk/lifecycle"\n)\n\ntype Pattern struct {\n    // Backends (filled by SDK)\n    registry  interfaces.KeyValueScanDriver\n    messaging interfaces.PubSubDriver\n\n    // Concurrency primitives\n    workerPool *concurrency.WorkerPool\n    breakers   map[string]*concurrency.CircuitBreaker\n\n    // Lifecycle management\n    config  *lifecycle.Config\n    wg      sync.WaitGroup\n    stopCh  chan struct{}\n    started bool\n    mu      sync.RWMutex\n}\n\n// Name implements lifecycle.Pattern\nfunc (p *Pattern) Name() string {\n    return "multicast-registry"\n}\n\n// Initialize implements lifecycle.Pattern\nfunc (p *Pattern) Initialize(ctx context.Context, config *lifecycle.Config, backends map[string]interface{}) error {\n    p.config = config\n    p.stopCh = make(chan struct{})\n    p.breakers = make(map[string]*concurrency.CircuitBreaker)\n\n    // Extract backends from validated slots\n    var ok bool\n    p.registry, ok = backends["registry"].(interfaces.KeyValueScanDriver)\n    if !ok {\n        return fmt.Errorf("registry backend does not implement KeyValueScanDriver")\n    }\n\n    p.messaging, ok = backends["messaging"].(interfaces.PubSubDriver)\n    if !ok {\n        return fmt.Errorf("messaging backend does not implement PubSubDriver")\n    }\n\n    // Initialize concurrency primitives\n    p.workerPool = concurrency.NewWorkerPool(config.Pattern.Concurrency.Workers)\n\n    // Create circuit breakers for each backend\n    p.breakers["registry"] = concurrency.NewCircuitBreaker(\n        config.Pattern.Concurrency.CircuitBreaker.MaxFailures,\n        config.Pattern.Concurrency.CircuitBreaker.ResetTimeout,\n    )\n    p.breakers["messaging"] = concurrency.NewCircuitBreaker(\n        config.Pattern.Concurrency.CircuitBreaker.MaxFailures,\n        config.Pattern.Concurrency.CircuitBreaker.ResetTimeout,\n    )\n\n    return nil\n}\n\n// Start implements lifecycle.Pattern\nfunc (p *Pattern) Start(ctx context.Context) error {\n    p.mu.Lock()\n    if p.started {\n        p.mu.Unlock()\n        return fmt.Errorf("pattern already started")\n    }\n    p.started = true\n    p.mu.Unlock()\n\n    // Start worker pool\n    p.workerPool.Start(ctx)\n\n    // Start health check goroutine\n    p.wg.Add(1)\n    go p.healthCheckLoop(ctx)\n\n    // Pattern-specific startup logic\n    log.Info("Multicast registry pattern started")\n\n    // Block until stopped\n    <-p.stopCh\n    return nil\n}\n\n// Shutdown implements lifecycle.Pattern (bounded by timeout from SDK)\nfunc (p *Pattern) Shutdown(ctx context.Context) error {\n    p.mu.Lock()\n    if !p.started {\n        p.mu.Unlock()\n        return nil\n    }\n    p.mu.Unlock()\n\n    log.Info("Shutting down multicast registry pattern")\n\n    // Signal stop\n    close(p.stopCh)\n\n    // Shutdown worker pool (waits for in-flight tasks)\n    shutdownCh := make(chan struct{})\n    go func() {\n        p.workerPool.Stop()\n        close(shutdownCh)\n    }()\n\n    // Wait for worker pool shutdown or context timeout\n    select {\n    case <-shutdownCh:\n        log.Info("Worker pool shutdown complete")\n    case <-ctx.Done():\n        log.Warn("Worker pool shutdown timeout, forcing stop")\n        // Forcefully stop workers (implementation-specific)\n    }\n\n    // Wait for background goroutines\n    waitCh := make(chan struct{})\n    go func() {\n        p.wg.Wait()\n        close(waitCh)\n    }()\n\n    select {\n    case <-waitCh:\n        log.Info("Background goroutines stopped")\n    case <-ctx.Done():\n        log.Warn("Background goroutines timeout")\n    }\n\n    // Close backend connections\n    if closer, ok := p.registry.(interface{ Close() error }); ok {\n        if err := closer.Close(); err != nil {\n            log.Error("Failed to close registry backend", "error", err)\n        }\n    }\n\n    if closer, ok := p.messaging.(interface{ Close() error }); ok {\n        if err := closer.Close(); err != nil {\n            log.Error("Failed to close messaging backend", "error", err)\n        }\n    }\n\n    log.Info("Shutdown complete")\n    return nil\n}\n\n// HealthCheck implements lifecycle.Pattern\nfunc (p *Pattern) HealthCheck(ctx context.Context) error {\n    // Check registry backend\n    if err := p.breakers["registry"].Call(ctx, func() error {\n        return p.registry.Exists(ctx, "_health")\n    }); err != nil {\n        return fmt.Errorf("registry backend unhealthy: %w", err)\n    }\n\n    // Check messaging backend (implementation-specific)\n    if err := p.breakers["messaging"].Call(ctx, func() error {\n        // Messaging health check\n        return nil\n    }); err != nil {\n        return fmt.Errorf("messaging backend unhealthy: %w", err)\n    }\n\n    return nil\n}\n\n// healthCheckLoop runs periodic health checks\nfunc (p *Pattern) healthCheckLoop(ctx context.Context) {\n    defer p.wg.Done()\n\n    ticker := time.NewTicker(10 * time.Second)\n    defer ticker.Stop()\n\n    for {\n        select {\n        case <-ctx.Done():\n            return\n        case <-p.stopCh:\n            return\n        case <-ticker.C:\n            if err := p.HealthCheck(ctx); err != nil {\n                log.Warn("Health check failed", "error", err)\n            }\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"graceful-shutdown-flow",children:"Graceful Shutdown Flow"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Graceful Shutdown Flow                      \u2502\n\u2502                                                                 \u2502\n\u2502  1. Signal Received (SIGTERM/SIGINT)                           \u2502\n\u2502     \u2193                                                           \u2502\n\u2502  2. SDK creates shutdown context with timeout                  \u2502\n\u2502     \u2514\u2500 Timeout: 30s (configurable)                             \u2502\n\u2502     \u2193                                                           \u2502\n\u2502  3. SDK calls pattern.Shutdown(ctx)                            \u2502\n\u2502     \u2193                                                           \u2502\n\u2502  4. Pattern drains in-flight requests                          \u2502\n\u2502     \u251c\u2500 Stop accepting new requests                             \u2502\n\u2502     \u251c\u2500 Wait for worker pool completion                         \u2502\n\u2502     \u2514\u2500 Bounded by context timeout                              \u2502\n\u2502     \u2193                                                           \u2502\n\u2502  5. Pattern closes backend connections                         \u2502\n\u2502     \u251c\u2500 registry.Close()                                        \u2502\n\u2502     \u251c\u2500 messaging.Close()                                       \u2502\n\u2502     \u2514\u2500 Wait for close or timeout                               \u2502\n\u2502     \u2193                                                           \u2502\n\u2502  6. Pattern returns from Shutdown()                            \u2502\n\u2502     \u2193                                                           \u2502\n\u2502  7. SDK logs result and exits                                  \u2502\n\u2502     \u251c\u2500 Exit 0: Clean shutdown                                  \u2502\n\u2502     \u251c\u2500 Exit 1: Shutdown errors                                 \u2502\n\u2502     \u2514\u2500 Exit 2: Timeout exceeded (forced)                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,i.jsx)(n.h3,{id:"configuration-example",children:"Configuration Example"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Complete pattern configuration with lifecycle"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# config/multicast-registry.yaml\n\n# Pattern Configuration\npattern:\n  name: multicast-registry\n  version: v1.2.0\n\n  # Lifecycle settings\n  lifecycle:\n    graceful_timeout: 30s     # Time for graceful shutdown\n    shutdown_timeout: 35s     # Hard timeout (graceful + 5s buffer)\n    health_check_interval: 10s\n\n  # Slots define backend requirements via interface unions\n  slots:\n    registry:\n      required_interfaces:\n        - keyvalue_basic\n        - keyvalue_scan\n      description: "Identity registry with scan"\n\n    messaging:\n      required_interfaces:\n        - pubsub_basic\n      description: "Multicast message delivery"\n\n  # Concurrency settings\n  concurrency:\n    workers: 10\n    circuit_breaker:\n      max_failures: 5\n      reset_timeout: 30s\n    bulkhead:\n      capacity: 100\n      timeout: 5s\n\n# Backend Configuration\nbackends:\n  registry:\n    driver: redis\n    config:\n      addresses:\n        - redis://localhost:6379\n      pool_size: 50\n      max_retries: 3\n\n  messaging:\n    driver: nats\n    config:\n      url: nats://localhost:4222\n      max_reconnects: 10\n\n# Observability\nobservability:\n  metrics:\n    enabled: true\n    port: 9090\n  tracing:\n    enabled: true\n    endpoint: localhost:4317\n  logging:\n    level: info\n    format: json\n'})}),"\n",(0,i.jsx)(n.h2,{id:"configuration-example-1",children:"Configuration Example"}),"\n",(0,i.jsx)(n.h3,{id:"pattern-configuration",children:"Pattern Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# Pattern-level configuration\nmulticast_registry:\n  # Backend slots (specified by interface requirements)\n  backends:\n    registry:\n      driver: redis\n      config:\n        addresses:\n          - redis://localhost:6379\n        pool_size: 50\n      interfaces:\n        - keyvalue_basic\n        - keyvalue_scan\n\n    messaging:\n      driver: nats\n      config:\n        url: nats://localhost:4222\n      interfaces:\n        - pubsub_basic\n\n  # Concurrency settings\n  concurrency:\n    workers: 10\n    circuit_breaker:\n      max_failures: 5\n      reset_timeout: 30s\n    bulkhead:\n      capacity: 100\n      timeout: 5s\n\n  # Pattern-specific settings\n  settings:\n    multicast_timeout: 10s\n    batch_size: 100\n"})}),"\n",(0,i.jsx)(n.h2,{id:"production-deployment-patterns",children:"Production Deployment Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"binary-size-comparison-real-numbers",children:"Binary Size Comparison (Real Numbers)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Monolithic SDK"})," (all drivers linked):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"Pattern Binary: 487 MB\nIncludes:\n- Redis client (v8): 42 MB\n- Postgres client (pgx): 38 MB\n- Kafka client (segmentio): 67 MB\n- NATS client: 18 MB\n- ClickHouse client: 54 MB\n- S3 SDK: 98 MB\n- MongoDB client: 71 MB\n- Cassandra client: 99 MB\nTotal: ~487 MB (plus pattern code)\n\nStartup time: 12-15 seconds\nMemory baseline: 1.8 GB\nDocker image: 520 MB\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Modular SDK"})," (Redis + NATS only):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"Pattern Binary: 54 MB\nIncludes:\n- Redis client: 42 MB\n- NATS client: 18 MB\n- Pattern code: ~4 MB\nTotal: ~54 MB\n\nStartup time: 1.2 seconds\nMemory baseline: 320 MB\nDocker image: 78 MB (with distroless base)\n\nReduction: 89% smaller, 10\xd7 faster startup, 82% less memory\n"})}),"\n",(0,i.jsx)(n.h3,{id:"container-image-optimization",children:"Container Image Optimization"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Multi-stage Dockerfile"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dockerfile",children:'# Stage 1: Build with only required drivers\nFROM golang:1.21 AS builder\n\nWORKDIR /build\n\n# Copy go.mod with ONLY needed driver dependencies\nCOPY go.mod go.sum ./\nRUN go mod download\n\nCOPY . .\n\n# Static build with only redis and nats drivers\nRUN CGO_ENABLED=0 GOOS=linux go build \\\n    -ldflags="-s -w" \\\n    -tags "redis_cluster nats_jetstream" \\\n    -o pattern ./cmd/multicast-registry\n\n# Stage 2: Minimal runtime (distroless)\nFROM gcr.io/distroless/static-debian11\n\nCOPY --from=builder /build/pattern /pattern\nCOPY --from=builder /build/config.yaml /config.yaml\n\nUSER nonroot:nonroot\n\nENTRYPOINT ["/pattern"]\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Result"}),": 78 MB image (vs 520 MB monolithic)"]}),"\n",(0,i.jsx)(n.h3,{id:"performance-optimization-strategies",children:"Performance Optimization Strategies"}),"\n",(0,i.jsx)(n.h4,{id:"1-zero-copy-operations",children:"1. Zero-Copy Operations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// Bad: String allocation and copy\nfunc (d *RedisDriver) GetBad(ctx context.Context, key string) (string, error) {\n    val, err := d.client.Get(ctx, key).Result()  // Allocates string\n    return val, err  // Another allocation when converting\n}\n\n// Good: Zero-copy with []byte\nfunc (d *RedisDriver) Get(ctx context.Context, key string) ([]byte, error) {\n    val, err := d.client.Get(ctx, key).Bytes()  // Returns []byte, no string alloc\n    return val, err\n}\n\n// Pattern uses []byte throughout\nfunc (p *Pattern) ProcessEvent(event []byte) error {\n    // No marshaling/unmarshaling string conversions\n    return p.driver.Set(ctx, key, event)\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Impact"}),": 40% reduction in GC pressure, 25% lower latency for high-throughput patterns."]}),"\n",(0,i.jsx)(n.h4,{id:"2-object-pooling-for-hot-paths",children:"2. Object Pooling for Hot Paths"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// concurrency/pool.go\nvar bufferPool = sync.Pool{\n    New: func() interface{} {\n        return make([]byte, 4096)\n    },\n}\n\nfunc (p *Pattern) ProcessBatch(events []Event) error {\n    // Reuse buffer from pool instead of allocating\n    buf := bufferPool.Get().([]byte)\n    defer bufferPool.Put(buf)\n\n    for _, event := range events {\n        // Use buf for serialization\n        n := event.MarshalTo(buf)\n        p.driver.Set(ctx, event.Key, buf[:n])\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Impact"}),": Eliminates 10,000+ allocations/sec in high-throughput patterns."]}),"\n",(0,i.jsx)(n.h4,{id:"3-connection-pool-tuning-per-pattern",children:"3. Connection Pool Tuning Per Pattern"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// drivers/redis/driver.go\nfunc NewRedisDriver(config Config) (*RedisDriver, error) {\n    client := redis.NewClusterClient(&redis.ClusterOptions{\n        Addrs:    config.Addresses,\n\n        // Pool configuration tuned for pattern workload\n        PoolSize:           config.PoolSize,           // Default: 10 \xd7 NumCPU\n        MinIdleConns:       config.PoolSize / 2,       // Keep connections warm\n        MaxConnAge:         30 * time.Minute,          // Rotate for load balancing\n        PoolTimeout:        4 * time.Second,           // Fail fast on pool exhaustion\n        IdleTimeout:        5 * time.Minute,           // Close idle conns\n        IdleCheckFrequency: 1 * time.Minute,           // Cleanup frequency\n\n        // Retry configuration\n        MaxRetries:      3,\n        MinRetryBackoff: 8 * time.Millisecond,\n        MaxRetryBackoff: 512 * time.Millisecond,\n    })\n\n    return &RedisDriver{client: client}, nil\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pattern-specific tuning"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"High-throughput patterns"})," (CDC, Session Store): PoolSize = 50-100"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Low-latency patterns"})," (Multicast): MinIdleConns = PoolSize (all warm)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Batch patterns"})," (ETL): Smaller PoolSize, longer timeouts"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"observability-middleware",children:"Observability Middleware"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Transparent instrumentation of all driver operations"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// github.com/prism/pattern-sdk/observability/middleware.go\npackage observability\n\nimport (\n    "context"\n    "time"\n\n    "github.com/prometheus/client_golang/prometheus"\n    "go.opentelemetry.io/otel/trace"\n)\n\ntype InstrumentedDriver struct {\n    driver    interfaces.KeyValueDriver\n    metrics   *Metrics\n    tracer    trace.Tracer\n}\n\nfunc WrapDriver(driver interfaces.KeyValueDriver, metrics *Metrics, tracer trace.Tracer) interfaces.KeyValueDriver {\n    return &InstrumentedDriver{\n        driver:  driver,\n        metrics: metrics,\n        tracer:  tracer,\n    }\n}\n\nfunc (d *InstrumentedDriver) Get(ctx context.Context, key string) ([]byte, error) {\n    // Start trace span\n    ctx, span := d.tracer.Start(ctx, "driver.Get")\n    defer span.End()\n\n    // Record metrics\n    start := time.Now()\n\n    // Execute operation\n    value, err := d.driver.Get(ctx, key)\n\n    // Record duration\n    duration := time.Since(start).Seconds()\n    d.metrics.OperationDuration.WithLabelValues("get", statusLabel(err)).Observe(duration)\n    d.metrics.OperationCount.WithLabelValues("get", statusLabel(err)).Inc()\n\n    if err != nil {\n        span.RecordError(err)\n        d.metrics.ErrorCount.WithLabelValues("get", errorType(err)).Inc()\n    }\n\n    return value, err\n}\n\ntype Metrics struct {\n    OperationDuration *prometheus.HistogramVec\n    OperationCount    *prometheus.CounterVec\n    ErrorCount        *prometheus.CounterVec\n}\n\nfunc NewMetrics(registry *prometheus.Registry) *Metrics {\n    m := &Metrics{\n        OperationDuration: prometheus.NewHistogramVec(\n            prometheus.HistogramOpts{\n                Name:    "driver_operation_duration_seconds",\n                Help:    "Driver operation latency in seconds",\n                Buckets: prometheus.DefBuckets,\n            },\n            []string{"operation", "status"},\n        ),\n        OperationCount: prometheus.NewCounterVec(\n            prometheus.CounterOpts{\n                Name: "driver_operation_total",\n                Help: "Total driver operations",\n            },\n            []string{"operation", "status"},\n        ),\n        ErrorCount: prometheus.NewCounterVec(\n            prometheus.CounterOpts{\n                Name: "driver_error_total",\n                Help: "Total driver errors",\n            },\n            []string{"operation", "error_type"},\n        ),\n    }\n\n    registry.MustRegister(m.OperationDuration, m.OperationCount, m.ErrorCount)\n    return m\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Usage in pattern"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'import (\n    "github.com/prism/pattern-sdk/observability"\n)\n\nfunc main() {\n    // Create driver\n    driver := redis.NewRedisDriver(config)\n\n    // Wrap with observability (transparent to pattern code)\n    driver = observability.WrapDriver(driver, metrics, tracer)\n\n    // Use driver - all operations auto-instrumented\n    pattern := NewMulticastRegistry(driver, messaging)\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Exported metrics"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:'driver_operation_duration_seconds{operation="get",status="success"} 0.0012\ndriver_operation_duration_seconds{operation="set",status="success"} 0.0018\ndriver_operation_total{operation="get",status="success"} 125043\ndriver_operation_total{operation="get",status="error"} 42\ndriver_error_total{operation="get",error_type="connection_refused"} 12\ndriver_error_total{operation="get",error_type="timeout"} 30\n'})}),"\n",(0,i.jsx)(n.h3,{id:"kubernetes-deployment",children:"Kubernetes Deployment"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# multicast-registry-deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: multicast-registry\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: multicast-registry\n  template:\n    metadata:\n      labels:\n        app: multicast-registry\n    spec:\n      containers:\n      - name: pattern\n        image: prism/multicast-registry:v1.2.0  # 78 MB image\n        resources:\n          requests:\n            memory: "512Mi"     # vs 2Gi for monolithic\n            cpu: "500m"\n          limits:\n            memory: "1Gi"\n            cpu: "2"\n\n        # Environment configuration\n        env:\n        - name: PATTERN_CONFIG\n          value: /config/pattern.yaml\n        - name: OTEL_EXPORTER_OTLP_ENDPOINT\n          value: http://otel-collector:4317\n\n        # Liveness probe (fast startup = fast recovery)\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8080\n          initialDelaySeconds: 5   # vs 30s for monolithic\n          periodSeconds: 10\n\n        # Readiness probe\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 8080\n          initialDelaySeconds: 3\n          periodSeconds: 5\n\n        # Volumes\n        volumeMounts:\n        - name: config\n          mountPath: /config\n        - name: vault-token\n          mountPath: /var/run/secrets/vault\n\n      # Sidecar: Vault agent for credential refresh\n      - name: vault-agent\n        image: vault:1.15\n        args:\n        - agent\n        - -config=/vault/config/agent.hcl\n        volumeMounts:\n        - name: vault-config\n          mountPath: /vault/config\n        - name: vault-token\n          mountPath: /var/run/secrets/vault\n\n      # Sidecar: Topaz for authorization\n      - name: topaz\n        image: aserto/topaz:0.30\n        ports:\n        - containerPort: 8282\n        volumeMounts:\n        - name: topaz-config\n          mountPath: /config\n\n      volumes:\n      - name: config\n        configMap:\n          name: multicast-registry-config\n      - name: vault-config\n        configMap:\n          name: vault-agent-config\n      - name: vault-token\n        emptyDir:\n          medium: Memory\n      - name: topaz-config\n        configMap:\n          name: topaz-config\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key benefits of modular architecture in K8s"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Faster pod startup"}),": 5s vs 30s (important for autoscaling)"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Lower resource requests"}),": 512Mi vs 2Gi (higher pod density)"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Smaller images"}),": Faster pulls, less registry storage"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Faster rollouts"}),": Less data to transfer, quicker deployments"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"migration-path",children:"Migration Path"}),"\n",(0,i.jsx)(n.h3,{id:"phase-1-modular-driver-architecture-week-1",children:"Phase 1: Modular Driver Architecture (Week 1)"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Create separate Go modules for each driver:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"mkdir -p pattern-sdk-drivers/{redis,postgres,kafka,nats,clickhouse,s3}\n\nfor driver in redis postgres kafka nats clickhouse s3; do\n  cd pattern-sdk-drivers/$driver\n  go mod init github.com/prism/pattern-sdk-drivers/$driver\ndone\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Move driver code to separate modules"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Implement driver registration system in core SDK"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Write interface binding tests"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"phase-2-concurrency-primitives-week-2",children:"Phase 2: Concurrency Primitives (Week 2)"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Implement WorkerPool with graceful shutdown"}),"\n",(0,i.jsx)(n.li,{children:"Implement FanOut/FanIn with bounded concurrency"}),"\n",(0,i.jsx)(n.li,{children:"Implement Pipeline with backpressure"}),"\n",(0,i.jsx)(n.li,{children:"Implement CircuitBreaker with sliding window"}),"\n",(0,i.jsx)(n.li,{children:"Implement Bulkhead with per-backend isolation"}),"\n",(0,i.jsx)(n.li,{children:"Write comprehensive tests + benchmarks"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"phase-3-pattern-migration-week-3",children:"Phase 3: Pattern Migration (Week 3)"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Refactor Multicast Registry to modular SDK\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Measure: Binary size, startup time, memory"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Refactor Session Store to modular SDK\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Measure: Same metrics"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"Document size/performance improvements"}),"\n",(0,i.jsx)(n.li,{children:"Write pattern implementation guide"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"phase-4-observability--production-week-4",children:"Phase 4: Observability & Production (Week 4)"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Implement observability middleware"}),"\n",(0,i.jsx)(n.li,{children:"Write Prometheus metrics guide"}),"\n",(0,i.jsx)(n.li,{children:"Write OpenTelemetry tracing guide"}),"\n",(0,i.jsx)(n.li,{children:"Create Grafana dashboards for patterns"}),"\n",(0,i.jsx)(n.li,{children:"Document Kubernetes deployment patterns"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"success-metrics",children:"Success Metrics"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Binary Size"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Target: <100 MB per pattern (vs ~500 MB monolithic)"}),"\n",(0,i.jsxs)(n.li,{children:["Measure: ",(0,i.jsx)(n.code,{children:"ls -lh pattern-binary"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Startup Time"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Target: <2 seconds (vs 10-15 seconds monolithic)"}),"\n",(0,i.jsxs)(n.li,{children:["Measure: ",(0,i.jsx)(n.code,{children:"time ./pattern --test-startup"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Memory Usage"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Target: <500 MB baseline (vs 1.8 GB monolithic)"}),"\n",(0,i.jsxs)(n.li,{children:["Measure: ",(0,i.jsx)(n.code,{children:"ps aux | grep pattern"})," or K8s metrics"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Build Time"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Target: <30 seconds incremental (vs 2+ minutes monolithic)"}),"\n",(0,i.jsxs)(n.li,{children:["Measure: ",(0,i.jsx)(n.code,{children:"time go build ./cmd/pattern"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"related-documents",children:"Related Documents"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/memos/memo-006-backend-interface-decomposition-schema-registry",children:"MEMO-006: Backend Interface Decomposition"})," - Interface definitions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/rfc/rfc-017-multicast-registry-pattern",children:"RFC-017: Multicast Registry Pattern"})," - Example pattern"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/rfc/rfc-024-distributed-session-store-pattern",children:"RFC-024: Distributed Session Store Pattern"})," - Example pattern"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/rfc/rfc-022-core-plugin-sdk-code-layout",children:"RFC-022: Core Plugin SDK Code Layout"}),' - SDK structure (now "Pattern SDK")']}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"2025-10-09: Initial RFC proposing Pattern SDK architecture with backend drivers and concurrency primitives"}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var t=r(96540);const i={},s=t.createContext(i);function a(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);