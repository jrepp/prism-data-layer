"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[411],{8453:(n,e,s)=>{s.d(e,{R:()=>a,x:()=>o});var r=s(6540);const t={},i=r.createContext(t);function a(n){const e=r.useContext(i);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),r.createElement(i.Provider,{value:e},n.children)}},9674:(n,e,s)=>{s.r(e),s.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"rust-async-concurrency-patterns","title":"ADR-019: Rust Async Concurrency Patterns","description":"Context","source":"@site/../docs-cms/adr/019-rust-async-concurrency-patterns.md","sourceDirName":".","slug":"/rust-async-concurrency-patterns","permalink":"/prism-data-layer/adr/rust-async-concurrency-patterns","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/019-rust-async-concurrency-patterns.md","tags":[{"inline":true,"label":"rust","permalink":"/prism-data-layer/adr/tags/rust"},{"inline":true,"label":"concurrency","permalink":"/prism-data-layer/adr/tags/concurrency"},{"inline":true,"label":"async","permalink":"/prism-data-layer/adr/tags/async"},{"inline":true,"label":"performance","permalink":"/prism-data-layer/adr/tags/performance"},{"inline":true,"label":"tokio","permalink":"/prism-data-layer/adr/tags/tokio"}],"version":"current","sidebarPosition":19,"frontMatter":{"title":"ADR-019: Rust Async Concurrency Patterns","status":"Accepted","date":"2025-10-07T00:00:00.000Z","deciders":"Core Team","tags":["rust","concurrency","async","performance","tokio"]},"sidebar":"adrSidebar","previous":{"title":"ADR-018: Rust Error Handling Strategy","permalink":"/prism-data-layer/adr/rust-error-handling-strategy"},"next":{"title":"ADR-020: Rust Testing Strategy","permalink":"/prism-data-layer/adr/rust-testing-strategy"}}');var t=s(4848),i=s(8453);const a={title:"ADR-019: Rust Async Concurrency Patterns",status:"Accepted",date:new Date("2025-10-07T00:00:00.000Z"),deciders:"Core Team",tags:["rust","concurrency","async","performance","tokio"]},o=void 0,l={},c=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Architecture",id:"architecture",level:3},{value:"Tokio Runtime Configuration",id:"tokio-runtime-configuration",level:3},{value:"Spawning Concurrent Tasks",id:"spawning-concurrent-tasks",level:3},{value:"Channel Patterns",id:"channel-patterns",level:3},{value:"Select for Multiplexing",id:"select-for-multiplexing",level:3},{value:"Connection Pooling",id:"connection-pooling",level:3},{value:"Graceful Shutdown",id:"graceful-shutdown",level:3},{value:"Alternatives Considered",id:"alternatives-considered",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Implementation Notes",id:"implementation-notes",level:2},{value:"Cargo Dependencies",id:"cargo-dependencies",level:3},{value:"Task Spawning Best Practices",id:"task-spawning-best-practices",level:3},{value:"Error Handling in Async",id:"error-handling-in-async",level:3},{value:"Testing Async Code",id:"testing-async-code",level:3},{value:"References",id:"references",level:2},{value:"Revision History",id:"revision-history",level:2}];function d(n){const e={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{id:"context",children:"Context"}),"\n",(0,t.jsx)(e.p,{children:"Prism proxy must handle:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Thousands of concurrent requests"}),"\n",(0,t.jsx)(e.li,{children:"Async I/O to multiple backends"}),"\n",(0,t.jsx)(e.li,{children:"Connection pooling and management"}),"\n",(0,t.jsx)(e.li,{children:"Request timeouts and cancellation"}),"\n",(0,t.jsx)(e.li,{children:"Graceful shutdown"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Requirements:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"High throughput (10k+ RPS)"}),"\n",(0,t.jsx)(e.li,{children:"Low latency (P99 < 10ms)"}),"\n",(0,t.jsx)(e.li,{children:"Efficient resource utilization"}),"\n",(0,t.jsx)(e.li,{children:"Predictable performance (no GC pauses)"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"decision",children:"Decision"}),"\n",(0,t.jsxs)(e.p,{children:["Use ",(0,t.jsx)(e.strong,{children:"Tokio async runtime"})," with established concurrency patterns:"]}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"tokio as async runtime"})," (work-stealing scheduler)"]}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"spawn tasks for concurrent operations"})}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"channels for communication"})," (mpsc, broadcast, oneshot)"]}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"select! for multiplexing"})}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"timeout and cancellation"})," via ",(0,t.jsx)(e.code,{children:"tokio::time"})," and ",(0,t.jsx)(e.code,{children:"select!"})]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"connection pooling"})," with ",(0,t.jsx)(e.code,{children:"deadpool"})," or ",(0,t.jsx)(e.code,{children:"bb8"})]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"rationale",children:"Rationale"}),"\n",(0,t.jsx)(e.h3,{id:"architecture",children:"Architecture"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502  gRPC Server\u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502  Handler    \u2502 (tokio::spawn per request)\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502                         \u2502\n         CONCURRENT                     \u2502\n              \u2502                         \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  Backend Pool 1    \u2502    \u2502  Backend Pool 2    \u2502\n    \u2502  (connection pool) \u2502    \u2502  (connection pool) \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502                         \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502   PostgreSQL       \u2502    \u2502     SQLite         \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(e.h3,{id:"tokio-runtime-configuration",children:"Tokio Runtime Configuration"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'// main.rs\n#[tokio::main(flavor = "multi_thread", worker_threads = 8)]\nasync fn main() -> Result<()> {\n    // Configure runtime\n    let runtime = tokio::runtime::Builder::new_multi_thread()\n        .worker_threads(num_cpus::get())\n        .thread_name("prism-worker")\n        .enable_all()\n        .build()?;\n\n    runtime.block_on(async {\n        run_server().await\n    })\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"spawning-concurrent-tasks",children:"Spawning Concurrent Tasks"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use tokio::task;\n\n// Spawn independent tasks\nasync fn process_batch(items: Vec<Item>) -> Result<()> {\n    let mut handles = Vec::new();\n\n    for item in items {\n        let handle = task::spawn(async move {\n            process_item(item).await\n        });\n        handles.push(handle);\n    }\n\n    // Wait for all tasks\n    for handle in handles {\n        handle.await??;\n    }\n\n    Ok(())\n}\n\n// Or use join! for fixed number of tasks\nuse tokio::join;\n\nasync fn parallel_operations() -> Result<()> {\n    let (result1, result2, result3) = join!(\n        operation1(),\n        operation2(),\n        operation3(),\n    );\n\n    result1?;\n    result2?;\n    result3?;\n\n    Ok(())\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"channel-patterns",children:"Channel Patterns"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use tokio::sync::{mpsc, oneshot, broadcast};\n\n// Multi-producer, single-consumer\nasync fn worker_pool() {\n    let (tx, mut rx) = mpsc::channel::<Task>(100);\n\n    // Spawn workers\n    for i in 0..8 {\n        let mut rx_clone = rx.clone();\n        task::spawn(async move {\n            while let Some(task) = rx_clone.recv().await {\n                process_task(task).await;\n            }\n        });\n    }\n\n    // Send work\n    for task in tasks {\n        tx.send(task).await?;\n    }\n}\n\n// One-shot for request-response\nasync fn request_response() -> Result<Response> {\n    let (tx, rx) = oneshot::channel();\n\n    task::spawn(async move {\n        let result = compute_result().await;\n        tx.send(result).ok();\n    });\n\n    rx.await?\n}\n\n// Broadcast for fan-out\nasync fn broadcast_shutdown() {\n    let (tx, _rx) = broadcast::channel(16);\n\n    // Clone for each listener\n    let mut rx1 = tx.subscribe();\n    let mut rx2 = tx.subscribe();\n\n    // Broadcast shutdown\n    tx.send(()).ok();\n\n    // Listeners receive\n    rx1.recv().await.ok();\n    rx2.recv().await.ok();\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"select-for-multiplexing",children:"Select for Multiplexing"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use tokio::select;\n\nasync fn operation_with_timeout() -> Result<Response> {\n    let timeout = tokio::time::sleep(Duration::from_secs(30));\n\n    select! {\n        result = backend.query() => {\n            result\n        }\n        _ = timeout => {\n            Err(anyhow!("operation timed out"))\n        }\n        _ = shutdown_signal.recv() => {\n            Err(anyhow!("shutting down"))\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"connection-pooling",children:"Connection Pooling"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use sqlx::postgres::PgPoolOptions;\nuse std::time::Duration;\n\nasync fn create_pool(database_url: &str) -> Result<PgPool> {\n    PgPoolOptions::new()\n        .max_connections(20)\n        .min_connections(5)\n        .acquire_timeout(Duration::from_secs(5))\n        .idle_timeout(Duration::from_secs(600))\n        .max_lifetime(Duration::from_secs(1800))\n        .connect(database_url)\n        .await\n        .context("failed to create connection pool")\n}\n\n// Use pool\nasync fn query_database(pool: &PgPool, key: &str) -> Result<Item> {\n    sqlx::query_as("SELECT * FROM items WHERE key = $1")\n        .bind(key)\n        .fetch_one(pool)  // Automatically acquires from pool\n        .await\n        .context("database query failed")\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"graceful-shutdown",children:"Graceful Shutdown"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use tokio::signal;\nuse tokio::sync::broadcast;\n\nasync fn run_server() -> Result<()> {\n    let (shutdown_tx, _) = broadcast::channel(1);\n\n    // Spawn server\n    let server_handle = {\n        let mut shutdown_rx = shutdown_tx.subscribe();\n        task::spawn(async move {\n            Server::builder()\n                .add_service(service)\n                .serve_with_shutdown(addr, async {\n                    shutdown_rx.recv().await.ok();\n                })\n                .await\n        })\n    };\n\n    // Wait for shutdown signal\n    signal::ctrl_c().await?;\n    tracing::info!("shutdown signal received");\n\n    // Broadcast shutdown\n    shutdown_tx.send(()).ok();\n\n    // Wait for server to stop\n    server_handle.await??;\n\n    tracing::info!("server stopped gracefully");\n    Ok(())\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"async-std instead of tokio"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Pros: Simpler API, mirrors std library"}),"\n",(0,t.jsx)(e.li,{children:"Cons: Smaller ecosystem, fewer libraries"}),"\n",(0,t.jsx)(e.li,{children:"Rejected: tokio is industry standard"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Synchronous multithreading"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Pros: Simpler mental model"}),"\n",(0,t.jsx)(e.li,{children:"Cons: Thread overhead, doesn't scale to 10k+ connections"}),"\n",(0,t.jsx)(e.li,{children:"Rejected: async required for high concurrency"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Custom executor"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Pros: Full control"}),"\n",(0,t.jsx)(e.li,{children:"Cons: Complex, error-prone"}),"\n",(0,t.jsx)(e.li,{children:"Rejected: tokio is battle-tested"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"consequences",children:"Consequences"}),"\n",(0,t.jsx)(e.h3,{id:"positive",children:"Positive"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"High concurrency"}),": 10k+ concurrent requests"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Low latency"}),": Async I/O doesn't block threads"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Efficient"}),": Work-stealing scheduler maximizes CPU utilization"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Ecosystem"}),": Rich library support (tonic, sqlx, etc.)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Predictable"}),": No GC pauses"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"negative",children:"Negative"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Complexity"}),": Async code harder to debug than sync"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Colored functions"}),": Async/await splits the function space"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Learning curve"}),": async Rust has sharp edges"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"neutral",children:"Neutral"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Runtime overhead (minimal for I/O-bound workloads)"}),"\n",(0,t.jsx)(e.li,{children:"Must choose correct runtime flavor (multi_thread vs current_thread)"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,t.jsx)(e.h3,{id:"cargo-dependencies",children:"Cargo Dependencies"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-toml",children:'[dependencies]\ntokio = { version = "1.35", features = ["full"] }\ntokio-util = "0.7"\nasync-trait = "0.1"\nfutures = "0.3"\n'})}),"\n",(0,t.jsx)(e.h3,{id:"task-spawning-best-practices",children:"Task Spawning Best Practices"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"// \u2705 Good: spawn for CPU-bound work\ntask::spawn_blocking(|| {\n    // CPU-intensive computation\n    compute_hash(large_data)\n});\n\n// \u2705 Good: spawn for independent async work\ntask::spawn(async move {\n    background_job().await\n});\n\n// \u274c Bad: don't spawn for every tiny operation\nfor item in items {\n    task::spawn(async move {  // Too much overhead!\n        trivial_operation(item).await\n    });\n}\n\n// \u2705 Good: batch work\ntask::spawn(async move {\n    for item in items {\n        trivial_operation(item).await;\n    }\n});\n"})}),"\n",(0,t.jsx)(e.h3,{id:"error-handling-in-async",children:"Error Handling in Async"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"// Propagate errors with ?\nasync fn operation() -> Result<()> {\n    let result = backend.query().await?;\n    process(result).await?;\n    Ok(())\n}\n\n// Handle task join errors\nlet handle = task::spawn(async {\n    do_work().await\n});\n\nmatch handle.await {\n    Ok(Ok(result)) => { /* success */ }\n    Ok(Err(e)) => { /* work failed */ }\n    Err(e) => { /* task panicked or cancelled */ }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"testing-async-code",children:"Testing Async Code"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_concurrent_operations() {\n        let result = parallel_operations().await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test(flavor = "multi_thread", worker_threads = 2)]\n    async fn test_with_specific_runtime() {\n        // Test with 2 workers\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://tokio.rs",children:"Tokio Documentation"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://rust-lang.github.io/async-book/",children:"Async Rust Book"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://docs.rs/tokio/latest/tokio/runtime/",children:"Tokio Runtime Documentation"})}),"\n",(0,t.jsx)(e.li,{children:"ADR-001: Rust for the Proxy"}),"\n",(0,t.jsx)(e.li,{children:"ADR-018: Rust Error Handling Strategy"}),"\n",(0,t.jsx)(e.li,{children:"ADR-014: Go Concurrency Patterns (parallel Go patterns)"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"2025-10-07: Initial draft and acceptance"}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}}}]);