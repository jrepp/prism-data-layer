"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[2128],{4717:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"client-originated-configuration","title":"ADR-002: Client-Originated Configuration","description":"Context","source":"@site/../docs-cms/adr/002-client-originated-configuration.md","sourceDirName":".","slug":"/client-originated-configuration","permalink":"/prism-data-layer/adr/client-originated-configuration","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/002-client-originated-configuration.md","tags":[{"inline":true,"label":"architecture","permalink":"/prism-data-layer/adr/tags/architecture"},{"inline":true,"label":"configuration","permalink":"/prism-data-layer/adr/tags/configuration"},{"inline":true,"label":"dx","permalink":"/prism-data-layer/adr/tags/dx"}],"version":"current","sidebarPosition":2,"frontMatter":{"title":"ADR-002: Client-Originated Configuration","status":"Accepted","date":"2025-10-05T00:00:00.000Z","deciders":"Core Team","tags":["architecture","configuration","dx"]},"sidebar":"adrSidebar","previous":{"title":"ADR-001: Rust for the Proxy Implementation","permalink":"/prism-data-layer/adr/rust-for-proxy"},"next":{"title":"ADR-003: Protobuf as Single Source of Truth","permalink":"/prism-data-layer/adr/protobuf-single-source-of-truth"}}');var t=i(4848),r=i(8453);const a={title:"ADR-002: Client-Originated Configuration",status:"Accepted",date:new Date("2025-10-05T00:00:00.000Z"),deciders:"Core Team",tags:["architecture","configuration","dx"]},l=void 0,o={},c=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Rationale",id:"rationale",level:2},{value:"How It Works",id:"how-it-works",level:3},{value:"Benefits Over Manual Provisioning",id:"benefits-over-manual-provisioning",level:3},{value:"Alternatives Considered",id:"alternatives-considered",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Implementation Notes",id:"implementation-notes",level:2},{value:"Protobuf Extensions",id:"protobuf-extensions",level:3},{value:"Capacity Planner Algorithm",id:"capacity-planner-algorithm",level:3},{value:"Evolution Strategy",id:"evolution-strategy",level:3},{value:"References",id:"references",level:2},{value:"Revision History",id:"revision-history",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,t.jsx)(n.p,{children:"Traditional data infrastructure requires manual provisioning:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Application team estimates data requirements"}),"\n",(0,t.jsx)(n.li,{children:"DBA provisions database cluster"}),"\n",(0,t.jsx)(n.li,{children:"Application team configures connection details"}),"\n",(0,t.jsx)(n.li,{children:"Capacity is often wrong (over or under-provisioned)"}),"\n",(0,t.jsx)(n.li,{children:"Changes require coordination between teams"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Netflix's Data Gateway improves this with declarative deployment configuration, but still requires infrastructure team involvement to map capacity requirements to hardware."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem"}),": Manual capacity planning is slow, error-prone, and creates bottlenecks."]}),"\n",(0,t.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,t.jsxs)(n.p,{children:["Implement ",(0,t.jsx)(n.strong,{children:"client-originated configuration"})," where applications declare their data access patterns in protobuf definitions, and Prism automatically:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Selects optimal backend storage engine"}),"\n",(0,t.jsx)(n.li,{children:"Calculates capacity requirements"}),"\n",(0,t.jsx)(n.li,{children:"Provisions infrastructure"}),"\n",(0,t.jsx)(n.li,{children:"Configures connections and policies"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"rationale",children:"Rationale"}),"\n",(0,t.jsx)(n.h3,{id:"how-it-works",children:"How It Works"}),"\n",(0,t.jsx)(n.p,{children:"Applications define data models with annotations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-protobuf",children:'message UserEvents {\n  string user_id = 1 [(prism.index) = "partition_key"];\n  bytes event_data = 2;\n  int64 timestamp = 3 [(prism.index) = "clustering_key"];\n\n  option (prism.access_pattern) = "append_heavy";  // 95% writes, 5% reads\n  option (prism.estimated_write_rps) = "10000";     // Peak writes/sec\n  option (prism.estimated_read_rps) = "500";        // Peak reads/sec\n  option (prism.data_size_estimate_mb) = "1000";    // Total data size\n  option (prism.retention_days) = "90";             // Auto-delete old data\n  option (prism.consistency) = "eventual";          // Consistency requirement\n  option (prism.latency_p99_ms) = "10";             // Latency SLO\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Prism's capacity planner:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Analyzes access pattern"}),': "append_heavy" \u2192 Kafka is ideal']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Calculates partition count"}),": 10k writes/sec \u2192 20 partitions (500 writes/partition/sec)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Provisions cluster"}),": Creates Kafka cluster with appropriate instance types"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Configures retention"}),": Sets 90-day retention policy"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sets up monitoring"}),": Alerts if P99 > 10ms or RPS exceeds 10k"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"benefits-over-manual-provisioning",children:"Benefits Over Manual Provisioning"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Aspect"}),(0,t.jsx)(n.th,{children:"Manual"}),(0,t.jsx)(n.th,{children:"Client-Originated"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Time to provision"}),(0,t.jsx)(n.td,{children:"Days/weeks"}),(0,t.jsx)(n.td,{children:"Minutes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Accuracy"}),(0,t.jsx)(n.td,{children:"Often wrong"}),(0,t.jsx)(n.td,{children:"Data-driven"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Ownership"}),(0,t.jsx)(n.td,{children:"Split (app + infra teams)"}),(0,t.jsx)(n.td,{children:"Clear (app team)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Scaling"}),(0,t.jsx)(n.td,{children:"Manual requests"}),(0,t.jsx)(n.td,{children:"Automatic"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Cost optimization"}),(0,t.jsx)(n.td,{children:"Ad-hoc"}),(0,t.jsx)(n.td,{children:"Continuous"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Manual Provisioning"})," (traditional approach)"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Pros:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Full control"}),"\n",(0,t.jsx)(n.li,{children:"Familiar to ops teams"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Cons:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Slow (days/weeks)"}),"\n",(0,t.jsx)(n.li,{children:"Error-prone"}),"\n",(0,t.jsx)(n.li,{children:"Creates bottlenecks"}),"\n",(0,t.jsx)(n.li,{children:"Scales poorly (1 DBA : N teams)"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Rejected because: Doesn't scale as org grows"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Declarative Deployment Config"})," (Netflix's approach)"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Pros:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Better than manual"}),"\n",(0,t.jsx)(n.li,{children:"Infrastructure as code"}),"\n",(0,t.jsx)(n.li,{children:"Version controlled"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Cons:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Still requires capacity planning expertise"}),"\n",(0,t.jsx)(n.li,{children:"Separate from application code"}),"\n",(0,t.jsx)(n.li,{children:"Changes require infra team review"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Rejected because: Still creates coordination overhead"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Fully Automatic"})," (no application hints)"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Pros:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Zero configuration burden"}),"\n",(0,t.jsx)(n.li,{children:"Ultimate simplicity"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Cons:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Cannot optimize for known patterns"}),"\n",(0,t.jsx)(n.li,{children:"Over-provisions to be safe"}),"\n",(0,t.jsx)(n.li,{children:"Higher costs"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Rejected because: Loses optimization opportunities"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Runtime Metrics-Based"})," (scale based on observed load)"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Pros:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Responds to actual usage"}),"\n",(0,t.jsx)(n.li,{children:"No estimation needed"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Cons:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Reactive not proactive"}),"\n",(0,t.jsx)(n.li,{children:"Poor for spiky workloads"}),"\n",(0,t.jsx)(n.li,{children:"Doesn't help initial provisioning"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Rejected because: Can be combined with client-originated config for continuous optimization"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,t.jsx)(n.h3,{id:"positive",children:"Positive"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Faster Development"}),": No waiting for database provisioning"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Self-Service"}),": Application teams are empowered"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Accurate Capacity"}),": Based on actual requirements, not guesses"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cost Optimization"}),": Right-sized infrastructure from day one"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Living Documentation"}),": Protobuf definitions document requirements"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Easier Migrations"}),": Change ",(0,t.jsx)(n.code,{children:'option (prism.backend) = "postgres"'})," to ",(0,t.jsx)(n.code,{children:'"kafka"'})," and redeploy"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"negative",children:"Negative"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"More Complex Tooling"}),": Capacity planner must be sophisticated","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"Mitigation"}),": Start with conservative heuristics; refine over time"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Protobuf Coupling"}),": Configuration embedded in data models","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"Mitigation"}),": This is intentional; keeps requirements close to code"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Requires Estimation"}),": Teams must estimate RPS, data size","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"Mitigation"}),": Provide estimation tools; Prism adapts based on actual metrics"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"neutral",children:"Neutral"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Shifts Responsibility"}),": From infra team to app teams","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Some teams will prefer this (autonomy)"}),"\n",(0,t.jsx)(n.li,{children:"Others may miss having an expert provision for them"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"Plan"}),": Provide templates and examples for common patterns"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,t.jsx)(n.h3,{id:"protobuf-extensions",children:"Protobuf Extensions"}),"\n",(0,t.jsxs)(n.p,{children:["Define custom options in ",(0,t.jsx)(n.code,{children:"prism/options.proto"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-protobuf",children:'syntax = "proto3";\n\npackage prism;\n\nimport "google/protobuf/descriptor.proto";\n\nextend google.protobuf.MessageOptions {\n  // Access pattern hint\n  string access_pattern = 50001;  // "read_heavy" | "write_heavy" | "append_heavy" | "balanced"\n\n  // Capacity estimates\n  int64 estimated_read_rps = 50002;\n  int64 estimated_write_rps = 50003;\n  int64 data_size_estimate_mb = 50004;\n\n  // Policies\n  int32 retention_days = 50005;\n  string consistency = 50006;  // "strong" | "eventual" | "causal"\n  int32 latency_p99_ms = 50007;\n\n  // Backend override (optional)\n  string backend = 50008;  // "postgres" | "kafka" | "sqlite" | etc.\n}\n\nextend google.protobuf.FieldOptions {\n  // Index type\n  string index = 50101;  // "primary" | "secondary" | "partition_key" | "clustering_key"\n\n  // PII tagging\n  string pii = 50102;  // "email" | "name" | "ssn" | etc.\n\n  // Encryption\n  bool encrypt_at_rest = 50103;\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"capacity-planner-algorithm",children:"Capacity Planner Algorithm"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'struct CapacityPlanner;\n\nimpl CapacityPlanner {\n    fn plan(&self, config: &MessageConfig) -> InfrastructureSpec {\n        // 1. Select backend based on access pattern\n        let backend = self.select_backend(config);\n\n        // 2. Calculate required capacity\n        let capacity = match backend {\n            Backend::Kafka => self.plan_kafka(config),\n            Backend::Postgres => self.plan_postgres(config),\n            Backend::Nats => self.plan_nats(config),\n            // ...\n        };\n\n        // 3. Return infrastructure specification\n        InfrastructureSpec {\n            backend,\n            capacity,\n            policies: self.extract_policies(config),\n        }\n    }\n\n    fn select_backend(&self, config: &MessageConfig) -> Backend {\n        if let Some(explicit) = config.backend {\n            return explicit;\n        }\n\n        match config.access_pattern {\n            "append_heavy" => Backend::Kafka,\n            "read_heavy" if config.supports_sql() => Backend::Postgres,\n            "balanced" => Backend::Postgres,\n            "graph" => Backend::Neptune,\n            _ => Backend::Postgres, // Safe default\n        }\n    }\n\n    fn plan_kafka(&self, config: &MessageConfig) -> KafkaCapacity {\n        // Rule of thumb: 500 writes/sec per partition\n        let partitions = (config.estimated_write_rps / 500).max(1);\n\n        // Calculate retention storage\n        let daily_data_mb = (config.estimated_write_rps * 86400 * config.avg_message_size_bytes) / 1_000_000;\n        let retention_storage_gb = daily_data_mb * config.retention_days / 1000;\n\n        KafkaCapacity {\n            partitions,\n            replication_factor: 3,  // Default for durability\n            retention_storage_gb,\n            instance_type: self.select_kafka_instance_type(config),\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"evolution-strategy",children:"Evolution Strategy"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Phase 1"})," (MVP): Support explicit backend selection"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-protobuf",children:'option (prism.backend) = "postgres";\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Phase 2"}),": Add access pattern hints"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-protobuf",children:'option (prism.access_pattern) = "read_heavy";\noption (prism.estimated_read_rps) = "10000";\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Phase 3"}),": Automatic backend selection based on patterns"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Phase 4"}),": Continuous optimization using runtime metrics"]}),"\n",(0,t.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Netflix Data Gateway Deployment Configuration"}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://wa.aws.amazon.com/",children:"AWS Well-Architected Framework - Capacity Planning"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://sre.google/sre-book/handling-overload/",children:"Google SRE Book - Capacity Planning"})}),"\n",(0,t.jsx)(n.li,{children:"ADR-003: Protobuf as Single Source of Truth"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"2025-10-05: Initial draft and acceptance"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var s=i(6540);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);