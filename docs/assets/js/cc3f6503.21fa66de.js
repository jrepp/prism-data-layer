"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[8978],{8167:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>c,contentTitle:()=>a,default:()=>g,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"dynamic-client-configuration","title":"ADR-022: Dynamic Client Configuration System","description":"Context","source":"@site/../docs-cms/adr/022-dynamic-client-configuration.md","sourceDirName":".","slug":"/dynamic-client-configuration","permalink":"/prism-data-layer/adr/dynamic-client-configuration","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/022-dynamic-client-configuration.md","tags":[{"inline":true,"label":"architecture","permalink":"/prism-data-layer/adr/tags/architecture"},{"inline":true,"label":"configuration","permalink":"/prism-data-layer/adr/tags/configuration"},{"inline":true,"label":"client-server","permalink":"/prism-data-layer/adr/tags/client-server"},{"inline":true,"label":"protobuf","permalink":"/prism-data-layer/adr/tags/protobuf"}],"version":"current","sidebarPosition":22,"frontMatter":{"title":"ADR-022: Dynamic Client Configuration System","status":"Accepted","date":"2025-10-07T00:00:00.000Z","deciders":"Core Team","tags":["architecture","configuration","client-server","protobuf"]},"sidebar":"adrSidebar","previous":{"title":"ADR-021: Rust Structured Logging with Tracing","permalink":"/prism-data-layer/adr/rust-structured-logging"},"next":{"title":"ADR-023: gRPC-First Interface Design","permalink":"/prism-data-layer/adr/grpc-first-interface-design"}}');var t=i(4848),s=i(8453);const o={title:"ADR-022: Dynamic Client Configuration System",status:"Accepted",date:new Date("2025-10-07T00:00:00.000Z"),deciders:"Core Team",tags:["architecture","configuration","client-server","protobuf"]},a=void 0,c={},l=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Configuration Architecture",id:"configuration-architecture",level:3},{value:"Client Configuration Descriptor (Protobuf)",id:"client-configuration-descriptor-protobuf",level:3},{value:"Configuration Service (gRPC)",id:"configuration-service-grpc",level:3},{value:"Client Connection Flow",id:"client-connection-flow",level:3},{value:"Example: Named Configuration",id:"example-named-configuration",level:3},{value:"Server Configuration (Static)",id:"server-configuration-static",level:3},{value:"Protobuf Tagging for Configuration",id:"protobuf-tagging-for-configuration",level:3},{value:"Alternatives Considered",id:"alternatives-considered",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Implementation Notes",id:"implementation-notes",level:2},{value:"Configuration Storage",id:"configuration-storage",level:3},{value:"Configuration Validation",id:"configuration-validation",level:3},{value:"Configuration Caching",id:"configuration-caching",level:3},{value:"References",id:"references",level:2},{value:"Revision History",id:"revision-history",level:2}];function d(n){const e={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{id:"context",children:"Context"}),"\n",(0,t.jsx)(e.p,{children:"Prism needs a flexible configuration system that:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Separates client configuration from server infrastructure configuration"}),"\n",(0,t.jsx)(e.li,{children:"Allows clients to specify their data access patterns at runtime"}),"\n",(0,t.jsx)(e.li,{children:"Supports server-side configuration templates for common patterns"}),"\n",(0,t.jsx)(e.li,{children:"Enables configuration discovery and reuse"}),"\n",(0,t.jsx)(e.li,{children:"Follows Netflix Data Gateway patterns while improving on them"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Key Requirements:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Server config"}),": Backend databases, queues, infrastructure (static, admin-controlled)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Client config"}),": Data access patterns, backend selection, consistency requirements (dynamic, client-controlled)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Configuration portability"}),": Clients can bring their config or use server-provided templates"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Versioning"}),": Configuration evolves without breaking existing clients"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"decision",children:"Decision"}),"\n",(0,t.jsxs)(e.p,{children:["Implement ",(0,t.jsx)(e.strong,{children:"Dynamic Client Configuration"})," with protobuf descriptors:"]}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Separation"}),": Server manages infrastructure, clients manage access patterns"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Protobuf descriptors"}),": Client configuration expressed as protobuf messages"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Named configurations"}),": Server stores reusable configuration templates"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Runtime discovery"}),": Clients can query available configurations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Override capability"}),": Clients can provide custom configurations inline"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"rationale",children:"Rationale"}),"\n",(0,t.jsx)(e.h3,{id:"configuration-architecture",children:"Configuration Architecture"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:'\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Prism Server                         \u2502\n\u2502                                                           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502 Server Config      \u2502        \u2502 Client Config     \u2502   \u2502\n\u2502  \u2502 (Static/Admin)     \u2502        \u2502 (Dynamic/Runtime) \u2502   \u2502\n\u2502  \u2502                    \u2502        \u2502                   \u2502   \u2502\n\u2502  \u2502 - Postgres pool    \u2502        \u2502 - Named configs   \u2502   \u2502\n\u2502  \u2502 - Kafka brokers    \u2502        \u2502 - Access patterns \u2502   \u2502\n\u2502  \u2502 - NATS cluster     \u2502        \u2502 - Backend routing \u2502   \u2502\n\u2502  \u2502 - Auth policies    \u2502        \u2502 - Consistency     \u2502   \u2502\n\u2502  \u2502 - Rate limits      \u2502        \u2502 - Cache policy    \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                                                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                           \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502                         \u2502\n              \u2502                         \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502   Client A        \u2502     \u2502   Client B        \u2502\n    \u2502                   \u2502     \u2502                   \u2502\n    \u2502 Uses named config \u2502     \u2502 Provides custom   \u2502\n    \u2502 "user-profiles"   \u2502     \u2502 inline config     \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n'})}),"\n",(0,t.jsx)(e.h3,{id:"client-configuration-descriptor-protobuf",children:"Client Configuration Descriptor (Protobuf)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-protobuf",children:'// proto/prism/config/v1/client_config.proto\nsyntax = "proto3";\n\npackage prism.config.v1;\n\nimport "prism/options.proto";\n\n// Client configuration descriptor\nmessage ClientConfig {\n  option (prism.schema) = {\n    version: "1.0.0"\n    category: "config"\n    compatibility: COMPATIBILITY_MODE_BACKWARD\n    backend: "postgres"\n    track_evolution: true\n    owner: "platform-team"\n    tags: ["client", "configuration", "core"]\n  };\n\n  option (prism.protocol) = {\n    recording: RECORDING_LEVEL_METADATA\n    category: "config"\n    operation: "client_config"\n    sample_rate: 0.1\n    tags: ["configuration", "audit"]\n  };\n\n  // Configuration name (for named configs)\n  string name = 1 [\n    (prism.field_schema) = {\n      index: INDEX_TYPE_PRIMARY\n      required_for_create: true\n    }\n  ];\n\n  // Version for evolution\n  string version = 2 [\n    (prism.field_schema) = {\n      index: INDEX_TYPE_SECONDARY\n      required_for_create: true\n    }\n  ];\n\n  // Data access pattern\n  AccessPattern pattern = 3 [\n    (prism.field_schema) = {\n      required_for_create: true\n    }\n  ];\n\n  // Backend selection\n  BackendConfig backend = 4 [\n    (prism.field_schema) = {\n      required_for_create: true\n    }\n  ];\n\n  // Consistency requirements\n  ConsistencyConfig consistency = 5;\n\n  // Caching policy\n  CacheConfig cache = 6;\n\n  // Rate limiting\n  RateLimitConfig rate_limit = 7;\n\n  // Namespace for data isolation\n  string namespace = 8 [\n    (prism.field_schema) = {\n      index: INDEX_TYPE_SECONDARY\n      required_for_create: true\n    }\n  ];\n}\n\n// Access patterns supported by Prism\nenum AccessPattern {\n  ACCESS_PATTERN_UNSPECIFIED = 0;\n  ACCESS_PATTERN_KEY_VALUE = 1;        // Simple get/put\n  ACCESS_PATTERN_QUEUE = 2;            // Kafka-style queue\n  ACCESS_PATTERN_PUBSUB = 3;           // NATS-style pub/sub\n  ACCESS_PATTERN_PAGED_READER = 4;     // Database pagination\n  ACCESS_PATTERN_TRANSACT_WRITE = 5;   // Transactional writes\n}\n\n// Backend configuration\nmessage BackendConfig {\n  // Backend type\n  BackendType type = 1;\n\n  // Backend-specific options\n  map<string, string> options = 2;\n\n  // Connection pool settings\n  PoolConfig pool = 3;\n}\n\nenum BackendType {\n  BACKEND_TYPE_UNSPECIFIED = 0;\n  BACKEND_TYPE_POSTGRES = 1;\n  BACKEND_TYPE_SQLITE = 2;\n  BACKEND_TYPE_KAFKA = 3;\n  BACKEND_TYPE_NATS = 4;\n  BACKEND_TYPE_NEPTUNE = 5;\n}\n\nmessage PoolConfig {\n  int32 min_connections = 1;\n  int32 max_connections = 2;\n  int32 idle_timeout_seconds = 3;\n}\n\n// Consistency configuration\nmessage ConsistencyConfig {\n  ConsistencyLevel level = 1;\n  int32 timeout_ms = 2;\n}\n\nenum ConsistencyLevel {\n  CONSISTENCY_LEVEL_UNSPECIFIED = 0;\n  CONSISTENCY_LEVEL_EVENTUAL = 1;\n  CONSISTENCY_LEVEL_STRONG = 2;\n  CONSISTENCY_LEVEL_BOUNDED_STALENESS = 3;\n}\n\n// Cache configuration\nmessage CacheConfig {\n  bool enabled = 1;\n  int32 ttl_seconds = 2;\n  int32 max_size_mb = 3;\n}\n\n// Rate limit configuration\nmessage RateLimitConfig {\n  int32 requests_per_second = 1;\n  int32 burst = 2;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"configuration-service-grpc",children:"Configuration Service (gRPC)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-protobuf",children:'// proto/prism/config/v1/config_service.proto\nsyntax = "proto3";\n\npackage prism.config.v1;\n\nimport "prism/config/v1/client_config.proto";\n\n// Configuration service for managing client configs\nservice ConfigService {\n  // List available named configurations\n  rpc ListConfigs(ListConfigsRequest) returns (ListConfigsResponse);\n\n  // Get a specific named configuration\n  rpc GetConfig(GetConfigRequest) returns (GetConfigResponse);\n\n  // Register a new named configuration (admin only)\n  rpc RegisterConfig(RegisterConfigRequest) returns (RegisterConfigResponse);\n\n  // Validate a configuration before use\n  rpc ValidateConfig(ValidateConfigRequest) returns (ValidateConfigResponse);\n}\n\nmessage ListConfigsRequest {\n  // Filter by access pattern\n  optional AccessPattern pattern = 1;\n\n  // Filter by namespace\n  optional string namespace = 2;\n}\n\nmessage ListConfigsResponse {\n  repeated ClientConfig configs = 1;\n}\n\nmessage GetConfigRequest {\n  string name = 1;\n  optional string version = 2;  // Empty = latest\n}\n\nmessage GetConfigResponse {\n  ClientConfig config = 1;\n}\n\nmessage RegisterConfigRequest {\n  ClientConfig config = 1;\n  bool overwrite = 2;  // Allow updating existing\n}\n\nmessage RegisterConfigResponse {\n  bool success = 1;\n  string message = 2;\n}\n\nmessage ValidateConfigRequest {\n  ClientConfig config = 1;\n}\n\nmessage ValidateConfigResponse {\n  bool valid = 1;\n  repeated string errors = 2;\n  repeated string warnings = 3;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"client-connection-flow",children:"Client Connection Flow"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:'Client                          Prism Server\n  \u2502                                  \u2502\n  \u2502  1. Connect with auth           \u2502\n  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500>\u2502\n  \u2502                                  \u2502\n  \u2502  2. Request config "user-profiles" \u2502\n  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500>\u2502\n  \u2502                                  \u2502\n  \u2502  3. Return ClientConfig         \u2502\n  \u2502<\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n  \u2502  {                               \u2502\n  \u2502    name: "user-profiles"         \u2502\n  \u2502    pattern: KEY_VALUE            \u2502\n  \u2502    backend: POSTGRES             \u2502\n  \u2502    consistency: STRONG           \u2502\n  \u2502  }                               \u2502\n  \u2502                                  \u2502\n  \u2502  4. Establish session with config\u2502\n  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500>\u2502\n  \u2502                                  \u2502\n  \u2502  5. Session token + metadata    \u2502\n  \u2502<\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n  \u2502                                  \u2502\n  \u2502  6. Make data requests          \u2502\n  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500>\u2502\n  \u2502     (using session token)        \u2502\n  \u2502                                  \u2502\n'})}),"\n",(0,t.jsx)(e.h3,{id:"example-named-configuration",children:"Example: Named Configuration"}),"\n",(0,t.jsx)(e.p,{children:"Server stores common configurations:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:'# Server-side: config/named/user-profiles.yaml\nname: user-profiles\nversion: "1.0"\npattern: KEY_VALUE\nbackend:\n  type: POSTGRES\n  options:\n    table: user_profiles\n  pool:\n    min_connections: 5\n    max_connections: 20\nconsistency:\n  level: STRONG\n  timeout_ms: 5000\ncache:\n  enabled: true\n  ttl_seconds: 300\nrate_limit:\n  requests_per_second: 1000\n  burst: 2000\nnamespace: production\n'})}),"\n",(0,t.jsx)(e.p,{children:"Client retrieves and uses:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-go",children:'// Client code\nclient := prism.NewClient(endpoint)\n\n// Option 1: Use named config\nconfig, err := client.GetConfig("user-profiles")\nsession, err := client.StartSession(config)\n\n// Option 2: Provide inline config\nconfig := &prism.ClientConfig{\n    Pattern: prism.AccessPattern_KEY_VALUE,\n    Backend: &prism.BackendConfig{\n        Type: prism.BackendType_POSTGRES,\n    },\n    Consistency: &prism.ConsistencyConfig{\n        Level: prism.ConsistencyLevel_STRONG,\n    },\n}\nsession, err := client.StartSession(config)\n'})}),"\n",(0,t.jsx)(e.h3,{id:"server-configuration-static",children:"Server Configuration (Static)"}),"\n",(0,t.jsx)(e.p,{children:"Remains infrastructure-focused:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"# Server config (admin-controlled)\nserver:\n  host: 0.0.0.0\n  port: 8980\n\nbackends:\n  postgres:\n    - name: primary\n      connection_string: postgres://...\n      max_connections: 100\n    - name: replica\n      connection_string: postgres://...\n      max_connections: 50\n\n  kafka:\n    brokers:\n      - localhost:9092\n      - localhost:9093\n\n  nats:\n    urls:\n      - nats://localhost:4222\n\nauth:\n  mtls:\n    enabled: true\n    ca_cert: /path/to/ca.pem\n\nobservability:\n  tracing:\n    exporter: jaeger\n    endpoint: localhost:14268\n  metrics:\n    exporter: prometheus\n    port: 9090\n"})}),"\n",(0,t.jsx)(e.h3,{id:"protobuf-tagging-for-configuration",children:"Protobuf Tagging for Configuration"}),"\n",(0,t.jsx)(e.p,{children:"Client configuration messages use protobuf custom options for schema evolution and protocol recording (see ADR-029, ADR-030):"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Schema Tagging:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"(prism.schema)"})," option on ClientConfig tracks versioning and compatibility"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"(prism.field_schema)"})," options on fields enable:","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Index hints for storage backends"}),"\n",(0,t.jsx)(e.li,{children:"Required field validation"}),"\n",(0,t.jsx)(e.li,{children:"Migration planning"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Protocol Tagging:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"(prism.protocol)"})," option enables recording of configuration changes"]}),"\n",(0,t.jsx)(e.li,{children:"Sampling at 10% to track config usage patterns"}),"\n",(0,t.jsx)(e.li,{children:"Metadata-only recording (no sensitive data in payloads)"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Benefits:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Configuration changes automatically recorded for audit"}),"\n",(0,t.jsx)(e.li,{children:"Schema evolution tracked in registry"}),"\n",(0,t.jsx)(e.li,{children:"Breaking changes detected before deployment"}),"\n",(0,t.jsx)(e.li,{children:"Field-level metadata drives validation and storage optimization"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Example: Recording Configuration Request"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'// Proxy automatically records configuration requests\nlet entry = ProtocolEntry {\n    id: Uuid::new_v4(),\n    category: "config",\n    operation: "client_config",\n    message_type: "prism.config.v1.ClientConfig",\n    recording_level: RecordingLevel::Metadata,\n    metadata: {\n        "name": config.name,\n        "version": config.version,\n        "pattern": format!("{:?}", config.pattern),\n        "namespace": config.namespace,\n    },\n    payload: None,  // Metadata only\n    tags: vec!["configuration", "audit"],\n};\nrecorder.record(entry).await?;\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Example: Schema Registry Integration"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"# Schemas automatically registered during build\nprism-admin schema register \\\n  --proto proto/prism/config/v1/client_config.proto \\\n  --version 1.0.0 \\\n  --environment production\n\n# Check compatibility before deployment\nprism-admin schema check \\\n  --proto proto/prism/config/v1/client_config.proto \\\n  --against 0.9.0\n"})}),"\n",(0,t.jsx)(e.h3,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Static client configuration files"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Pros: Simple, familiar pattern"}),"\n",(0,t.jsx)(e.li,{children:"Cons: No runtime discovery, hard to evolve, deployment coupling"}),"\n",(0,t.jsx)(e.li,{children:"Rejected: Doesn't support dynamic use cases"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"REST-based configuration API"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Pros: Simple HTTP, easy debugging"}),"\n",(0,t.jsx)(e.li,{children:"Cons: No type safety, manual serialization, version skew"}),"\n",(0,t.jsx)(e.li,{children:"Rejected: Protobuf provides better type safety and evolution"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Environment variables for client config"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Pros: 12-factor compliant"}),"\n",(0,t.jsx)(e.li,{children:"Cons: Limited structure, hard to compose, no discovery"}),"\n",(0,t.jsx)(e.li,{children:"Rejected: Too limited for complex configurations"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Configuration in application code"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Pros: Type-safe, compile-time validation"}),"\n",(0,t.jsx)(e.li,{children:"Cons: Requires deployment to change, no runtime flexibility"}),"\n",(0,t.jsx)(e.li,{children:"Rejected: Conflicts with dynamic configuration goal"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"consequences",children:"Consequences"}),"\n",(0,t.jsx)(e.h3,{id:"positive",children:"Positive"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Clean separation"}),": Server infrastructure vs. client access patterns"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Runtime flexibility"}),": Clients can adapt configuration without redeployment"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Discovery"}),": Clients can browse available configurations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Reusability"}),": Named configs shared across clients"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Evolution"}),": Protobuf versioning supports backward compatibility"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Type safety"}),": Protobuf ensures correct configuration structure"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Netflix-inspired"}),": Follows proven patterns from Data Gateway"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"negative",children:"Negative"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Additional complexity"}),": Two configuration systems to manage"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Discovery overhead"}),": Clients make extra RPC to fetch config"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Storage required"}),": Server must persist named configurations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Validation needed"}),": Server must validate client-provided configs"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"neutral",children:"Neutral"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Learning curve"}),": Teams must understand dual configuration model"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Migration path"}),": Existing systems need gradual migration"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,t.jsx)(e.h3,{id:"configuration-storage",children:"Configuration Storage"}),"\n",(0,t.jsx)(e.p,{children:"Server stores named configurations:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"config/\n\u251c\u2500\u2500 named/\n\u2502   \u251c\u2500\u2500 user-profiles.yaml\n\u2502   \u251c\u2500\u2500 session-cache.yaml\n\u2502   \u251c\u2500\u2500 event-queue.yaml\n\u2502   \u2514\u2500\u2500 analytics-stream.yaml\n\u2514\u2500\u2500 templates/\n    \u251c\u2500\u2500 key-value.yaml\n    \u251c\u2500\u2500 queue.yaml\n    \u2514\u2500\u2500 pubsub.yaml\n"})}),"\n",(0,t.jsx)(e.h3,{id:"configuration-validation",children:"Configuration Validation"}),"\n",(0,t.jsx)(e.p,{children:"Server validates all configurations:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"impl ConfigValidator {\n    fn validate(&self, config: &ClientConfig) -> Result<(), Vec<ValidationError>> {\n        let mut errors = Vec::new();\n\n        // Check backend compatibility with pattern\n        if config.pattern == AccessPattern::Queue\n           && config.backend.type != BackendType::Kafka {\n            errors.push(ValidationError::IncompatibleBackend);\n        }\n\n        // Check namespace exists\n        if !self.namespace_exists(&config.namespace) {\n            errors.push(ValidationError::UnknownNamespace);\n        }\n\n        // Check rate limits are reasonable\n        if config.rate_limit.requests_per_second > MAX_RPS {\n            errors.push(ValidationError::RateLimitTooHigh);\n        }\n\n        if errors.is_empty() { Ok(()) } else { Err(errors) }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"configuration-caching",children:"Configuration Caching"}),"\n",(0,t.jsx)(e.p,{children:"Client caches configurations locally:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-go",children:"type ConfigCache struct {\n    cache map[string]*ClientConfig\n    ttl   time.Duration\n}\n\nfunc (c *ConfigCache) Get(name string) (*ClientConfig, error) {\n    if config, ok := c.cache[name]; ok {\n        return config, nil\n    }\n\n    // Fetch from server\n    config, err := c.client.GetConfig(name)\n    if err != nil {\n        return nil, err\n    }\n\n    c.cache[name] = config\n    return config, nil\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://netflixtechblog.com/data-gateway-a-platform-for-growing-and-protecting-the-data-tier-f1-2019-3fd1a829503",children:"Netflix Data Gateway Architecture"})}),"\n",(0,t.jsx)(e.li,{children:"ADR-002: Client-Originated Configuration"}),"\n",(0,t.jsx)(e.li,{children:"ADR-003: Protobuf as Single Source of Truth"}),"\n",(0,t.jsx)(e.li,{children:"ADR-006: Namespace and Multi-Tenancy"}),"\n",(0,t.jsx)(e.li,{children:"ADR-029: Protocol Recording with Protobuf Tagging"}),"\n",(0,t.jsx)(e.li,{children:"ADR-030: Schema Recording with Protobuf Tagging"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"2025-10-08: Added protobuf tagging section with schema and protocol recording examples"}),"\n",(0,t.jsx)(e.li,{children:"2025-10-07: Initial draft and acceptance"}),"\n"]})]})}function g(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>o,x:()=>a});var r=i(6540);const t={},s=r.createContext(t);function o(n){const e=r.useContext(s);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:o(n.components),r.createElement(s.Provider,{value:e},n.children)}}}]);