"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[75319],{28453:(n,e,r)=>{r.d(e,{R:()=>s,x:()=>l});var t=r(96540);const a={},i=t.createContext(a);function s(n){const e=t.useContext(i);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:s(n.components),t.createElement(i.Provider,{value:e},n.children)}},90649:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"adr-056","title":"ADR-056: Launcher-Admin Control Plane Protocol","description":"Context","source":"@site/../docs-cms/adr/adr-056-launcher-admin-control-plane.md","sourceDirName":".","slug":"/adr-056","permalink":"/prism-data-layer/adr/adr-056","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/adr-056-launcher-admin-control-plane.md","tags":[{"inline":true,"label":"launcher","permalink":"/prism-data-layer/adr/tags/launcher"},{"inline":true,"label":"admin","permalink":"/prism-data-layer/adr/tags/admin"},{"inline":true,"label":"control-plane","permalink":"/prism-data-layer/adr/tags/control-plane"},{"inline":true,"label":"grpc","permalink":"/prism-data-layer/adr/tags/grpc"},{"inline":true,"label":"patterns","permalink":"/prism-data-layer/adr/tags/patterns"},{"inline":true,"label":"lifecycle","permalink":"/prism-data-layer/adr/tags/lifecycle"}],"version":"current","frontMatter":{"date":"2025-10-15T00:00:00.000Z","deciders":"Engineering Team","doc_uuid":"2f8a9c4e-1b3d-4a5f-9e7c-6d2f8a4b9c3e","id":"adr-056","project_id":"prism-data-layer","status":"Accepted","tags":["launcher","admin","control-plane","grpc","patterns","lifecycle"],"title":"ADR-056: Launcher-Admin Control Plane Protocol"},"sidebar":"adrSidebar","previous":{"title":"Proxy-Admin Control Plane Protocol \u2022 ADR-055","permalink":"/prism-data-layer/adr/adr-055"},"next":{"title":"Refactor pattern-launcher to prism-launcher as General Control Plane Launcher \u2022 ADR-057","permalink":"/prism-data-layer/adr/adr-057"}}');var a=r(74848),i=r(28453);const s={date:new Date("2025-10-15T00:00:00.000Z"),deciders:"Engineering Team",doc_uuid:"2f8a9c4e-1b3d-4a5f-9e7c-6d2f8a4b9c3e",id:"adr-056",project_id:"prism-data-layer",status:"Accepted",tags:["launcher","admin","control-plane","grpc","patterns","lifecycle"],title:"ADR-056: Launcher-Admin Control Plane Protocol"},l=void 0,c={},o=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Alternatives Considered",id:"alternatives-considered",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Implementation Notes",id:"implementation-notes",level:2},{value:"Launcher-Side Admin Client",id:"launcher-side-admin-client",level:3},{value:"Admin-Side Launcher Control",id:"admin-side-launcher-control",level:3},{value:"Storage Schema Extensions",id:"storage-schema-extensions",level:3},{value:"Launcher Configuration",id:"launcher-configuration",level:3},{value:"Graceful Fallback",id:"graceful-fallback",level:3},{value:"prismctl Local Integration",id:"prismctl-local-integration",level:3},{value:"References",id:"references",level:2},{value:"Revision History",id:"revision-history",level:2}];function d(n){const e={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h2,{id:"context",children:"Context"}),"\n",(0,a.jsx)(e.p,{children:"The pattern-launcher (prism-launcher) currently operates independently without admin coordination. This creates operational challenges:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Pattern Registry"}),": No central view of which patterns are running on which launchers"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Pattern Distribution"}),": Cannot distribute patterns across launcher instances"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Dynamic Pattern Provisioning"}),": Pattern deployments require manual launcher configuration"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Health Monitoring"}),": No centralized view of pattern health across launchers"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Namespace Coordination"}),": Launchers don't coordinate with admin on namespace assignments"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"Per ADR-055, prism-proxy now connects to prism-admin via control plane protocol. We need the same bidirectional gRPC control plane between prism-launcher and prism-admin for:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Launcher instances register with admin on startup"}),"\n",(0,a.jsx)(e.li,{children:"Admin tracks running patterns per launcher"}),"\n",(0,a.jsx)(e.li,{children:"Admin can provision/deprovision patterns dynamically"}),"\n",(0,a.jsx)(e.li,{children:"Launchers report pattern health via heartbeat"}),"\n",(0,a.jsx)(e.li,{children:"Namespace-pattern mapping coordinated by admin"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"decision",children:"Decision"}),"\n",(0,a.jsx)(e.p,{children:"Extend the ControlPlane gRPC service (from ADR-055) to support launcher registration and pattern lifecycle management:"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Launcher Startup"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"pattern-launcher --admin-endpoint admin.prism.local:8981 --launcher-id launcher-01 --listen :7070\n"})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Extended Control Plane Flows"}),":"]}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Launcher Registration"})," (launcher \u2192 admin):"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Launcher connects on startup, sends LauncherRegistration with ID, address, capabilities"}),"\n",(0,a.jsx)(e.li,{children:"Admin records launcher in storage (launchers table)"}),"\n",(0,a.jsx)(e.li,{children:"Admin returns assigned patterns for this launcher"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Pattern Assignment"})," (admin \u2192 launcher):"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Admin pushes PatternAssignment to launcher with pattern config"}),"\n",(0,a.jsx)(e.li,{children:"Includes namespace and backend slot configuration"}),"\n",(0,a.jsx)(e.li,{children:"Launcher validates, provisions pattern process, and activates"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Pattern Provisioning"})," (client \u2192 admin \u2192 launcher):"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Client requests pattern deployment (e.g., via prismctl)"}),"\n",(0,a.jsx)(e.li,{children:"Admin selects launcher based on capacity/region"}),"\n",(0,a.jsx)(e.li,{children:"Admin sends PatternAssignment to launcher"}),"\n",(0,a.jsx)(e.li,{children:"Launcher provisions pattern, acknowledges when ready"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Pattern Health Heartbeat"})," (launcher \u2194 admin):"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Launcher sends heartbeat every 30s with pattern health"}),"\n",(0,a.jsx)(e.li,{children:"Reports: pattern status, memory usage, restart count, error count"}),"\n",(0,a.jsx)(e.li,{children:"Admin updates pattern registry with health data"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Pattern Deprovisioning"})," (admin \u2192 launcher):"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Admin sends RevokePattern message"}),"\n",(0,a.jsx)(e.li,{children:"Launcher gracefully shuts down pattern (30s timeout)"}),"\n",(0,a.jsx)(e.li,{children:"Launcher acknowledges pattern stopped"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Protobuf Extensions"})," (add to ControlPlane service):"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-protobuf",children:"service ControlPlane {\n  // ... existing proxy RPCs ...\n\n  // Launcher \u2192 Admin: Register launcher on startup\n  rpc RegisterLauncher(LauncherRegistration) returns (LauncherRegistrationAck);\n\n  // Admin \u2192 Launcher: Assign pattern to launcher\n  rpc AssignPattern(PatternAssignment) returns (PatternAssignmentAck);\n\n  // Launcher \u2192 Admin: Report pattern health\n  rpc LauncherHeartbeat(LauncherHeartbeat) returns (HeartbeatAck);\n\n  // Admin \u2192 Launcher: Deprovision pattern\n  rpc RevokePattern(PatternRevocation) returns (PatternRevocationAck);\n}\n\nmessage LauncherRegistration {\n  string launcher_id = 1;           // Unique launcher identifier (launcher-01)\n  string address = 2;               // Launcher gRPC address (launcher-01.prism.local:7070)\n  string region = 3;                // Deployment region (us-west-2)\n  string version = 4;               // Launcher version (0.1.0)\n  repeated string capabilities = 5; // Supported isolation levels (none, namespace, session)\n  int32 max_patterns = 6;           // Maximum concurrent patterns\n  map<string, string> metadata = 7; // Custom labels\n}\n\nmessage LauncherRegistrationAck {\n  bool success = 1;\n  string message = 2;\n  repeated PatternAssignment initial_patterns = 3; // Pre-assigned patterns\n  int32 assigned_capacity = 4;                     // Number of pattern slots assigned\n}\n\nmessage PatternAssignment {\n  string pattern_id = 1;            // Unique pattern identifier\n  string pattern_type = 2;          // Pattern type (keyvalue, pubsub, multicast_registry)\n  string namespace = 3;             // Target namespace\n  string isolation_level = 4;       // Isolation level (none, namespace, session)\n  PatternConfig config = 5;         // Pattern-specific configuration\n  map<string, BackendConfig> backends = 6; // Backend slot configurations\n  int64 version = 7;                // Config version for idempotency\n}\n\nmessage PatternConfig {\n  map<string, string> settings = 1; // Pattern-specific settings\n  int32 port = 2;                   // gRPC port for pattern\n  int32 health_check_port = 3;      // HTTP health check port\n  string log_level = 4;             // Logging verbosity\n}\n\nmessage LauncherHeartbeat {\n  string launcher_id = 1;\n  map<string, PatternHealth> pattern_health = 2;\n  LauncherResourceUsage resources = 3;\n  int64 timestamp = 4;\n}\n\nmessage PatternHealth {\n  string status = 1;                // running, starting, stopping, failed, stopped\n  int32 pid = 2;                    // Process ID\n  int32 restart_count = 3;          // Number of restarts\n  int32 error_count = 4;            // Cumulative error count\n  int64 memory_mb = 5;              // Memory usage in MB\n  int64 uptime_seconds = 6;         // Seconds since pattern started\n  string last_error = 7;            // Last error message (if any)\n}\n\nmessage LauncherResourceUsage {\n  int32 pattern_count = 1;          // Current pattern count\n  int32 max_patterns = 2;           // Maximum capacity\n  int64 total_memory_mb = 3;        // Total memory used by all patterns\n  float cpu_percent = 4;            // CPU utilization percentage\n}\n\nmessage PatternRevocation {\n  string launcher_id = 1;\n  string pattern_id = 2;\n  int32 graceful_timeout_seconds = 3; // Timeout before force kill (default 30s)\n}\n\nmessage PatternRevocationAck {\n  bool success = 1;\n  string message = 2;\n  int64 stopped_at = 3;             // Unix timestamp when pattern stopped\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"rationale",children:"Rationale"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Why Extend ControlPlane Service (not separate service):"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Single gRPC connection from launcher to admin (reuses ADR-055 infrastructure)"}),"\n",(0,a.jsx)(e.li,{children:"Proxy and launcher share control plane concepts (registration, heartbeat, health)"}),"\n",(0,a.jsx)(e.li,{children:"Unified admin control surface for all components"}),"\n",(0,a.jsx)(e.li,{children:"Simpler authentication/authorization (same mTLS certs)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Why Pattern Assignment vs Self-Provisioning:"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Admin has global view of launcher capacity"}),"\n",(0,a.jsx)(e.li,{children:"Admin can balance patterns across launchers"}),"\n",(0,a.jsx)(e.li,{children:"Admin enforces namespace \u2192 launcher affinity"}),"\n",(0,a.jsx)(e.li,{children:"Client requests go through admin (centralized policy)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Why 30s Heartbeat Interval:"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Matches proxy heartbeat interval (ADR-055)"}),"\n",(0,a.jsx)(e.li,{children:"Sufficient for pattern health monitoring"}),"\n",(0,a.jsx)(e.li,{children:"Detects failed launchers within 1 minute"}),"\n",(0,a.jsx)(e.li,{children:"Low overhead (~33 heartbeats/hour per launcher)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Why Graceful Timeout on Deprovision:"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Patterns may have in-flight requests to drain"}),"\n",(0,a.jsx)(e.li,{children:"Backend connections need graceful close"}),"\n",(0,a.jsx)(e.li,{children:"Prevents data loss during shutdown"}),"\n",(0,a.jsx)(e.li,{children:"Default 30s matches Kubernetes terminationGracePeriodSeconds"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Separate LauncherControl Service"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Pros: Clean separation, launcher-specific API"}),"\n",(0,a.jsx)(e.li,{children:"Cons: Two gRPC connections per launcher, more complex mTLS setup"}),"\n",(0,a.jsx)(e.li,{children:"Rejected because: Single control plane service is simpler"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Launcher Polls Admin for Assignments"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Pros: No admin \u2192 launcher push required"}),"\n",(0,a.jsx)(e.li,{children:"Cons: Higher latency, more network traffic, admin can't push urgent changes"}),"\n",(0,a.jsx)(e.li,{children:"Rejected because: Bidirectional gRPC enables instant pattern provisioning"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Pattern Assignment via Message Queue"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Pros: Decoupled, queue-based workflow"}),"\n",(0,a.jsx)(e.li,{children:"Cons: Requires Kafka/NATS dependency, eventual consistency"}),"\n",(0,a.jsx)(e.li,{children:"Rejected because: gRPC request-response is sufficient for control plane"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Static Pattern-Launcher Mapping"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Pros: Simple, no runtime coordination"}),"\n",(0,a.jsx)(e.li,{children:"Cons: Cannot rebalance patterns, no dynamic provisioning"}),"\n",(0,a.jsx)(e.li,{children:"Rejected because: Dynamic assignment enables horizontal scaling"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"consequences",children:"Consequences"}),"\n",(0,a.jsx)(e.h3,{id:"positive",children:"Positive"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Centralized Pattern Registry"}),": Admin has complete view of patterns across all launchers"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Dynamic Pattern Provisioning"}),": Patterns deployed via admin without launcher restarts"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Load Balancing"}),": Admin distributes patterns based on launcher capacity"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Health Monitoring"}),": Pattern health visible in admin UI/API"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Namespace Coordination"}),": Admin ensures namespace-pattern consistency"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Graceful Degradation"}),": Launcher operates independently if admin unavailable"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Horizontal Scaling"}),": Add launchers, admin distributes patterns automatically"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"negative",children:"Negative"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Control Plane Dependency"}),": Launchers require admin for pattern provisioning"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Admin as SPOF"}),": If admin down, cannot provision new patterns (existing continue)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Pattern Handoff Complexity"}),": Moving patterns between launchers requires coordination"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Connection Overhead"}),": Each launcher maintains persistent gRPC connection"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"State Synchronization"}),": Admin and launcher must agree on pattern assignments"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"neutral",children:"Neutral"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Launchers can optionally run without admin (local patterns directory mode)"}),"\n",(0,a.jsx)(e.li,{children:"Admin stores launcher state in SQLite/PostgreSQL (ADR-054 storage)"}),"\n",(0,a.jsx)(e.li,{children:"Pattern capacity (max_patterns) configurable per launcher"}),"\n",(0,a.jsx)(e.li,{children:"Control plane protocol versioned independently from pattern protocols"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,a.jsx)(e.h3,{id:"launcher-side-admin-client",children:"Launcher-Side Admin Client"}),"\n",(0,a.jsxs)(e.p,{children:["Go implementation in ",(0,a.jsx)(e.code,{children:"pkg/launcher/admin_client.go"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-go",children:'type LauncherAdminClient struct {\n    client    pb.ControlPlaneClient\n    conn      *grpc.ClientConn\n    launcherID string\n    address    string\n    region     string\n    maxPatterns int32\n}\n\nfunc NewLauncherAdminClient(\n    adminEndpoint string,\n    launcherID string,\n    address string,\n    region string,\n    maxPatterns int32,\n) (*LauncherAdminClient, error) {\n    conn, err := grpc.Dial(\n        adminEndpoint,\n        grpc.WithTransportCredentials(insecure.NewCredentials()),\n    )\n    if err != nil {\n        return nil, fmt.Errorf("failed to dial admin: %w", err)\n    }\n\n    return &LauncherAdminClient{\n        client:      pb.NewControlPlaneClient(conn),\n        conn:        conn,\n        launcherID:  launcherID,\n        address:     address,\n        region:      region,\n        maxPatterns: maxPatterns,\n    }, nil\n}\n\nfunc (c *LauncherAdminClient) Register(ctx context.Context) (*pb.LauncherRegistrationAck, error) {\n    req := &pb.LauncherRegistration{\n        LauncherId:   c.launcherID,\n        Address:      c.address,\n        Region:       c.region,\n        Version:      version.Version,\n        Capabilities: []string{"none", "namespace", "session"},\n        MaxPatterns:  c.maxPatterns,\n        Metadata:     map[string]string{},\n    }\n\n    return c.client.RegisterLauncher(ctx, req)\n}\n\nfunc (c *LauncherAdminClient) StartHeartbeatLoop(\n    ctx context.Context,\n    manager *procmgr.ProcessManager,\n) {\n    ticker := time.NewTicker(30 * time.Second)\n    defer ticker.Stop()\n\n    for {\n        select {\n        case <-ctx.Done():\n            return\n        case <-ticker.C:\n            c.sendHeartbeat(ctx, manager)\n        }\n    }\n}\n\nfunc (c *LauncherAdminClient) sendHeartbeat(\n    ctx context.Context,\n    manager *procmgr.ProcessManager,\n) error {\n    patternHealth := c.collectPatternHealth(manager)\n    resources := c.collectResourceUsage(manager)\n\n    req := &pb.LauncherHeartbeat{\n        LauncherId:    c.launcherID,\n        PatternHealth: patternHealth,\n        Resources:     resources,\n        Timestamp:     time.Now().Unix(),\n    }\n\n    _, err := c.client.LauncherHeartbeat(ctx, req)\n    if err != nil {\n        log.Warn().Err(err).Msg("Heartbeat failed")\n    }\n    return err\n}\n\nfunc (c *LauncherAdminClient) collectPatternHealth(\n    manager *procmgr.ProcessManager,\n) map[string]*pb.PatternHealth {\n    patterns := manager.ListProcesses()\n    health := make(map[string]*pb.PatternHealth)\n\n    for _, p := range patterns {\n        health[p.ID] = &pb.PatternHealth{\n            Status:        string(p.State),\n            Pid:           int32(p.PID),\n            RestartCount:  int32(p.RestartCount),\n            ErrorCount:    int32(p.ErrorCount),\n            MemoryMb:      p.MemoryMB,\n            UptimeSeconds: int64(time.Since(p.StartTime).Seconds()),\n            LastError:     p.LastError,\n        }\n    }\n\n    return health\n}\n\nfunc (c *LauncherAdminClient) collectResourceUsage(\n    manager *procmgr.ProcessManager,\n) *pb.LauncherResourceUsage {\n    patterns := manager.ListProcesses()\n    var totalMemory int64\n    for _, p := range patterns {\n        totalMemory += p.MemoryMB\n    }\n\n    return &pb.LauncherResourceUsage{\n        PatternCount:  int32(len(patterns)),\n        MaxPatterns:   c.maxPatterns,\n        TotalMemoryMb: totalMemory,\n        CpuPercent:    getCPUUsage(), // Platform-specific\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"admin-side-launcher-control",children:"Admin-Side Launcher Control"}),"\n",(0,a.jsxs)(e.p,{children:["Go implementation in ",(0,a.jsx)(e.code,{children:"cmd/prism-admin/launcher_control.go"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-go",children:'func (s *ControlPlaneService) RegisterLauncher(\n    ctx context.Context,\n    req *pb.LauncherRegistration,\n) (*pb.LauncherRegistrationAck, error) {\n    // Record launcher in storage\n    launcher := &Launcher{\n        LauncherID:  req.LauncherId,\n        Address:     req.Address,\n        Version:     req.Version,\n        Status:      "healthy",\n        MaxPatterns: req.MaxPatterns,\n        LastSeen:    time.Now(),\n        Metadata:    req.Metadata,\n    }\n\n    if err := s.storage.UpsertLauncher(ctx, launcher); err != nil {\n        return nil, err\n    }\n\n    // Get patterns assigned to this launcher\n    patterns, err := s.storage.ListPatternsByLauncher(ctx, req.LauncherId)\n    if err != nil {\n        return nil, err\n    }\n\n    // Convert to PatternAssignment messages\n    assignments := make([]*pb.PatternAssignment, len(patterns))\n    for i, p := range patterns {\n        assignments[i] = &pb.PatternAssignment{\n            PatternId:      p.PatternID,\n            PatternType:    p.PatternType,\n            Namespace:      p.Namespace,\n            IsolationLevel: p.IsolationLevel,\n            Config:         p.Config,\n            Backends:       p.Backends,\n            Version:        p.Version,\n        }\n    }\n\n    return &pb.LauncherRegistrationAck{\n        Success:          true,\n        Message:          "Launcher registered successfully",\n        InitialPatterns:  assignments,\n        AssignedCapacity: int32(len(patterns)),\n    }, nil\n}\n\nfunc (s *ControlPlaneService) AssignPattern(\n    ctx context.Context,\n    req *pb.PatternAssignment,\n) (*pb.PatternAssignmentAck, error) {\n    // Persist pattern assignment\n    pattern := &Pattern{\n        PatternID:      req.PatternId,\n        PatternType:    req.PatternType,\n        Namespace:      req.Namespace,\n        IsolationLevel: req.IsolationLevel,\n        Config:         req.Config,\n        Backends:       req.Backends,\n        Status:         "provisioning",\n    }\n\n    if err := s.storage.CreatePattern(ctx, pattern); err != nil {\n        return nil, err\n    }\n\n    return &pb.PatternAssignmentAck{\n        Success: true,\n        Message: "Pattern assigned successfully",\n    }, nil\n}\n\nfunc (s *ControlPlaneService) LauncherHeartbeat(\n    ctx context.Context,\n    req *pb.LauncherHeartbeat,\n) (*pb.HeartbeatAck, error) {\n    // Update launcher last_seen timestamp\n    if err := s.storage.TouchLauncher(ctx, req.LauncherId); err != nil {\n        log.Error().Err(err).Msg("Failed to update launcher timestamp")\n    }\n\n    // Update pattern health in storage\n    for patternID, health := range req.PatternHealth {\n        if err := s.storage.UpdatePatternHealth(ctx, patternID, health); err != nil {\n            log.Error().Err(err).Str("pattern_id", patternID).Msg("Failed to update pattern health")\n        }\n    }\n\n    return &pb.HeartbeatAck{\n        Success: true,\n    }, nil\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"storage-schema-extensions",children:"Storage Schema Extensions"}),"\n",(0,a.jsx)(e.p,{children:"Add launchers table to ADR-054 schema:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-sql",children:"-- Launchers table\nCREATE TABLE IF NOT EXISTS launchers (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    launcher_id TEXT NOT NULL UNIQUE,\n    address TEXT NOT NULL,\n    version TEXT,\n    status TEXT CHECK(status IN ('healthy', 'unhealthy', 'unknown')) NOT NULL DEFAULT 'unknown',\n    max_patterns INTEGER NOT NULL DEFAULT 10,\n    last_seen TIMESTAMP,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    metadata TEXT -- JSON\n);\n\n-- Add launcher_id foreign key to patterns table\nALTER TABLE patterns ADD COLUMN launcher_id TEXT;\nALTER TABLE patterns ADD FOREIGN KEY (launcher_id) REFERENCES launchers(launcher_id) ON DELETE SET NULL;\n\n-- Indexes\nCREATE INDEX idx_launchers_status ON launchers(status, last_seen);\nCREATE INDEX idx_patterns_launcher ON patterns(launcher_id);\n"})}),"\n",(0,a.jsx)(e.h3,{id:"launcher-configuration",children:"Launcher Configuration"}),"\n",(0,a.jsx)(e.p,{children:"Add admin endpoint to launcher config:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-yaml",children:'admin:\n  endpoint: "admin.prism.local:8981"\n  launcher_id: "launcher-01"\n  region: "us-west-2"\n  max_patterns: 20\n  heartbeat_interval: "30s"\n  reconnect_backoff: "5s"\n\nlauncher:\n  listen: ":7070"\n  patterns_dir: "./patterns"\n  log_level: "info"\n'})}),"\n",(0,a.jsx)(e.h3,{id:"graceful-fallback",children:"Graceful Fallback"}),"\n",(0,a.jsx)(e.p,{children:"If admin unavailable, launcher operates with local patterns directory:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-go",children:'func Start(cfg *Config) error {\n    // Try connecting to admin\n    adminClient, err := NewLauncherAdminClient(\n        cfg.Admin.Endpoint,\n        cfg.Admin.LauncherID,\n        cfg.Launcher.Listen,\n        cfg.Admin.Region,\n        cfg.Admin.MaxPatterns,\n    )\n    if err != nil {\n        log.Warn().Err(err).Msg("Admin connection failed, using local patterns directory")\n        return startWithLocalPatterns(cfg)\n    }\n\n    // Register with admin\n    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n    defer cancel()\n\n    ack, err := adminClient.Register(ctx)\n    if err != nil {\n        log.Warn().Err(err).Msg("Registration failed, using local patterns directory")\n        return startWithLocalPatterns(cfg)\n    }\n\n    log.Info().\n        Int("initial_patterns", len(ack.InitialPatterns)).\n        Msg("Registered with admin")\n\n    // Apply admin-provided patterns\n    for _, assignment := range ack.InitialPatterns {\n        if err := provisionPattern(assignment); err != nil {\n            log.Error().Err(err).Str("pattern_id", assignment.PatternId).Msg("Failed to provision pattern")\n        }\n    }\n\n    // Start heartbeat loop\n    go adminClient.StartHeartbeatLoop(context.Background(), processManager)\n\n    // Start launcher gRPC server\n    return startGRPCServer(cfg)\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"prismctl-local-integration",children:"prismctl Local Integration"}),"\n",(0,a.jsxs)(e.p,{children:["Update ",(0,a.jsx)(e.code,{children:"cmd/prismctl/cmd/local.go"})," to use admin-connected launcher:"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-go",children:'{\n    name:    "pattern-launcher",\n    binary:  filepath.Join(binDir, "pattern-launcher"),\n    args:    []string{\n        "--admin-endpoint=localhost:8980",  // Control plane port\n        "--launcher-id=launcher-01",\n        "--listen=:7070",\n        "--max-patterns=10",\n    },\n    logFile: filepath.Join(logsDir, "launcher.log"),\n    delay:   2 * time.Second,\n},\n'})}),"\n",(0,a.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"/adr/adr-055",children:"ADR-055: Proxy-Admin Control Plane Protocol"})," - Proxy registration and namespace distribution"]}),"\n",(0,a.jsx)(e.li,{children:"ADR-054: SQLite Storage for prism-admin (planned) - Storage for launcher registry"}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"/rfc/rfc-035",children:"RFC-035: Pattern Process Launcher"})," - Pattern lifecycle management"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"/memos/memo-034",children:"MEMO-034: Pattern Process Launcher Quick Start"})," - Launcher usage guide"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"2025-10-15: Initial draft - Launcher-admin control plane with pattern assignment"}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}}}]);