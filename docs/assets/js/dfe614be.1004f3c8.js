"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[80776],{28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>l});var r=s(96540);const i={},t=r.createContext(i);function a(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(t.Provider,{value:n},e.children)}},68703:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"rfc-031","title":"RFC-031: Message Envelope Protocol for Pub/Sub Systems","description":"Abstract","source":"@site/../docs-cms/rfcs/RFC-031-message-envelope-protocol.md","sourceDirName":".","slug":"/rfc-031","permalink":"/prism-data-layer/rfc/rfc-031","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/rfcs/RFC-031-message-envelope-protocol.md","tags":[{"inline":true,"label":"architecture","permalink":"/prism-data-layer/rfc/tags/architecture"},{"inline":true,"label":"pubsub","permalink":"/prism-data-layer/rfc/tags/pubsub"},{"inline":true,"label":"protocol","permalink":"/prism-data-layer/rfc/tags/protocol"},{"inline":true,"label":"interoperability","permalink":"/prism-data-layer/rfc/tags/interoperability"},{"inline":true,"label":"security","permalink":"/prism-data-layer/rfc/tags/security"},{"inline":true,"label":"schema","permalink":"/prism-data-layer/rfc/tags/schema"},{"inline":true,"label":"future-proof","permalink":"/prism-data-layer/rfc/tags/future-proof"}],"version":"current","frontMatter":{"title":"RFC-031: Message Envelope Protocol for Pub/Sub Systems","author":"Platform Team","created":"2025-10-13T00:00:00.000Z","updated":"2025-10-13T00:00:00.000Z","status":"Draft","tags":["architecture","pubsub","protocol","interoperability","security","schema","future-proof"],"id":"rfc-031","project_id":"prism-data-layer","doc_uuid":"8a7c9f3e-2b15-4d8a-9f6e-4c1a8b9e7d2f"},"sidebar":"rfcSidebar","previous":{"title":"Schema Evolution and Validation for Decoupled Pub/Sub \u2022 RFC-030","permalink":"/prism-data-layer/rfc/rfc-030"},"next":{"title":"Minimal Prism Schema Registry for Local Testing \u2022 RFC-032","permalink":"/prism-data-layer/rfc/rfc-032"}}');var i=s(74848),t=s(28453);const a={title:"RFC-031: Message Envelope Protocol for Pub/Sub Systems",author:"Platform Team",created:new Date("2025-10-13T00:00:00.000Z"),updated:new Date("2025-10-13T00:00:00.000Z"),status:"Draft",tags:["architecture","pubsub","protocol","interoperability","security","schema","future-proof"],id:"rfc-031",project_id:"prism-data-layer",doc_uuid:"8a7c9f3e-2b15-4d8a-9f6e-4c1a8b9e7d2f"},l=void 0,o={},c=[{value:"Abstract",id:"abstract",level:2},{value:"Motivation",id:"motivation",level:2},{value:"The Problem: Inconsistent Message Envelopes",id:"the-problem-inconsistent-message-envelopes",level:3},{value:"Real-World Example: Cross-Backend Migration",id:"real-world-example-cross-backend-migration",level:3},{value:"Goals",id:"goals",level:2},{value:"Non-Goals",id:"non-goals",level:2},{value:"Proposed Solution: Prism Message Envelope v1",id:"proposed-solution-prism-message-envelope-v1",level:2},{value:"Core Design: Protobuf Envelope",id:"core-design-protobuf-envelope",level:3},{value:"Key Design Decisions",id:"key-design-decisions",level:3},{value:"Backend-Specific Serialization",id:"backend-specific-serialization",level:3},{value:"Developer APIs: Ergonomic Wrappers",id:"developer-apis-ergonomic-wrappers",level:3},{value:"Backward Compatibility Strategy",id:"backward-compatibility-strategy",level:3},{value:"Security Considerations",id:"security-considerations",level:3},{value:"Observability Integration",id:"observability-integration",level:3},{value:"Schema Context Integration (RFC-030)",id:"schema-context-integration-rfc-030",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:3},{value:"Migration Path from Current Systems",id:"migration-path-from-current-systems",level:3},{value:"Implementation Plan",id:"implementation-plan",level:2},{value:"Phase 1: Protobuf Definition (Week 1)",id:"phase-1-protobuf-definition-week-1",level:3},{value:"Phase 2: SDK Integration (Weeks 2-3)",id:"phase-2-sdk-integration-weeks-2-3",level:3},{value:"Phase 3: Backend Plugin Support (Weeks 4-5)",id:"phase-3-backend-plugin-support-weeks-4-5",level:3},{value:"Phase 4: Observability Integration (Week 6)",id:"phase-4-observability-integration-week-6",level:3},{value:"Phase 5: Migration Tools (Week 7)",id:"phase-5-migration-tools-week-7",level:3},{value:"Trade-Offs and Alternatives",id:"trade-offs-and-alternatives",level:2},{value:"Alternative 1: JSON Envelope",id:"alternative-1-json-envelope",level:3},{value:"Alternative 2: No Envelope (Backend-Specific Headers)",id:"alternative-2-no-envelope-backend-specific-headers",level:3},{value:"Alternative 3: CloudEvents Standard",id:"alternative-3-cloudevents-standard",level:3},{value:"Success Criteria",id:"success-criteria",level:2},{value:"Open Questions",id:"open-questions",level:2},{value:"References",id:"references",level:2},{value:"Revision History",id:"revision-history",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"abstract",children:"Abstract"}),"\n",(0,i.jsxs)(n.p,{children:["This RFC defines a ",(0,i.jsx)(n.strong,{children:"unified message envelope protocol"})," for Prism's pub/sub systems that is:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consistent"}),": Same envelope structure across all backends (Kafka, NATS, Redis, PostgreSQL, SQS)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Flexible"}),": Extensible for future features without breaking existing consumers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Secure"}),": Built-in support for authentication, encryption, and audit metadata"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Developer-Friendly"}),": Ergonomic APIs for common operations, minimal boilerplate"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Future-Proof"}),": Designed for 10+ year evolution with backward compatibility"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The envelope wraps user payloads with metadata (routing, schema, auth, observability) while remaining ",(0,i.jsx)(n.strong,{children:"backend-agnostic"})," to support any message transport."]}),"\n",(0,i.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,i.jsx)(n.h3,{id:"the-problem-inconsistent-message-envelopes",children:"The Problem: Inconsistent Message Envelopes"}),"\n",(0,i.jsx)(n.p,{children:"Current pub/sub implementations across different backends use inconsistent metadata formats:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Kafka"})," (message headers):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"schema-id: 123\ncorrelation-id: abc-456\ntimestamp: 1697200000\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"NATS"})," (custom headers):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"Nats-Msg-Id: xyz-789\nX-Schema-URL: github.com/...\nX-Trace-ID: trace-123\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Redis"})," (no native headers, metadata in payload prefix):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:'{"meta":{"schema":"v2","ts":1697200000},"payload":<user data>}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"PostgreSQL"})," (JSON columns):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"INSERT INTO events (topic, payload, metadata) VALUES ('orders', '{...}', '{\"schema_version\":\"v2\"}');\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Problems This Creates:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Client Complexity"}),": Developers must handle each backend differently"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Migration Pain"}),": Moving from Redis \u2192 Kafka requires rewriting envelope logic"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Missing Features"}),": Some backends lack auth metadata, schema info, or trace context"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"No Versioning"}),": Can't evolve envelope without breaking consumers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Security Gaps"}),": No standard place for encryption keys, PII flags, or auth tokens"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"real-world-example-cross-backend-migration",children:"Real-World Example: Cross-Backend Migration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Producer wants to migrate from Redis to Kafka\n# Current code (Redis):\nredis_client.publish("orders.created", json.dumps({\n    "meta": {"schema": "v2", "trace_id": trace_id},\n    "payload": order_dict\n}))\n\n# New code (Kafka) - COMPLETELY DIFFERENT API:\nkafka_producer.send("orders.created", value=order_dict, headers=[\n    ("schema-version", b"v2"),\n    ("trace-id", trace_id.encode())\n])\n\n# Consumer code ALSO breaks:\n# Redis consumer expects: json.loads(msg)["payload"]\n# Kafka consumer expects: deserialize(msg.value)\n# NATS consumer expects: msg.data\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"This is unacceptable for sustainable development."})}),"\n",(0,i.jsx)(n.h2,{id:"goals",children:"Goals"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Single Envelope Format"}),": One protobuf-based envelope for all backends"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Backend Abstraction"}),": Prism SDK hides backend-specific serialization"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Backward Compatibility"}),": Envelope v1 consumers work with v2 envelopes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Forward Compatibility"}),": v2 consumers ignore unknown v3 fields"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Security by Default"}),": Auth tokens, encryption metadata built-in"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Observability"}),": Trace IDs, timestamps, causality chains standard"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Schema Integration"}),": Tight integration with RFC-030 schema registry"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance"}),": Minimal overhead (<1% latency increase)"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"non-goals",children:"Non-Goals"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Payload Encryption"}),": Envelope defines metadata; encryption is separate RFC"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compression"}),": Backend-specific optimization (e.g., Kafka compression)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Ordered Delivery"}),": Envelope doesn't enforce ordering (backend responsibility)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Replay Protection"}),": Deduplication is application-level concern"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Routing Logic"}),": Envelope carries routing metadata; proxy implements routing"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"proposed-solution-prism-message-envelope-v1",children:"Proposed Solution: Prism Message Envelope v1"}),"\n",(0,i.jsx)(n.h3,{id:"core-design-protobuf-envelope",children:"Core Design: Protobuf Envelope"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:'syntax = "proto3";\n\npackage prism.envelope.v1;\n\nimport "google/protobuf/any.proto";\nimport "google/protobuf/timestamp.proto";\n\n// PrismEnvelope wraps all pub/sub messages\nmessage PrismEnvelope {\n  // Envelope version for evolution (REQUIRED)\n  int32 envelope_version = 1;  // Currently: 1\n\n  // Message metadata (REQUIRED)\n  PrismMetadata metadata = 2;\n\n  // User payload (REQUIRED)\n  // Can be protobuf (Any), JSON (bytes), or custom format\n  google.protobuf.Any payload = 3;\n\n  // Security context (OPTIONAL but recommended)\n  SecurityContext security = 4;\n\n  // Observability context (OPTIONAL but recommended)\n  ObservabilityContext observability = 5;\n\n  // Schema metadata (OPTIONAL, required if RFC-030 schema validation enabled)\n  SchemaContext schema = 6;\n\n  // Extension fields for future evolution (OPTIONAL)\n  map<string, bytes> extensions = 99;\n}\n\n// Core message metadata\nmessage PrismMetadata {\n  // Unique message ID (UUID v7 recommended for time-ordering)\n  string message_id = 1;\n\n  // Topic name (e.g., "orders.created")\n  string topic = 2;\n\n  // Namespace (multi-tenancy isolation)\n  string namespace = 3;\n\n  // Publish timestamp (producer clock)\n  google.protobuf.Timestamp published_at = 4;\n\n  // Content type (e.g., "application/protobuf", "application/json")\n  string content_type = 5;\n\n  // Content encoding (e.g., "gzip", "snappy", "none")\n  string content_encoding = 6;\n\n  // Message priority (0=lowest, 10=highest, default=5)\n  int32 priority = 7;\n\n  // TTL in seconds (0 = no expiration)\n  int64 ttl_seconds = 8;\n\n  // Correlation ID for request/response patterns\n  string correlation_id = 9;\n\n  // Causality: parent message ID (for event chains)\n  string causality_parent = 10;\n}\n\n// Security context\nmessage SecurityContext {\n  // Publisher identity (from OIDC token or mTLS cert)\n  string publisher_id = 1;\n\n  // Publisher team/organization\n  string publisher_team = 2;\n\n  // Authorization token (for consumer validation)\n  // NOTE: Redacted in logs/audit trails\n  string auth_token = 3;\n\n  // Signature for message authenticity (HMAC-SHA256 or Ed25519)\n  bytes signature = 4;\n\n  // Signature algorithm ("hmac-sha256", "ed25519")\n  string signature_algorithm = 5;\n\n  // Encryption metadata (key ID, algorithm, IV)\n  EncryptionMetadata encryption = 6;\n\n  // PII sensitivity flag (from schema governance)\n  bool contains_pii = 7;\n\n  // Data classification ("public", "internal", "confidential", "restricted")\n  string data_classification = 8;\n}\n\n// Encryption metadata (payload encryption details)\nmessage EncryptionMetadata {\n  // Key ID (reference to key in Vault/KMS)\n  string key_id = 1;\n\n  // Algorithm ("aes-256-gcm", "chacha20-poly1305")\n  string algorithm = 2;\n\n  // Initialization vector (base64-encoded)\n  bytes iv = 3;\n\n  // Additional authenticated data (base64-encoded)\n  bytes aad = 4;\n}\n\n// Observability context (distributed tracing + metrics)\nmessage ObservabilityContext {\n  // Trace ID (W3C Trace Context format)\n  string trace_id = 1;\n\n  // Span ID (W3C Trace Context format)\n  string span_id = 2;\n\n  // Parent span ID (for nested traces)\n  string parent_span_id = 3;\n\n  // Trace flags (W3C Trace Context sampled bit, etc.)\n  int32 trace_flags = 4;\n\n  // Baggage (key-value pairs for cross-service context)\n  map<string, string> baggage = 5;\n\n  // Metrics labels (for aggregation in Prometheus/Signoz)\n  map<string, string> labels = 6;\n}\n\n// Schema context (tight integration with RFC-030)\nmessage SchemaContext {\n  // Schema URL (GitHub, Prism Registry, or HTTPS endpoint)\n  string schema_url = 1;\n\n  // Schema version (e.g., "v2", "1.0.0")\n  string schema_version = 2;\n\n  // Schema format ("protobuf", "json-schema", "avro")\n  string schema_format = 3;\n\n  // Schema hash (SHA-256 for immutability check)\n  string schema_hash = 4;\n\n  // Schema name (protobuf message name, e.g., "OrderCreated")\n  string schema_name = 5;\n\n  // Compatibility mode ("backward", "forward", "full", "none")\n  string compatibility_mode = 6;\n\n  // Deprecated fields accessed (for migration tracking)\n  repeated string deprecated_fields_used = 7;\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"key-design-decisions",children:"Key Design Decisions"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Protobuf for Envelope (Not JSON)"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Why Protobuf:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Binary Efficiency"}),": 3-10x smaller than JSON for metadata"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Type Safety"}),": Compile-time validation of envelope structure"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Evolution"}),": Add fields without breaking consumers (field numbers)"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Language Support"}),": Generated clients for Go, Python, Rust, JavaScript"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Payload Flexibility:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Payload can be ",(0,i.jsx)(n.strong,{children:"any format"})," (protobuf, JSON, Avro, custom)"]}),"\n",(0,i.jsx)(n.li,{children:"Envelope metadata is always protobuf (consistent)"}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"google.protobuf.Any"})," allows any protobuf message"]}),"\n",(0,i.jsxs)(n.li,{children:["For JSON payloads, use ",(0,i.jsx)(n.code,{children:'content_type: "application/json"'})," and store bytes"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Envelope Version Field"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:"int32 envelope_version = 1;  // REQUIRED, always first field\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Evolution Strategy:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Version"}),(0,i.jsx)(n.th,{children:"Changes"}),(0,i.jsx)(n.th,{children:"Backward Compatible?"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"v1"}),(0,i.jsx)(n.td,{children:"Initial design (this RFC)"}),(0,i.jsx)(n.td,{children:"N/A (baseline)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"v2"}),(0,i.jsxs)(n.td,{children:["Add ",(0,i.jsx)(n.code,{children:"routing_hints"})," field"]}),(0,i.jsx)(n.td,{children:"\u2705 Yes (v1 consumers ignore it)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"v3"}),(0,i.jsxs)(n.td,{children:["Change ",(0,i.jsx)(n.code,{children:"trace_id"})," to structured type"]}),(0,i.jsx)(n.td,{children:"\u26a0\ufe0f Depends (need migration period)"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Consumer Handling:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// Consumer checks envelope version\nenvelope := &prism.PrismEnvelope{}\nproto.Unmarshal(bytes, envelope)\n\nif envelope.EnvelopeVersion > 1 {\n    log.Warn("Received envelope v%d (consumer supports v1), attempting best-effort parse", envelope.EnvelopeVersion)\n    // v1 consumer ignores unknown fields, continues processing\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"3. Extension Map for Future-Proofing"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:"map<string, bytes> extensions = 99;  // Field 99 reserved for extensions\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// Future: Add custom metadata without envelope version bump\nenvelope.Extensions["x-retry-count"] = []byte("3")\nenvelope.Extensions["x-dlq-source"] = []byte("orders.failed")\nenvelope.Extensions["x-custom-routing"] = []byte(`{"region":"us-west-2"}`)\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Guidelines:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Extensions prefixed with ",(0,i.jsx)(n.code,{children:"x-"})," are non-standard (experimental)"]}),"\n",(0,i.jsxs)(n.li,{children:["Extensions without ",(0,i.jsx)(n.code,{children:"x-"})," are standardized (future RFC)"]}),"\n",(0,i.jsx)(n.li,{children:"Consumers MUST ignore unknown extensions"}),"\n",(0,i.jsxs)(n.li,{children:["Extensions are opaque ",(0,i.jsx)(n.code,{children:"bytes"})," (serialize as JSON/protobuf as needed)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"backend-specific-serialization",children:"Backend-Specific Serialization"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Prism SDK hides backend differences:"})}),"\n",(0,i.jsx)(n.mermaid,{value:'sequenceDiagram\n    participant App as Application\n    participant SDK as Prism SDK\n    participant Proxy as Prism Proxy\n    participant Plugin as Backend Plugin\n    participant Backend as Backend (Kafka/NATS/Redis)\n\n    Note over App,Backend: Producer publishes message\n\n    App->>SDK: publish(topic="orders", payload=OrderCreated{})\n    SDK->>SDK: Wrap payload in PrismEnvelope\n    SDK->>SDK: Add metadata, security, schema context\n\n    SDK->>Proxy: PublishRequest(envelope=PrismEnvelope)\n    Proxy->>Plugin: Publish(topic, envelope_bytes)\n\n    Note over Plugin: Backend-specific serialization\n\n    Plugin->>Backend: Backend-native format'}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Kafka: Envelope as Message Value + Headers"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:'Kafka Message {\n  Key: <partition key>\n  Value: <PrismEnvelope protobuf bytes>\n  Headers: {\n    "prism-envelope-version": "1"\n    "prism-message-id": "<uuid>"\n    "prism-topic": "orders.created"\n    "prism-trace-id": "<trace-id>"\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Why Duplicate Metadata in Headers:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Kafka tools (console consumer, Connect, etc.) can read headers without deserializing"}),"\n",(0,i.jsx)(n.li,{children:"Filtering/routing at broker level (Kafka Streams, KSQLdb)"}),"\n",(0,i.jsx)(n.li,{children:"Backward compat with non-Prism consumers (can read headers)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"NATS: Envelope as Message Data + NATS Headers"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:'NATS Message {\n  Subject: "orders.created"\n  Data: <PrismEnvelope protobuf bytes>\n  Headers: {\n    "Prism-Envelope-Version": "1"\n    "Prism-Message-ID": "<uuid>"\n    "Prism-Trace-ID": "<trace-id>"\n    "Nats-Msg-Id": "<uuid>"  // NATS deduplication\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Redis: Envelope as Pub/Sub Message"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"PUBLISH orders.created <PrismEnvelope protobuf bytes>\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"No headers in Redis Pub/Sub, so envelope is self-contained."})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"PostgreSQL: Envelope as JSONB Column"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE prism_events (\n  id BIGSERIAL PRIMARY KEY,\n  topic TEXT NOT NULL,\n  envelope JSONB NOT NULL,  -- PrismEnvelope as JSON\n  published_at TIMESTAMPTZ DEFAULT NOW(),\n  consumed BOOLEAN DEFAULT FALSE\n);\n\n-- Index for efficient topic queries\nCREATE INDEX idx_events_topic_consumed ON prism_events(topic, consumed);\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Why JSON for PostgreSQL:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"PostgreSQL JSONB has rich querying (GIN indexes)"}),"\n",(0,i.jsx)(n.li,{children:"Easier debugging (human-readable)"}),"\n",(0,i.jsx)(n.li,{children:"Still type-safe via protobuf \u2192 JSON conversion"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"S3/Object Storage: Envelope as Blob Metadata"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:'S3 Object {\n  Key: "events/2025/10/13/orders.created/<uuid>.bin"\n  Body: <PrismEnvelope protobuf bytes>\n  Metadata: {\n    "x-amz-meta-prism-envelope-version": "1"\n    "x-amz-meta-prism-message-id": "<uuid>"\n    "x-amz-meta-prism-topic": "orders.created"\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"developer-apis-ergonomic-wrappers",children:"Developer APIs: Ergonomic Wrappers"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Python Producer (High-Level API):"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from prism_sdk import PrismClient, PrismPublishOptions\n\nclient = PrismClient(namespace="order-events")\n\n# Simple publish (envelope auto-generated)\nclient.publish(\n    topic="orders.created",\n    payload=order,  # Can be protobuf or dict\n)\n\n# Advanced publish (custom metadata)\nclient.publish(\n    topic="orders.created",\n    payload=order,\n    options=PrismPublishOptions(\n        correlation_id="req-12345",\n        priority=8,\n        ttl_seconds=3600,\n        labels={"region": "us-west", "tier": "premium"},\n    )\n)\n\n# Batch publish (single envelope for multiple messages)\nclient.publish_batch([\n    (topic="orders.created", payload=order1),\n    (topic="orders.created", payload=order2),\n    (topic="orders.updated", payload=order3),\n])\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Go Consumer (Type-Safe API):"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'import "prism.io/sdk/go"\n\nclient := prism.NewClient("order-events")\n\n// Subscribe with typed messages\nstream := client.SubscribeTyped[OrderCreated]("orders.created")\n\nfor envelope := range stream {\n    // Envelope provides metadata access\n    log.Info("Received message",\n        "message_id", envelope.Metadata().MessageID,\n        "published_at", envelope.Metadata().PublishedAt,\n        "trace_id", envelope.Observability().TraceID,\n    )\n\n    // Payload is strongly typed\n    order := envelope.Payload()  // *OrderCreated\n    fmt.Printf("Order: %s, Total: %.2f\\n", order.OrderId, order.Total)\n\n    // Check for deprecated fields\n    if len(envelope.Schema().DeprecatedFieldsUsed) > 0 {\n        log.Warn("Message uses deprecated fields", "fields", envelope.Schema().DeprecatedFieldsUsed)\n    }\n\n    // Acknowledge message\n    envelope.Ack()\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Rust Consumer (Zero-Copy Deserialization):"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use prism_sdk::{PrismClient, PrismEnvelope};\n\nlet client = PrismClient::new("order-events");\nlet mut stream = client.subscribe("orders.created").await?;\n\nwhile let Some(envelope) = stream.next().await {\n    // Access metadata without copying\n    let metadata = envelope.metadata();\n    println!("Message ID: {}", metadata.message_id());\n    println!("Trace ID: {}", envelope.observability().trace_id());\n\n    // Deserialize payload (lazy, on-demand)\n    let order: OrderCreated = envelope.payload().parse()?;\n    println!("Order: {}, Total: {}", order.order_id, order.total);\n\n    // Security context\n    if envelope.security().contains_pii() {\n        // Handle PII appropriately\n        mask_pii_fields(&order);\n    }\n\n    envelope.ack().await?;\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"backward-compatibility-strategy",children:"Backward Compatibility Strategy"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"v1 Consumers Reading v2 Envelopes:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:"// v1 envelope (baseline)\nmessage PrismEnvelope {\n  int32 envelope_version = 1;\n  PrismMetadata metadata = 2;\n  google.protobuf.Any payload = 3;\n}\n\n// v2 envelope (adds routing hints)\nmessage PrismEnvelope {\n  int32 envelope_version = 1;\n  PrismMetadata metadata = 2;\n  google.protobuf.Any payload = 3;\n  RoutingHints routing = 7;  // NEW field\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Protobuf Behavior:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["v1 consumer ",(0,i.jsx)(n.strong,{children:"ignores field 7"})," (unknown field, no error)"]}),"\n",(0,i.jsx)(n.li,{children:"v1 consumer continues processing normally"}),"\n",(0,i.jsx)(n.li,{children:"No coordination needed between producer/consumer upgrades"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"v2 Consumers Reading v1 Envelopes:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// v2 consumer checks for routing hints\nenvelope := &prism.PrismEnvelope{}\nproto.Unmarshal(bytes, envelope)\n\nif envelope.Routing != nil {\n    // Use routing hints (v2 envelope)\n    region := envelope.Routing.PreferredRegion\n} else {\n    // No routing hints (v1 envelope), use default\n    region := "us-west-2"\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Breaking Change Procedure (Last Resort):"})}),"\n",(0,i.jsx)(n.p,{children:"If v3 envelope needs a breaking change:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# 1. Dual-publish period (6 months)\n#    Producer sends BOTH v2 and v3 envelopes (separate topics)\nproducer.publish("orders.created.v2", envelope_v2)  # Existing consumers\nproducer.publish("orders.created.v3", envelope_v3)  # New consumers\n\n# 2. Consumer migration window (3 months)\n#    Consumers migrate from v2 \u2192 v3 topic at their own pace\n\n# 3. Deprecation notice (3 months before cutoff)\n#    Prism logs warnings for v2 consumers\n\n# 4. Cutoff date (12 months after v3 release)\n#    Stop publishing to v2 topic\n'})}),"\n",(0,i.jsx)(n.h3,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Auth Token Handling"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:"message SecurityContext {\n  string auth_token = 3;  // JWT or opaque token\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Rules:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Auth tokens are ",(0,i.jsx)(n.strong,{children:"redacted in logs"})," (never logged in plaintext)"]}),"\n",(0,i.jsxs)(n.li,{children:["Auth tokens are ",(0,i.jsx)(n.strong,{children:"validated by Prism proxy"})," (not forwarded to backend)"]}),"\n",(0,i.jsxs)(n.li,{children:["Consumers ",(0,i.jsx)(n.strong,{children:"do not see auth tokens"})," (proxy strips before delivery)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Message Signing"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// Producer signs message\nenvelope := createEnvelope(payload)\nsignature := hmacSHA256(envelope, secretKey)\nenvelope.Security.Signature = signature\nenvelope.Security.SignatureAlgorithm = "hmac-sha256"\n\n// Consumer verifies signature\ncomputedSignature := hmacSHA256(envelope, secretKey)\nif !bytes.Equal(computedSignature, envelope.Security.Signature) {\n    return errors.New("signature verification failed")\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Prevent message tampering in untrusted backends"}),"\n",(0,i.jsx)(n.li,{children:"Non-repudiation (prove publisher identity)"}),"\n",(0,i.jsx)(n.li,{children:"Regulatory compliance (HIPAA, SOX)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"3. PII Awareness"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:"message SecurityContext {\n  bool contains_pii = 7;  // Set by schema governance\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Automatic Population:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Prism proxy sets ",(0,i.jsx)(n.code,{children:"contains_pii=true"})," if schema (RFC-030) has PII fields"]}),"\n",(0,i.jsx)(n.li,{children:"Consumers check flag before logging/storing"}),"\n",(0,i.jsx)(n.li,{children:"Audit logs track PII access"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"4. Data Classification"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:'message SecurityContext {\n  string data_classification = 8;  // "public", "internal", "confidential", "restricted"\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Enforcement:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"High-classification messages require encryption"}),"\n",(0,i.jsx)(n.li,{children:"Consumers validate their compliance level matches message classification"}),"\n",(0,i.jsx)(n.li,{children:"Audit logs track access to restricted data"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"observability-integration",children:"Observability Integration"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"W3C Trace Context Support:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:"message ObservabilityContext {\n  string trace_id = 1;      // 32-hex-char trace ID\n  string span_id = 2;       // 16-hex-char span ID\n  string parent_span_id = 3; // Parent span for nested traces\n  int32 trace_flags = 4;    // Sampled bit, etc.\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Automatic Trace Propagation:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Producer (trace context from HTTP request)\nwith tracer.start_span("publish_order") as span:\n    client.publish(\n        topic="orders.created",\n        payload=order,\n        trace_context=span.context  # SDK auto-populates observability fields\n    )\n\n# Consumer (trace context continues)\nfor envelope in client.subscribe("orders.created"):\n    with tracer.start_span("process_order", parent_context=envelope.trace_context()) as span:\n        process_order(envelope.payload())\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Metrics Labels:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:"message ObservabilityContext {\n  map<string, string> labels = 6;  // Prometheus/Signoz labels\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Track message volume by customer tier: ",(0,i.jsx)(n.code,{children:'labels={tier: "premium"}'})]}),"\n",(0,i.jsxs)(n.li,{children:["SLA monitoring by region: ",(0,i.jsx)(n.code,{children:'labels={region: "us-west-2"}'})]}),"\n",(0,i.jsxs)(n.li,{children:["Error rates by version: ",(0,i.jsx)(n.code,{children:'labels={app_version: "v2.1.0"}'})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"schema-context-integration-rfc-030",children:"Schema Context Integration (RFC-030)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Automatic Schema Population:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# Namespace config (RFC-030)\nnamespaces:\n  - name: order-events\n    schema:\n      registry_type: prism\n      url: https://schema-registry.example.com\n      version: v2\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Prism SDK Auto-Populates Schema Fields:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Producer publishes with schema metadata\nclient.publish(\n    topic="orders.created",\n    payload=order  # OrderCreated protobuf\n)\n\n# SDK automatically sets:\n# envelope.schema.schema_url = "prism-registry.example.com/schemas/orders.created/v2"\n# envelope.schema.schema_version = "v2"\n# envelope.schema.schema_format = "protobuf"\n# envelope.schema.schema_hash = "sha256:abc123..."\n# envelope.schema.schema_name = "OrderCreated"\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Consumer Validation:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'envelope := <-stream\n\n// Check schema compatibility\nif envelope.Schema().SchemaVersion != "v2" {\n    log.Warn("Unexpected schema version", "expected", "v2", "actual", envelope.Schema().SchemaVersion)\n}\n\n// Verify schema integrity\nexpectedHash := "sha256:abc123..."\nif envelope.Schema().SchemaHash != expectedHash {\n    return errors.New("schema hash mismatch, possible tampering")\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Deprecation Tracking:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:"message SchemaContext {\n  repeated string deprecated_fields_used = 7;  // Track deprecated field access\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Producer Behavior:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["If message uses deprecated fields, SDK populates ",(0,i.jsx)(n.code,{children:"deprecated_fields_used"})]}),"\n",(0,i.jsx)(n.li,{children:'Enables migration tracking: "Which consumers still use old fields?"'}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Envelope Overhead:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Backend"}),(0,i.jsx)(n.th,{children:"Baseline (no envelope)"}),(0,i.jsx)(n.th,{children:"With Prism Envelope"}),(0,i.jsx)(n.th,{children:"Overhead"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Kafka"})}),(0,i.jsx)(n.td,{children:"500 bytes/msg"}),(0,i.jsx)(n.td,{children:"650 bytes/msg"}),(0,i.jsx)(n.td,{children:"+150 bytes (+30%)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"NATS"})}),(0,i.jsx)(n.td,{children:"100 bytes/msg"}),(0,i.jsx)(n.td,{children:"250 bytes/msg"}),(0,i.jsx)(n.td,{children:"+150 bytes (+150%)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Redis"})}),(0,i.jsx)(n.td,{children:"200 bytes/msg"}),(0,i.jsx)(n.td,{children:"350 bytes/msg"}),(0,i.jsx)(n.td,{children:"+150 bytes (+75%)"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Latency Impact:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"Baseline publish (no envelope): 10ms P99\nWith envelope serialization: 10.5ms P99 (+5%)\n\nRationale: Protobuf serialization is <0.5ms even on mobile CPUs\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Mitigation:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Envelope is small (150-300 bytes typically)"}),"\n",(0,i.jsx)(n.li,{children:"Protobuf is highly optimized (binary format)"}),"\n",(0,i.jsx)(n.li,{children:"For high-throughput, batch multiple messages in single envelope"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"migration-path-from-current-systems",children:"Migration Path from Current Systems"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Phase 1: Dual-Write (Transition Period)"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Producer writes both old format and new envelope\n# Old format (backward compat)\nredis_client.publish("orders", json.dumps({"payload": order_dict}))\n\n# New format (Prism envelope)\nprism_client.publish("orders", payload=order)\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Phase 2: Dual-Read (Consumers Migrate)"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Consumer reads both formats\nmsg = redis_client.get_message()\n\nif is_prism_envelope(msg):\n    envelope = parse_prism_envelope(msg)\n    payload = envelope.payload()\nelse:\n    # Legacy format\n    payload = json.loads(msg)["payload"]\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Phase 3: Prism-Only (Cutover)"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Producer only writes Prism envelope\nprism_client.publish("orders", payload=order)\n\n# Consumer only reads Prism envelope\nenvelope = prism_client.subscribe("orders")\n'})}),"\n",(0,i.jsx)(n.h2,{id:"implementation-plan",children:"Implementation Plan"}),"\n",(0,i.jsx)(n.h3,{id:"phase-1-protobuf-definition-week-1",children:"Phase 1: Protobuf Definition (Week 1)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Deliverables:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 Define ",(0,i.jsx)(n.code,{children:"prism.envelope.v1"})," protobuf package"]}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Generate Go, Python, Rust client code"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Unit tests for envelope serialization/deserialization"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Documentation: Envelope field guide"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Success Criteria:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"All fields documented with examples"}),"\n",(0,i.jsx)(n.li,{children:"Protobuf compiles in all target languages"}),"\n",(0,i.jsx)(n.li,{children:"Unit tests cover all optional field combinations"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"phase-2-sdk-integration-weeks-2-3",children:"Phase 2: SDK Integration (Weeks 2-3)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Deliverables:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 Python SDK: ",(0,i.jsx)(n.code,{children:"client.publish()"})," wraps payload in envelope"]}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Go SDK: Type-safe envelope wrappers"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Rust SDK: Zero-copy envelope parsing"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Envelope builder API for custom metadata"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Success Criteria:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"SDK hides envelope complexity from developers"}),"\n",(0,i.jsx)(n.li,{children:"Publish/subscribe APIs unchanged (envelope is transparent)"}),"\n",(0,i.jsx)(n.li,{children:"Performance overhead <5% latency"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"phase-3-backend-plugin-support-weeks-4-5",children:"Phase 3: Backend Plugin Support (Weeks 4-5)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Deliverables:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Kafka plugin: Envelope as message value + headers"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 NATS plugin: Envelope as message data + NATS headers"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Redis plugin: Envelope as pub/sub message"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 PostgreSQL plugin: Envelope as JSONB column"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Success Criteria:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"All plugins serialize/deserialize envelope correctly"}),"\n",(0,i.jsx)(n.li,{children:"Backend-specific features preserved (Kafka partition keys, NATS headers)"}),"\n",(0,i.jsx)(n.li,{children:"Integration tests pass for all backends"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"phase-4-observability-integration-week-6",children:"Phase 4: Observability Integration (Week 6)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Deliverables:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 OpenTelemetry trace context propagation"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Prometheus metrics with envelope labels"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Signoz dashboard for envelope metadata"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Success Criteria:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Traces span producer \u2192 proxy \u2192 consumer"}),"\n",(0,i.jsx)(n.li,{children:"Metrics breakdowns by topic, namespace, schema version"}),"\n",(0,i.jsx)(n.li,{children:"Audit logs include envelope metadata"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"phase-5-migration-tools-week-7",children:"Phase 5: Migration Tools (Week 7)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Deliverables:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 CLI tool: ",(0,i.jsx)(n.code,{children:"prism envelope migrate --from redis --to kafka"})]}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Dual-write proxy for transition period"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Validation tool: Check envelope compatibility"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Success Criteria:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Zero downtime migration for existing deployments"}),"\n",(0,i.jsx)(n.li,{children:"Backward compatibility verified with integration tests"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"trade-offs-and-alternatives",children:"Trade-Offs and Alternatives"}),"\n",(0,i.jsx)(n.h3,{id:"alternative-1-json-envelope",children:"Alternative 1: JSON Envelope"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Pros:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Human-readable (debugging easier)"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Language-agnostic (no code generation)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Cons:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u274c 3-10x larger than protobuf"}),"\n",(0,i.jsx)(n.li,{children:"\u274c No type safety (runtime errors)"}),"\n",(0,i.jsx)(n.li,{children:"\u274c Slower parsing (JSON vs protobuf)"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Verdict:"})," Protobuf's benefits outweigh JSON's readability."]}),"\n",(0,i.jsx)(n.h3,{id:"alternative-2-no-envelope-backend-specific-headers",children:"Alternative 2: No Envelope (Backend-Specific Headers)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Pros:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Zero overhead (no wrapper)"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Native to each backend"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Cons:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u274c Inconsistent across backends"}),"\n",(0,i.jsx)(n.li,{children:"\u274c Can't evolve metadata without breaking consumers"}),"\n",(0,i.jsx)(n.li,{children:"\u274c No standard place for auth, schema, trace context"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Verdict:"})," Envelope provides consistency and evolution worth the overhead."]}),"\n",(0,i.jsx)(n.h3,{id:"alternative-3-cloudevents-standard",children:"Alternative 3: CloudEvents Standard"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Pros:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Industry standard (CNCF)"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Rich tooling ecosystem"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Cons:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u274c JSON-based (larger payloads)"}),"\n",(0,i.jsx)(n.li,{children:"\u274c Designed for HTTP, not native pub/sub"}),"\n",(0,i.jsx)(n.li,{children:"\u274c Missing Prism-specific fields (namespace, schema governance)"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Verdict:"})," CloudEvents-inspired but not compatible (different goals)."]}),"\n",(0,i.jsx)(n.h2,{id:"success-criteria",children:"Success Criteria"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Developer Adoption"}),": 80% of new pub/sub code uses Prism envelope within 6 months"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance"}),": <5% latency overhead vs baseline (no envelope)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Backward Compatibility"}),": v1 \u2192 v2 envelope migration with zero downtime"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cross-Backend Portability"}),": Same producer/consumer code works with Kafka, NATS, Redis"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Security Compliance"}),": 100% of PII messages have ",(0,i.jsx)(n.code,{children:"contains_pii=true"})," flag"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"open-questions",children:"Open Questions"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Batch Envelope"}),": Should we support multi-message envelopes for high-throughput?"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compression"}),": Should envelope metadata be compressed (gzip) for large payloads?"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Deduplication"}),": Should envelope include nonce for idempotent processing?"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Replay"}),": Should envelope track message lineage for event sourcing?"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"RFC-030"}),": Schema Evolution and Validation (schema context integration)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"RFC-014"}),": Layered Data Access Patterns (pub/sub patterns)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"RFC-008"}),": Proxy Plugin Architecture (backend plugins)"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.w3.org/TR/trace-context/",children:"W3C Trace Context"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://cloudevents.io/",children:"CloudEvents Spec"})," (inspiration for observability fields)"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://protobuf.dev/programming-guides/dos-donts/",children:"Protobuf Best Practices"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"2025-10-13 (v1): Initial draft - Unified message envelope protocol for pub/sub systems"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);