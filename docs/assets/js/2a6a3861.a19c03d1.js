"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[46329],{18725:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"adr-002","title":"Client-Originated Configuration","description":"Context","source":"@site/../docs-cms/adr/adr-002-client-originated-configuration.md","sourceDirName":".","slug":"/adr-002","permalink":"/prism-data-layer/adr/adr-002","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/adr-002-client-originated-configuration.md","tags":[{"inline":true,"label":"architecture","permalink":"/prism-data-layer/adr/tags/architecture"},{"inline":true,"label":"configuration","permalink":"/prism-data-layer/adr/tags/configuration"},{"inline":true,"label":"dx","permalink":"/prism-data-layer/adr/tags/dx"}],"version":"current","frontMatter":{"date":"2025-10-05T00:00:00.000Z","deciders":"Core Team","doc_uuid":"b4c74aef-30c2-47a0-b998-04a139f1e716","id":"adr-002","project_id":"prism-data-layer","status":"Accepted","tags":["architecture","configuration","dx"],"title":"Client-Originated Configuration"},"sidebar":"adrSidebar","previous":{"title":"Rust for the Proxy Implementation \u2022 ADR-001","permalink":"/prism-data-layer/adr/adr-001"},"next":{"title":"Protobuf as Single Source of Truth \u2022 ADR-003","permalink":"/prism-data-layer/adr/adr-003"}}');var r=i(74848),t=i(28453);const a={date:new Date("2025-10-05T00:00:00.000Z"),deciders:"Core Team",doc_uuid:"b4c74aef-30c2-47a0-b998-04a139f1e716",id:"adr-002",project_id:"prism-data-layer",status:"Accepted",tags:["architecture","configuration","dx"],title:"Client-Originated Configuration"},l=void 0,o={},c=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Rationale",id:"rationale",level:2},{value:"How It Works",id:"how-it-works",level:3},{value:"Benefits Over Manual Provisioning",id:"benefits-over-manual-provisioning",level:3},{value:"Alternatives Considered",id:"alternatives-considered",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Organizational Scalability and Authorization Boundaries",id:"organizational-scalability-and-authorization-boundaries",level:2},{value:"The Scalability Challenge",id:"the-scalability-challenge",level:3},{value:"Authorization Boundaries: Expressibility vs Security/Reliability",id:"authorization-boundaries-expressibility-vs-securityreliability",level:3},{value:"Configuration Permission Levels",id:"configuration-permission-levels",level:3},{value:"Policy Enforcement Mechanism",id:"policy-enforcement-mechanism",level:3},{value:"Permission Escalation Workflow",id:"permission-escalation-workflow",level:3},{value:"Common Configuration Mistakes Prevented",id:"common-configuration-mistakes-prevented",level:3},{value:"Organizational Benefits",id:"organizational-benefits",level:3},{value:"Future Enhancements",id:"future-enhancements",level:3},{value:"Implementation Notes",id:"implementation-notes",level:2},{value:"Protobuf Extensions",id:"protobuf-extensions",level:3},{value:"Capacity Planner Algorithm",id:"capacity-planner-algorithm",level:3},{value:"Evolution Strategy",id:"evolution-strategy",level:3},{value:"References",id:"references",level:2},{value:"Revision History",id:"revision-history",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,r.jsx)(n.p,{children:"Traditional data infrastructure requires manual provisioning:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Application team estimates data requirements"}),"\n",(0,r.jsx)(n.li,{children:"DBA provisions database cluster"}),"\n",(0,r.jsx)(n.li,{children:"Application team configures connection details"}),"\n",(0,r.jsx)(n.li,{children:"Capacity is often wrong (over or under-provisioned)"}),"\n",(0,r.jsx)(n.li,{children:"Changes require coordination between teams"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Netflix's Data Gateway improves this with declarative deployment configuration, but still requires infrastructure team involvement to map capacity requirements to hardware."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Manual capacity planning is slow, error-prone, and creates bottlenecks."]}),"\n",(0,r.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,r.jsxs)(n.p,{children:["Implement ",(0,r.jsx)(n.strong,{children:"client-originated configuration"})," where applications declare their data access patterns in protobuf definitions, and Prism automatically:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Selects optimal backend storage engine"}),"\n",(0,r.jsx)(n.li,{children:"Calculates capacity requirements"}),"\n",(0,r.jsx)(n.li,{children:"Provisions infrastructure"}),"\n",(0,r.jsx)(n.li,{children:"Configures connections and policies"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"rationale",children:"Rationale"}),"\n",(0,r.jsx)(n.h3,{id:"how-it-works",children:"How It Works"}),"\n",(0,r.jsx)(n.p,{children:"Applications define data models with annotations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-protobuf",children:'message UserEvents {\n  string user_id = 1 [(prism.index) = "partition_key"];\n  bytes event_data = 2;\n  int64 timestamp = 3 [(prism.index) = "clustering_key"];\n\n  option (prism.access_pattern) = "append_heavy";  // 95% writes, 5% reads\n  option (prism.estimated_write_rps) = "10000";     // Peak writes/sec\n  option (prism.estimated_read_rps) = "500";        // Peak reads/sec\n  option (prism.data_size_estimate_mb) = "1000";    // Total data size\n  option (prism.retention_days) = "90";             // Auto-delete old data\n  option (prism.consistency) = "eventual";          // Consistency requirement\n  option (prism.latency_p99_ms) = "10";             // Latency SLO\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Prism's capacity planner:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Analyzes access pattern"}),': "append_heavy" \u2192 Kafka is ideal']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Calculates partition count"}),": 10k writes/sec \u2192 20 partitions (500 writes/partition/sec)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Provisions cluster"}),": Creates Kafka cluster with appropriate instance types"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Configures retention"}),": Sets 90-day retention policy"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sets up monitoring"}),": Alerts if P99 > 10ms or RPS exceeds 10k"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"benefits-over-manual-provisioning",children:"Benefits Over Manual Provisioning"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Aspect"}),(0,r.jsx)(n.th,{children:"Manual"}),(0,r.jsx)(n.th,{children:"Client-Originated"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Time to provision"}),(0,r.jsx)(n.td,{children:"Days/weeks"}),(0,r.jsx)(n.td,{children:"Minutes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Accuracy"}),(0,r.jsx)(n.td,{children:"Often wrong"}),(0,r.jsx)(n.td,{children:"Data-driven"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Ownership"}),(0,r.jsx)(n.td,{children:"Split (app + infra teams)"}),(0,r.jsx)(n.td,{children:"Clear (app team)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Scaling"}),(0,r.jsx)(n.td,{children:"Manual requests"}),(0,r.jsx)(n.td,{children:"Automatic"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Cost optimization"}),(0,r.jsx)(n.td,{children:"Ad-hoc"}),(0,r.jsx)(n.td,{children:"Continuous"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Manual Provisioning"})," (traditional approach)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Pros:\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Full control"}),"\n",(0,r.jsx)(n.li,{children:"Familiar to ops teams"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Cons:\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Slow (days/weeks)"}),"\n",(0,r.jsx)(n.li,{children:"Error-prone"}),"\n",(0,r.jsx)(n.li,{children:"Creates bottlenecks"}),"\n",(0,r.jsx)(n.li,{children:"Scales poorly (1 DBA : N teams)"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"Rejected because: Doesn't scale as org grows"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Declarative Deployment Config"})," (Netflix's approach)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Pros:\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Better than manual"}),"\n",(0,r.jsx)(n.li,{children:"Infrastructure as code"}),"\n",(0,r.jsx)(n.li,{children:"Version controlled"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Cons:\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Still requires capacity planning expertise"}),"\n",(0,r.jsx)(n.li,{children:"Separate from application code"}),"\n",(0,r.jsx)(n.li,{children:"Changes require infra team review"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"Rejected because: Still creates coordination overhead"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Fully Automatic"})," (no application hints)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Pros:\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Zero configuration burden"}),"\n",(0,r.jsx)(n.li,{children:"Ultimate simplicity"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Cons:\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Cannot optimize for known patterns"}),"\n",(0,r.jsx)(n.li,{children:"Over-provisions to be safe"}),"\n",(0,r.jsx)(n.li,{children:"Higher costs"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"Rejected because: Loses optimization opportunities"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Runtime Metrics-Based"})," (scale based on observed load)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Pros:\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Responds to actual usage"}),"\n",(0,r.jsx)(n.li,{children:"No estimation needed"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Cons:\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Reactive not proactive"}),"\n",(0,r.jsx)(n.li,{children:"Poor for spiky workloads"}),"\n",(0,r.jsx)(n.li,{children:"Doesn't help initial provisioning"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"Rejected because: Can be combined with client-originated config for continuous optimization"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,r.jsx)(n.h3,{id:"positive",children:"Positive"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Faster Development"}),": No waiting for database provisioning"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Self-Service"}),": Application teams are empowered"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Accurate Capacity"}),": Based on actual requirements, not guesses"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cost Optimization"}),": Right-sized infrastructure from day one"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Living Documentation"}),": Protobuf definitions document requirements"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Easier Migrations"}),": Change ",(0,r.jsx)(n.code,{children:'option (prism.backend) = "postgres"'})," to ",(0,r.jsx)(n.code,{children:'"kafka"'})," and redeploy"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Organizational Scalability"}),": Infrastructure team doesn't become bottleneck as company grows"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"negative",children:"Negative"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"More Complex Tooling"}),": Capacity planner must be sophisticated\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"Mitigation"}),": Start with conservative heuristics; refine over time"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Protobuf Coupling"}),": Configuration embedded in data models\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"Mitigation"}),": This is intentional; keeps requirements close to code"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Requires Estimation"}),": Teams must estimate RPS, data size\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"Mitigation"}),": Provide estimation tools; Prism adapts based on actual metrics"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Configuration Authority"}),": Need authorization boundaries to prevent misuse\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"Mitigation"}),": Policy-driven configuration limits (see Organizational Scalability section)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"neutral",children:"Neutral"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Shifts Responsibility"}),": From infra team to app teams\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Some teams will prefer this (autonomy)"}),"\n",(0,r.jsx)(n.li,{children:"Others may miss having an expert provision for them"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"Plan"}),": Provide templates and examples for common patterns"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"organizational-scalability-and-authorization-boundaries",children:"Organizational Scalability and Authorization Boundaries"}),"\n",(0,r.jsx)(n.h3,{id:"the-scalability-challenge",children:"The Scalability Challenge"}),"\n",(0,r.jsx)(n.p,{children:"As organizations grow, traditional manual provisioning breaks down:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Organization Size"}),(0,r.jsx)(n.th,{children:"Manual Provisioning Model"}),(0,r.jsx)(n.th,{children:"Bottleneck"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Startup (1-5 teams)"})}),(0,r.jsx)(n.td,{children:"1 DBA provisions all databases"}),(0,r.jsx)(n.td,{children:"Works initially"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Growing (10-20 teams)"})}),(0,r.jsx)(n.td,{children:"2-3 DBAs, ticket queue"}),(0,r.jsx)(n.td,{children:"1-2 week delays"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Scale (50+ teams)"})}),(0,r.jsx)(n.td,{children:"5-10 DBAs, complex approval process"}),(0,r.jsx)(n.td,{children:"2-4 week delays, team burnout"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Large (500+ teams)"})}),(0,r.jsx)(n.td,{children:"20+ DBAs, dedicated infrastructure org"}),(0,r.jsx)(n.td,{children:"Infrastructure team larger than feature teams"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Client-originated configuration solves this"}),": Infrastructure team size remains ",(0,r.jsx)(n.strong,{children:"constant"})," (maintain Prism platform) while application teams scale ",(0,r.jsx)(n.strong,{children:"linearly"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key Insight"}),": Client configurability is essential for organizational scalability, but requires authorization boundaries to prevent misuse."]}),"\n",(0,r.jsx)(n.h3,{id:"authorization-boundaries-expressibility-vs-securityreliability",children:"Authorization Boundaries: Expressibility vs Security/Reliability"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"The Tension"}),": Allow teams enough expressibility to move fast, but prevent configurations that compromise security or reliability."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Guiding Principles"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Default to Safe"}),": Conservative defaults prevent common misconfigurations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Progressive Permission"}),": Teams earn more configurability through demonstrated responsibility"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Policy as Code"}),": Configuration limits defined in version-controlled policies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fail Loudly"}),": Invalid configurations rejected at deploy-time, not runtime"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"configuration-permission-levels",children:"Configuration Permission Levels"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Level 1: Guided (Default for All Teams)"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Allowed"}),": Choose from pre-approved backends (Postgres, Kafka, Redis)"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Allowed"}),": Set access patterns (",(0,r.jsx)(n.code,{children:"read_heavy"}),", ",(0,r.jsx)(n.code,{children:"write_heavy"}),", ",(0,r.jsx)(n.code,{children:"balanced"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Allowed"}),": Declare capacity estimates (within reasonable bounds)"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Allowed"}),": Configure retention (up to organization maximum)"]}),"\n",(0,r.jsxs)(n.li,{children:["\u274c ",(0,r.jsx)(n.strong,{children:"Restricted"}),": Backend-specific tuning parameters"]}),"\n",(0,r.jsxs)(n.li,{children:["\u274c ",(0,r.jsx)(n.strong,{children:"Restricted"}),": Replication factors, partition counts"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-protobuf",children:'message UserEvents {\n  option (prism.backend) = "kafka";           // \u2705 Allowed\n  option (prism.access_pattern) = "append_heavy";  // \u2705 Allowed\n  option (prism.estimated_write_rps) = "10000";    // \u2705 Allowed (within limits)\n  option (prism.retention_days) = "90";            // \u2705 Allowed (< 180 day max)\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Level 2: Advanced (Requires Platform Team Approval)"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Allowed"}),": All Level 1 permissions"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Allowed"}),": Backend-specific tuning (e.g., Kafka partition count)"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Allowed"}),": Custom replication factors"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Allowed"}),": Extended retention (up to 1 year)"]}),"\n",(0,r.jsxs)(n.li,{children:["\u274c ",(0,r.jsx)(n.strong,{children:"Restricted"}),": Cross-region replication"]}),"\n",(0,r.jsxs)(n.li,{children:["\u274c ",(0,r.jsx)(n.strong,{children:"Restricted"}),": Encryption key management overrides"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-protobuf",children:'message HighThroughputLogs {\n  option (prism.backend) = "kafka";\n  option (prism.kafka_partitions) = "50";          // \u2705 Advanced permission required\n  option (prism.kafka_replication_factor) = "5";   // \u2705 Advanced permission required\n  option (prism.retention_days) = "365";           // \u2705 Advanced permission required\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Level 3: Expert (Platform Team Only)"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Allowed"}),": All Level 1 & 2 permissions"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Allowed"}),": Cross-region replication"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Allowed"}),": Custom encryption keys (BYOK)"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Allowed"}),": Low-level performance tuning"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Allowed"}),": Override safety limits"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"policy-enforcement-mechanism",children:"Policy Enforcement Mechanism"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Configuration Validation at Deploy Time"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'pub struct ConfigurationValidator {\n    policies: HashMap<String, TeamPolicy>,\n}\n\npub struct TeamPolicy {\n    team_name: String,\n    permission_level: PermissionLevel,\n    limits: ConfigurationLimits,\n}\n\npub struct ConfigurationLimits {\n    max_write_rps: i64,\n    max_read_rps: i64,\n    max_retention_days: i32,\n    max_data_size_gb: i64,\n    allowed_backends: Vec<String>,\n    backend_specific_tuning: bool,\n}\n\nimpl ConfigurationValidator {\n    pub fn validate(&self, config: &MessageConfig, team: &str) -> Result<(), ValidationError> {\n        let policy = self.policies.get(team)\n            .ok_or(ValidationError::UnknownTeam(team.to_string()))?;\n\n        let limits = &policy.limits;\n\n        // Check RPS within limits\n        if config.estimated_write_rps > limits.max_write_rps {\n            return Err(ValidationError::ExceedsLimit {\n                field: "estimated_write_rps",\n                value: config.estimated_write_rps,\n                max: limits.max_write_rps,\n                message: format!(\n                    "Team {} limited to {}k writes/sec. Request platform team approval for higher capacity.",\n                    team, limits.max_write_rps / 1000\n                ),\n            });\n        }\n\n        // Check retention within limits\n        if config.retention_days > limits.max_retention_days {\n            return Err(ValidationError::ExceedsLimit {\n                field: "retention_days",\n                value: config.retention_days,\n                max: limits.max_retention_days,\n                message: format!(\n                    "Team {} limited to {} day retention. Longer retention requires compliance review.",\n                    team, limits.max_retention_days\n                ),\n            });\n        }\n\n        // Check backend in allowed list\n        if let Some(backend) = &config.backend {\n            if !limits.allowed_backends.contains(backend) {\n                return Err(ValidationError::DisallowedBackend {\n                    backend: backend.clone(),\n                    allowed: limits.allowed_backends.clone(),\n                    message: format!(\n                        "Backend \'{}\' not approved for team {}. Allowed backends: {}",\n                        backend, team, limits.allowed_backends.join(", ")\n                    ),\n                });\n            }\n        }\n\n        // Check backend-specific tuning permissions\n        if config.has_backend_tuning() && !limits.backend_specific_tuning {\n            return Err(ValidationError::PermissionDenied {\n                field: "backend tuning parameters",\n                message: format!(\n                    "Team {} does not have permission for backend-specific tuning. Request \'Advanced\' permission level.",\n                    team\n                ),\n            });\n        }\n\n        Ok(())\n    }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example Policy Configuration"})," (",(0,r.jsx)(n.code,{children:"policies/teams.yaml"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"teams:\n  # Most teams start here\n  - name: user-platform-team\n    permission_level: guided\n    limits:\n      max_write_rps: 50000\n      max_read_rps: 100000\n      max_retention_days: 180\n      max_data_size_gb: 1000\n      allowed_backends: [postgres, kafka, redis]\n      backend_specific_tuning: false\n\n  # Teams with demonstrated expertise\n  - name: data-infrastructure-team\n    permission_level: advanced\n    limits:\n      max_write_rps: 500000\n      max_read_rps: 1000000\n      max_retention_days: 365\n      max_data_size_gb: 10000\n      allowed_backends: [postgres, kafka, redis, nats, clickhouse]\n      backend_specific_tuning: true\n\n  # Platform team has unrestricted access\n  - name: platform-team\n    permission_level: expert\n    limits:\n      max_write_rps: unlimited\n      max_read_rps: unlimited\n      max_retention_days: unlimited\n      max_data_size_gb: unlimited\n      allowed_backends: [all]\n      backend_specific_tuning: true\n      cross_region_replication: true\n      custom_encryption_keys: true\n"})}),"\n",(0,r.jsx)(n.h3,{id:"permission-escalation-workflow",children:"Permission Escalation Workflow"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Scenario"}),": Team needs higher capacity than allowed by policy."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Workflow"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Team deploys configuration with ",(0,r.jsx)(n.code,{children:"estimated_write_rps: 100000"})]}),"\n",(0,r.jsxs)(n.li,{children:["Validation fails: ",(0,r.jsx)(n.code,{children:"Team user-platform-team limited to 50k writes/sec"})]}),"\n",(0,r.jsx)(n.li,{children:'Team opens request: "Increase RPS limit to 100k for user-events namespace"'}),"\n",(0,r.jsxs)(n.li,{children:["Platform team reviews:\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Is the estimate reasonable? (check current metrics)"}),"\n",(0,r.jsx)(n.li,{children:"Will this impact cluster capacity? (check resource availability)"}),"\n",(0,r.jsx)(n.li,{children:"Is the backend choice optimal? (suggest alternatives if not)"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["If approved, update ",(0,r.jsx)(n.code,{children:"policies/teams.yaml"}),":\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"- name: user-platform-team\n  permission_level: guided\n  limits:\n    max_write_rps: 100000  # \u2190 Increased\n"})}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"Team redeploys successfully"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key Benefits"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Audit Trail"}),": All permission changes version-controlled"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Gradual Escalation"}),": Teams earn trust over time"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Central Oversight"}),": Platform team maintains visibility"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fast Approval"}),": Simple cases auto-approved via policy updates"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"common-configuration-mistakes-prevented",children:"Common Configuration Mistakes Prevented"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"1. Excessive Retention Leading to Cost Overruns"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-protobuf",children:'// \u274c Rejected at deploy time\nmessage DebugLogs {\n  option (prism.retention_days) = "3650";  // 10 years!\n  // Error: Team limited to 180 days. Compliance review required for >1 year retention.\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"2. Wrong Backend for Access Pattern"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-protobuf",children:'// \u26a0\ufe0f Warning at deploy time\nmessage HighThroughputEvents {\n  option (prism.backend) = "postgres";\n  option (prism.access_pattern) = "append_heavy";\n  option (prism.estimated_write_rps) = "50000";\n  // Warning: Postgres may struggle with 50k writes/sec. Consider Kafka for append-heavy workloads.\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"3. Over-Provisioning Resources"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-protobuf",children:'// \u274c Rejected at deploy time\nmessage UserSessions {\n  option (prism.estimated_write_rps) = "100000";\n  option (prism.kafka_partitions) = "500";  // Way too many!\n  // Error: 500 partitions for 100k writes/sec is excessive. Recommended: 200 partitions (500 writes/partition/sec).\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"organizational-benefits",children:"Organizational Benefits"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Before Client-Originated Configuration"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Infrastructure team: 10 people"}),"\n",(0,r.jsx)(n.li,{children:"Application teams: 50 teams (500 engineers)"}),"\n",(0,r.jsx)(n.li,{children:"Bottleneck: 2-4 week provisioning delays"}),"\n",(0,r.jsx)(n.li,{children:"Cost: Infrastructure team growth required to scale"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"After Client-Originated Configuration with Authorization Boundaries"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Infrastructure team: 10 people (maintain Prism platform)"}),"\n",(0,r.jsx)(n.li,{children:"Application teams: 50 teams (self-service)"}),"\n",(0,r.jsx)(n.li,{children:"Bottleneck: Eliminated for 90% of requests, escalation path for 10%"}),"\n",(0,r.jsxs)(n.li,{children:["Cost: Infrastructure team size ",(0,r.jsx)(n.strong,{children:"stays constant"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Scaling Math"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Without Prism: 1 DBA per 10 teams \u2192 50 teams needs 5 DBAs"}),"\n",(0,r.jsx)(n.li,{children:"With Prism: Platform team of 10 supports 500+ teams (50x improvement)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"future-enhancements",children:"Future Enhancements"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Automated Permission Elevation"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"auto_approve_conditions:\n  - if: team.track_record > 6_months && team.incidents == 0\n    then: grant permission_level: advanced\n\n  - if: config.estimated_write_rps < current_metrics.write_rps * 1.5\n    then: auto_approve  # Only 50% increase, low risk\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cost Budgeting Integration"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-protobuf",children:"message ExpensiveData {\n  option (prism.estimated_cost_per_month) = 5000;  // $5k/month\n  option (prism.team_budget_limit) = 10000;        // $10k/month\n  // Auto-approved if within budget, requires approval if over\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,r.jsx)(n.h3,{id:"protobuf-extensions",children:"Protobuf Extensions"}),"\n",(0,r.jsxs)(n.p,{children:["Define custom options in ",(0,r.jsx)(n.code,{children:"prism/options.proto"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-protobuf",children:'syntax = "proto3";\n\npackage prism;\n\nimport "google/protobuf/descriptor.proto";\n\nextend google.protobuf.MessageOptions {\n  // Access pattern hint\n  string access_pattern = 50001;  // "read_heavy" | "write_heavy" | "append_heavy" | "balanced"\n\n  // Capacity estimates\n  int64 estimated_read_rps = 50002;\n  int64 estimated_write_rps = 50003;\n  int64 data_size_estimate_mb = 50004;\n\n  // Policies\n  int32 retention_days = 50005;\n  string consistency = 50006;  // "strong" | "eventual" | "causal"\n  int32 latency_p99_ms = 50007;\n\n  // Backend override (optional)\n  string backend = 50008;  // "postgres" | "kafka" | "sqlite" | etc.\n}\n\nextend google.protobuf.FieldOptions {\n  // Index type\n  string index = 50101;  // "primary" | "secondary" | "partition_key" | "clustering_key"\n\n  // PII tagging\n  string pii = 50102;  // "email" | "name" | "ssn" | etc.\n\n  // Encryption\n  bool encrypt_at_rest = 50103;\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"capacity-planner-algorithm",children:"Capacity Planner Algorithm"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'struct CapacityPlanner;\n\nimpl CapacityPlanner {\n    fn plan(&self, config: &MessageConfig) -> InfrastructureSpec {\n        // 1. Select backend based on access pattern\n        let backend = self.select_backend(config);\n\n        // 2. Calculate required capacity\n        let capacity = match backend {\n            Backend::Kafka => self.plan_kafka(config),\n            Backend::Postgres => self.plan_postgres(config),\n            Backend::Nats => self.plan_nats(config),\n            // ...\n        };\n\n        // 3. Return infrastructure specification\n        InfrastructureSpec {\n            backend,\n            capacity,\n            policies: self.extract_policies(config),\n        }\n    }\n\n    fn select_backend(&self, config: &MessageConfig) -> Backend {\n        if let Some(explicit) = config.backend {\n            return explicit;\n        }\n\n        match config.access_pattern {\n            "append_heavy" => Backend::Kafka,\n            "read_heavy" if config.supports_sql() => Backend::Postgres,\n            "balanced" => Backend::Postgres,\n            "graph" => Backend::Neptune,\n            _ => Backend::Postgres, // Safe default\n        }\n    }\n\n    fn plan_kafka(&self, config: &MessageConfig) -> KafkaCapacity {\n        // Rule of thumb: 500 writes/sec per partition\n        let partitions = (config.estimated_write_rps / 500).max(1);\n\n        // Calculate retention storage\n        let daily_data_mb = (config.estimated_write_rps * 86400 * config.avg_message_size_bytes) / 1_000_000;\n        let retention_storage_gb = daily_data_mb * config.retention_days / 1000;\n\n        KafkaCapacity {\n            partitions,\n            replication_factor: 3,  // Default for durability\n            retention_storage_gb,\n            instance_type: self.select_kafka_instance_type(config),\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"evolution-strategy",children:"Evolution Strategy"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Phase 1"})," (MVP): Support explicit backend selection"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-protobuf",children:'option (prism.backend) = "postgres";\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Phase 2"}),": Add access pattern hints"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-protobuf",children:'option (prism.access_pattern) = "read_heavy";\noption (prism.estimated_read_rps) = "10000";\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Phase 3"}),": Automatic backend selection based on patterns"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Phase 4"}),": Continuous optimization using runtime metrics"]}),"\n",(0,r.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Netflix Data Gateway Deployment Configuration"}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://wa.aws.amazon.com/",children:"AWS Well-Architected Framework - Capacity Planning"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://sre.google/sre-book/handling-overload/",children:"Google SRE Book - Capacity Planning"})}),"\n",(0,r.jsx)(n.li,{children:"ADR-003: Protobuf as Single Source of Truth"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"2025-10-05: Initial draft and acceptance"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var s=i(96540);const r={},t=s.createContext(r);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);