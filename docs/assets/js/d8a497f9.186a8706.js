"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[8792],{28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>l});var i=s(96540);const r={},t=i.createContext(r);function a(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(t.Provider,{value:n},e.children)}},73294:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"memo-005","title":"Client Protocol Design Philosophy - Composition vs Use-Case Specificity","description":"Purpose","source":"@site/../docs-cms/memos/memo-005-client-protocol-design-philosophy.md","sourceDirName":".","slug":"/memo-005","permalink":"/prism-data-layer/memos/memo-005","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/memos/memo-005-client-protocol-design-philosophy.md","tags":[{"inline":true,"label":"api-design","permalink":"/prism-data-layer/memos/tags/api-design"},{"inline":true,"label":"patterns","permalink":"/prism-data-layer/memos/tags/patterns"},{"inline":true,"label":"developer-experience","permalink":"/prism-data-layer/memos/tags/developer-experience"},{"inline":true,"label":"architecture","permalink":"/prism-data-layer/memos/tags/architecture"},{"inline":true,"label":"evolution","permalink":"/prism-data-layer/memos/tags/evolution"}],"version":"current","frontMatter":{"author":"Platform Team","created":"2025-10-09T00:00:00.000Z","doc_uuid":"30d6950c-8e74-4fcb-a4a5-873a1951b771","id":"memo-005","project_id":"prism-data-layer","tags":["api-design","patterns","developer-experience","architecture","evolution"],"title":"Client Protocol Design Philosophy - Composition vs Use-Case Specificity","updated":"2025-10-09T00:00:00.000Z"},"sidebar":"memosSidebar","previous":{"title":"Backend Plugin Implementation Guide \u2022 MEMO-004","permalink":"/prism-data-layer/memos/memo-004"},"next":{"title":"Backend Interface Decomposition and Schema Registry \u2022 MEMO-006","permalink":"/prism-data-layer/memos/memo-006"}}');var r=s(74848),t=s(28453);const a={author:"Platform Team",created:new Date("2025-10-09T00:00:00.000Z"),doc_uuid:"30d6950c-8e74-4fcb-a4a5-873a1951b771",id:"memo-005",project_id:"prism-data-layer",tags:["api-design","patterns","developer-experience","architecture","evolution"],title:"Client Protocol Design Philosophy - Composition vs Use-Case Specificity",updated:new Date("2025-10-09T00:00:00.000Z")},l="MEMO-005: Client Protocol Design Philosophy",c={},o=[{value:"Purpose",id:"purpose",level:2},{value:"Context",id:"context",level:2},{value:"RFC-014: Layered Data Access Patterns (Composable Approach)",id:"rfc-014-layered-data-access-patterns-composable-approach",level:3},{value:"RFC-017: Multicast Registry (Use-Case-Specific Approach)",id:"rfc-017-multicast-registry-use-case-specific-approach",level:3},{value:"Design Principles",id:"design-principles",level:2},{value:"1. Push Complexity Down from Application Developers \u2b50 <strong>PRIMARY</strong>",id:"1-push-complexity-down-from-application-developers--primary",level:3},{value:"2. Developer Comprehension and Usability \u2b50 <strong>PRIMARY</strong>",id:"2-developer-comprehension-and-usability--primary",level:3},{value:"3. Schema and Service Evolution",id:"3-schema-and-service-evolution",level:3},{value:"4. Keep Proxy Small and Tight",id:"4-keep-proxy-small-and-tight",level:3},{value:"Decision Matrix",id:"decision-matrix",level:2},{value:"Comparison to Alternatives",id:"comparison-to-alternatives",level:2},{value:"Alternative A: Primitives Only (No Layer 2)",id:"alternative-a-primitives-only-no-layer-2",level:3},{value:"Alternative B: Use-Case APIs Only (No Layer 1)",id:"alternative-b-use-case-apis-only-no-layer-1",level:3},{value:"Alternative C: Hybrid (Like Kubernetes)",id:"alternative-c-hybrid-like-kubernetes",level:3},{value:"Implementation Roadmap",id:"implementation-roadmap",level:2},{value:"Phase 1: POC Validation (Weeks 1-6, RFC-018)",id:"phase-1-poc-validation-weeks-1-6-rfc-018",level:3},{value:"Phase 2: Pattern Coordinator Prototype (Weeks 7-9, RFC-018)",id:"phase-2-pattern-coordinator-prototype-weeks-7-9-rfc-018",level:3},{value:"Phase 3: Expand Pattern Library (Post-POC, Weeks 12+)",id:"phase-3-expand-pattern-library-post-poc-weeks-12",level:3},{value:"Phase 4: Community Patterns (Months 3-6)",id:"phase-4-community-patterns-months-3-6",level:3},{value:"Naming Conventions",id:"naming-conventions",level:2},{value:"Layer 1: Primitives Use Abstract Nouns",id:"layer-1-primitives-use-abstract-nouns",level:3},{value:"Layer 2: Patterns Use Domain-Specific Verbs",id:"layer-2-patterns-use-domain-specific-verbs",level:3},{value:"Open Questions",id:"open-questions",level:2},{value:"1. How do we prevent Layer 2 explosion?",id:"1-how-do-we-prevent-layer-2-explosion",level:3},{value:"2. Can Layer 2 patterns compose with each other?",id:"2-can-layer-2-patterns-compose-with-each-other",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"memo-005-client-protocol-design-philosophy",children:"MEMO-005: Client Protocol Design Philosophy"})}),"\n",(0,r.jsx)(n.h2,{id:"purpose",children:"Purpose"}),"\n",(0,r.jsx)(n.p,{children:"Resolve the architectural tension between:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Composable primitives"})," (RFC-014: KeyValue, PubSub, Queue) - generic, reusable, small API surface"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use-case-specific protocols"})," (RFC-017: Multicast Registry) - ergonomic, self-documenting, purpose-built"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Core Question"}),": Should Prism offer one protobuf service per use case (IoT, presence, service discovery) or force applications to compose generic primitives?"]}),"\n",(0,r.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,r.jsx)(n.h3,{id:"rfc-014-layered-data-access-patterns-composable-approach",children:"RFC-014: Layered Data Access Patterns (Composable Approach)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Defines 6 generic patterns"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-protobuf",children:"service KeyValueService {\n  rpc Set(SetRequest) returns (SetResponse);\n  rpc Get(GetRequest) returns (GetResponse);\n  rpc Delete(DeleteRequest) returns (DeleteResponse);\n  rpc Scan(ScanRequest) returns (stream ScanResponse);\n}\n\nservice PubSubService {\n  rpc Publish(PublishRequest) returns (PublishResponse);\n  rpc Subscribe(SubscribeRequest) returns (stream Message);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Application must compose"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# IoT device management - application composes primitives\nawait client.keyvalue.set(f"device:{id}", metadata)  # Registry\ndevices = await client.keyvalue.scan("device:*")     # Enumerate\nawait client.pubsub.publish("commands", message)     # Broadcast\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 Small API surface (6 services)"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Reusable across use cases"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Easy to implement in proxy"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Schema evolution is localized"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Drawbacks"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u274c Application must understand composition"}),"\n",(0,r.jsx)(n.li,{children:"\u274c Boilerplate code for common patterns"}),"\n",(0,r.jsx)(n.li,{children:"\u274c No semantic guarantees (e.g., registry consistency)"}),"\n",(0,r.jsx)(n.li,{children:"\u274c Steep learning curve"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"rfc-017-multicast-registry-use-case-specific-approach",children:"RFC-017: Multicast Registry (Use-Case-Specific Approach)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Defines purpose-built API"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-protobuf",children:"service MulticastRegistryService {\n  rpc Register(RegisterRequest) returns (RegisterResponse);\n  rpc Enumerate(EnumerateRequest) returns (EnumerateResponse);\n  rpc Multicast(MulticastRequest) returns (MulticastResponse);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Application uses clear semantics"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# IoT device management - clear intent\nawait client.registry.register(\n    identity="device-123",\n    metadata={"type": "sensor", "location": "building-a"}\n)\n\ndevices = await client.registry.enumerate(\n    filter={"location": "building-a"}\n)\n\nresult = await client.registry.multicast(\n    filter={"type": "sensor"},\n    message={"command": "read_temperature"}\n)\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 Self-documenting (clear purpose)"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Less boilerplate"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Semantic guarantees (coordinated registry + messaging)"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Easier for application developers"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Drawbacks"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u274c API proliferation (one service per use case?)"}),"\n",(0,r.jsx)(n.li,{children:"\u274c More code in proxy (20+ services?)"}),"\n",(0,r.jsx)(n.li,{children:"\u274c Schema evolution harder (changes affect specific use cases)"}),"\n",(0,r.jsx)(n.li,{children:"\u274c Duplication across similar patterns"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"design-principles",children:"Design Principles"}),"\n",(0,r.jsxs)(n.h3,{id:"1-push-complexity-down-from-application-developers--primary",children:["1. Push Complexity Down from Application Developers \u2b50 ",(0,r.jsx)(n.strong,{children:"PRIMARY"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Goal"}),": Developers shouldn't need to understand distributed systems internals."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implications"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 Favor use-case-specific APIs (e.g., Multicast Registry)"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Hide coordination complexity (e.g., keeping registry + pub/sub consistent)"}),"\n",(0,r.jsx)(n.li,{children:'\u2705 Provide semantic guarantees (e.g., "multicast delivers to all registered")'}),"\n",(0,r.jsx)(n.li,{children:"\u274c Avoid forcing developers to compose primitives manually"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# BAD: Application must coordinate registry + pub/sub\ndevices = await client.keyvalue.scan("device:*")\nfor device in devices:\n    await client.pubsub.publish(f"device:{device}", message)\n# Problem: Race condition if device registers between scan and publish\n\n# GOOD: Prism coordinates atomically\nawait client.registry.multicast(filter={}, message=message)\n# Prism guarantees atomicity: enumerate + fan-out\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"2-developer-comprehension-and-usability--primary",children:["2. Developer Comprehension and Usability \u2b50 ",(0,r.jsx)(n.strong,{children:"PRIMARY"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Goal"}),": APIs should be immediately understandable without deep documentation."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implications"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u2705 Favor self-documenting method names (",(0,r.jsx)(n.code,{children:"register"}),", ",(0,r.jsx)(n.code,{children:"enumerate"}),", ",(0,r.jsx)(n.code,{children:"multicast"}),")"]}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Provide rich error messages"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Include use-case examples in docs"}),"\n",(0,r.jsx)(n.li,{children:'\u274c Avoid generic terms requiring mental mapping (e.g., "put into keyvalue to register")'}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-protobuf",children:"// CLEAR: Purpose obvious from name\nrpc Register(RegisterRequest) returns (RegisterResponse);\n\n// UNCLEAR: What am I setting? Why?\nrpc Set(SetRequest) returns (SetResponse);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-schema-and-service-evolution",children:"3. Schema and Service Evolution"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Goal"}),": Add features without breaking existing clients."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implications"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 Fewer services = fewer breaking changes (favor composition)"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Backward-compatible field additions"}),"\n",(0,r.jsx)(n.li,{children:"\u26a0\ufe0f Use-case-specific services are easier to version independently"}),"\n",(0,r.jsx)(n.li,{children:"\u274c Changing generic primitive affects many use cases"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-protobuf",children:"// Adding feature to MulticastRegistry: localized impact\nmessage RegisterRequest {\n  string identity = 1;\n  map<string, Value> metadata = 2;\n  optional int64 ttl_seconds = 3;  // NEW: backward compatible\n}\n\n// Adding feature to KeyValue: affects ALL use cases\nmessage SetRequest {\n  string key = 1;\n  bytes value = 2;\n  optional int64 ttl_seconds = 3;  // NEW: breaks IoT, presence, etc.\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"4-keep-proxy-small-and-tight",children:"4. Keep Proxy Small and Tight"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Goal"}),": Minimize proxy complexity and resource footprint."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implications"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 Favor generic primitives (fewer service implementations)"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Pattern coordinators can be plugins (not in core proxy)"}),"\n",(0,r.jsx)(n.li,{children:"\u26a0\ufe0f Use-case services increase code size"}),"\n",(0,r.jsx)(n.li,{children:"\u274c Too many services = maintenance burden"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),":\nProxy with 6 generic services: ~10k LOC, 50MB binary\nProxy with 20 use-case services: ~40k LOC, 150MB binary"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n## Proposed Solution: Layered API Architecture\n\n**Insight**: We don't have to choose! Provide **both layers** with clear separation.\n\n### Layer 1: Primitives (Generic, Always Available)\n\n**Six core primitives** (RFC-014):\n"})}),"\n",(0,r.jsx)(n.p,{children:"service KeyValueService { ... }\nservice PubSubService { ... }\nservice QueueService { ... }\nservice TimeSeriesService { ... }\nservice GraphService { ... }\nservice TransactionalService { ... }"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n**Characteristics**:\n- \u2705 Always available (core proxy functionality)\n- \u2705 Stable API (rarely changes)\n- \u2705 Generic (works for any use case)\n- \u274c Requires composition knowledge\n\n**Target Users**:\n- Advanced developers building custom patterns\n- Performance-critical applications (direct control)\n- Unusual use cases not covered by Layer 2\n\n### Layer 2: Patterns (Use-Case-Specific, Opt-In)\n\n**Purpose-built patterns** (RFC-017, plus more):\n"})}),"\n",(0,r.jsx)(n.p,{children:"service MulticastRegistryService { ... }  // IoT, presence, service discovery\nservice SagaService { ... }               // Distributed transactions\nservice EventSourcingService { ... }      // Audit trails, event log\nservice WorkQueueService { ... }          // Background jobs\nservice CacheAsideService { ... }         // Read-through cache"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n**Characteristics**:\n- \u2705 Self-documenting (clear purpose)\n- \u2705 Semantic guarantees (coordinated operations)\n- \u2705 Less boilerplate (ergonomic APIs)\n- \u26a0\ufe0f Implemented as **pattern coordinators** (plugins, not core)\n\n**Target Users**:\n- Most application developers (80% of use cases)\n- Teams prioritizing velocity over control\n- Developers new to distributed systems\n\n### Implementation Strategy\n\n#### Pattern Coordinators Live in Plugins, Not Core Proxy\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Prism Proxy (Core)                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  Layer 1: Primitives (Always Available)          \u2502   \u2502\n\u2502  \u2502  - KeyValueService                               \u2502   \u2502\n\u2502  \u2502  - PubSubService                                 \u2502   \u2502\n\u2502  \u2502  - QueueService                                  \u2502   \u2502\n\u2502  \u2502  - (3 more...)                                   \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n                         \u2502 gRPC\n                         \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           Pattern Coordinator Plugins (Opt-In)           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502 Multicast Registry \u2502  \u2502  Saga Coordinator      \u2502     \u2502\n\u2502  \u2502 (RFC-017)          \u2502  \u2502  (Distributed Txn)     \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502 Event Sourcing     \u2502  \u2502  Cache Aside           \u2502     \u2502\n\u2502  \u2502 (Append Log)       \u2502  \u2502  (Read-Through)        \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n                         \u2502 Uses Layer 1 APIs\n                         \u25bc\n                 (Composes primitives)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 Core proxy stays small (~10k LOC)"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Pattern plugins are optional (install only what you use)"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Independent evolution (update registry plugin without touching core)"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Community can contribute patterns (not just core team)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Configuration"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"namespaces:\n  - name: iot-devices\n    # Option A: Use primitive (advanced)\n    pattern: keyvalue\n    backend:\n      type: redis\n\n  - name: iot-commands\n    # Option B: Use pattern coordinator (ergonomic)\n    pattern: multicast-registry\n    coordinator_plugin: prism-multicast-registry:v1.2.0\n    backend_slots:\n      registry:\n        type: redis\n      messaging:\n        type: nats\n"})}),"\n",(0,r.jsx)(n.h2,{id:"decision-matrix",children:"Decision Matrix"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Concern"}),(0,r.jsx)(n.th,{children:"Primitives (Layer 1)"}),(0,r.jsx)(n.th,{children:"Patterns (Layer 2)"}),(0,r.jsx)(n.th,{children:"Layered Approach"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Developer Complexity"})}),(0,r.jsx)(n.td,{children:"\u274c High (must compose)"}),(0,r.jsx)(n.td,{children:"\u2705 Low (ergonomic)"}),(0,r.jsx)(n.td,{children:"\u2705 Choice per use case"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"API Clarity"})}),(0,r.jsx)(n.td,{children:"\u26a0\ufe0f Generic terms"}),(0,r.jsx)(n.td,{children:"\u2705 Self-documenting"}),(0,r.jsx)(n.td,{children:"\u2705 Clear at both layers"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Proxy Size"})}),(0,r.jsx)(n.td,{children:"\u2705 Small (6 services)"}),(0,r.jsx)(n.td,{children:"\u274c Large (20+ services)"}),(0,r.jsx)(n.td,{children:"\u2705 Core small, plugins opt-in"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Schema Evolution"})}),(0,r.jsx)(n.td,{children:"\u26a0\ufe0f Affects all use cases"}),(0,r.jsx)(n.td,{children:"\u2705 Localized impact"}),(0,r.jsx)(n.td,{children:"\u2705 Primitives stable, patterns evolve independently"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Flexibility"})}),(0,r.jsx)(n.td,{children:"\u2705 Unlimited composition"}),(0,r.jsx)(n.td,{children:"\u26a0\ufe0f Fixed patterns"}),(0,r.jsx)(n.td,{children:"\u2705 Both available"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Performance"})}),(0,r.jsx)(n.td,{children:"\u2705 Direct control"}),(0,r.jsx)(n.td,{children:"\u26a0\ufe0f Coordinator overhead"}),(0,r.jsx)(n.td,{children:"\u2705 Choose based on need"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Learning Curve"})}),(0,r.jsx)(n.td,{children:"\u274c Steep (distributed systems knowledge)"}),(0,r.jsx)(n.td,{children:"\u2705 Gentle (use-case driven)"}),(0,r.jsx)(n.td,{children:"\u2705 Start simple, grow into advanced"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"comparison-to-alternatives",children:"Comparison to Alternatives"}),"\n",(0,r.jsx)(n.h3,{id:"alternative-a-primitives-only-no-layer-2",children:"Alternative A: Primitives Only (No Layer 2)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": AWS DynamoDB, Redis, etcd"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pros"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Simple implementation"}),"\n",(0,r.jsx)(n.li,{children:"Small API surface"}),"\n",(0,r.jsx)(n.li,{children:"Maximum flexibility"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cons"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u274c High application complexity"}),"\n",(0,r.jsx)(n.li,{children:"\u274c Every team reimplements common patterns"}),"\n",(0,r.jsx)(n.li,{children:"\u274c No semantic guarantees"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Verdict"}),': Too low-level for Prism\'s goal of "push complexity down"']}),"\n",(0,r.jsx)(n.h3,{id:"alternative-b-use-case-apis-only-no-layer-1",children:"Alternative B: Use-Case APIs Only (No Layer 1)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": Twilio (SendMessage), Stripe (CreateCharge), Firebase (specific SDKs)"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pros"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Ergonomic"}),"\n",(0,r.jsx)(n.li,{children:"Self-documenting"}),"\n",(0,r.jsx)(n.li,{children:"Fast onboarding"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cons"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u274c API explosion (100+ services?)"}),"\n",(0,r.jsx)(n.li,{children:"\u274c Inflexible (can't compose novel patterns)"}),"\n",(0,r.jsx)(n.li,{children:"\u274c Large proxy binary"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Verdict"}),": Too rigid for Prism's diverse use cases"]}),"\n",(0,r.jsx)(n.h3,{id:"alternative-c-hybrid-like-kubernetes",children:"Alternative C: Hybrid (Like Kubernetes)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": Kubernetes (core API + CRDs + Operators)"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pros"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 Core stays stable"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Extensible (community patterns)"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Balances simplicity and power"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cons"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u26a0\ufe0f Two-tier documentation complexity"}),"\n",(0,r.jsx)(n.li,{children:"\u26a0\ufe0f Requires clear guidance on when to use each layer"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Verdict"}),": \u2705 ",(0,r.jsx)(n.strong,{children:"Best fit"})," - matches Prism's architecture"]}),"\n",(0,r.jsx)(n.h2,{id:"implementation-roadmap",children:"Implementation Roadmap"}),"\n",(0,r.jsx)(n.h3,{id:"phase-1-poc-validation-weeks-1-6-rfc-018",children:"Phase 1: POC Validation (Weeks 1-6, RFC-018)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implement Layer 1 only"})," (KeyValue, PubSub):"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"POC 1: KeyValue with MemStore"}),"\n",(0,r.jsx)(n.li,{children:"POC 2: KeyValue with Redis"}),"\n",(0,r.jsx)(n.li,{children:"POC 3: PubSub with NATS"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Goal"}),": Prove primitives are sufficient for basic use cases."]}),"\n",(0,r.jsx)(n.h3,{id:"phase-2-pattern-coordinator-prototype-weeks-7-9-rfc-018",children:"Phase 2: Pattern Coordinator Prototype (Weeks 7-9, RFC-018)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implement one Layer 2 pattern"})," (Multicast Registry):"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"POC 4: Multicast Registry coordinator plugin"}),"\n",(0,r.jsx)(n.li,{children:"Validate plugin architecture"}),"\n",(0,r.jsx)(n.li,{children:"Measure coordination overhead"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Goal"}),": Prove pattern coordinators add value without excessive complexity."]}),"\n",(0,r.jsx)(n.h3,{id:"phase-3-expand-pattern-library-post-poc-weeks-12",children:"Phase 3: Expand Pattern Library (Post-POC, Weeks 12+)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Add 3-5 common patterns"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Saga coordinator (distributed transactions)"}),"\n",(0,r.jsx)(n.li,{children:"Event sourcing (append-only log + replay)"}),"\n",(0,r.jsx)(n.li,{children:"Work queue (background jobs)"}),"\n",(0,r.jsx)(n.li,{children:"Cache aside (read-through cache)"}),"\n",(0,r.jsx)(n.li,{children:"Rate limiter (token bucket)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Goal"}),": Cover 80% of use cases with Layer 2 patterns."]}),"\n",(0,r.jsx)(n.h3,{id:"phase-4-community-patterns-months-3-6",children:"Phase 4: Community Patterns (Months 3-6)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Enable third-party pattern plugins"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Pattern plugin SDK"}),"\n",(0,r.jsx)(n.li,{children:"Plugin marketplace"}),"\n",(0,r.jsx)(n.li,{children:"Certification program"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Goal"}),": Ecosystem of community-contributed patterns."]}),"\n",(0,r.jsx)(n.h2,{id:"naming-conventions",children:"Naming Conventions"}),"\n",(0,r.jsx)(n.h3,{id:"layer-1-primitives-use-abstract-nouns",children:"Layer 1: Primitives Use Abstract Nouns"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-protobuf",children:"service KeyValueService { ... }    // Generic storage\nservice PubSubService { ... }      // Generic messaging\nservice QueueService { ... }       // Generic queue\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Rationale"}),': Abstract names signal "building block" nature.']}),"\n",(0,r.jsx)(n.h3,{id:"layer-2-patterns-use-domain-specific-verbs",children:"Layer 2: Patterns Use Domain-Specific Verbs"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-protobuf",children:"service MulticastRegistryService { ... }  // Identity management + broadcast\nservice SagaService { ... }               // Multi-step transactions\nservice EventSourcingService { ... }      // Audit-logged mutations\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Rationale"}),": Specific names signal purpose and use case."]}),"\n",(0,r.jsx)(n.h2,{id:"open-questions",children:"Open Questions"}),"\n",(0,r.jsx)(n.h3,{id:"1-how-do-we-prevent-layer-2-explosion",children:"1. How do we prevent Layer 2 explosion?"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Proposal"}),": Curated pattern library with strict acceptance criteria:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Must solve a common problem (>10% of use cases)"}),"\n",(0,r.jsx)(n.li,{children:"Must provide semantic guarantees over Layer 1 composition"}),"\n",(0,r.jsx)(n.li,{children:"Must have clear ownership and maintenance plan"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example rejection"}),": ",(0,r.jsx)(n.code,{children:"BlogPostService"})," (too specific, just use KeyValue)"]}),"\n",(0,r.jsx)(n.h3,{id:"2-can-layer-2-patterns-compose-with-each-other",children:"2. Can Layer 2 patterns compose with each other?"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": Saga + Multicast Registry?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Proposal"}),": Yes, but patterns should compose via Layer 1 APIs (not directly call each other)."]}),"\n",(0,r.jsx)(n.p,{children:"SagaService (Layer 2)\n\u2193 uses\nKeyValueService (Layer 1)\n\u2191 used by\nMulticastRegistryService (Layer 2)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n**Rationale**: Keeps patterns loosely coupled, evolution independent.\n\n### 3. How do we version Layer 2 patterns independently?\n\n**Proposal**: Pattern coordinators are plugins with semantic versioning:\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"coordinator_plugin: prism-multicast-registry:v1.2.0"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\n**Migration path**:\n- v1.x: Breaking changes \u2192 new major version\n- v2.x: Runs side-by-side with v1.x\n- Namespaces pin to specific version\n\n### 4. Should Layer 1 APIs be Sufficient for All Use Cases?\n\n**Proposal**: Yes - Layer 1 is Turing-complete (can implement any pattern).\n\n**Rationale**: If a pattern can't be built on Layer 1, we have a gap in primitives (not just missing sugar).\n\n**Litmus test**: If Multicast Registry can't be implemented using KeyValue + PubSub, we need to add primitives.\n\n## Success Metrics\n\n### Developer Experience\n\n- \u2705 **Onboarding time**: New developers productive in &lt;1 day (using Layer 2)\n- \u2705 **Code reduction**: Layer 2 reduces boilerplate by &gt;50% vs Layer 1 composition\n- \u2705 **Error clarity**: 90% of errors are self-explanatory without docs\n\n### System Complexity\n\n- \u2705 **Core proxy size**: Remains &lt;15k LOC (only Layer 1)\n- \u2705 **Binary size**: Core &lt;75MB, each pattern plugin &lt;10MB\n- \u2705 **Dependency count**: Core has &lt;20 dependencies\n\n### Pattern Adoption\n\n- \u2705 **Coverage**: Layer 2 patterns cover &gt;80% of use cases\n- \u2705 **Usage split**: 80% of applications use at least one Layer 2 pattern\n- \u2705 **Community**: 5+ community-contributed patterns within 6 months\n\n## Related Documents\n\n- [RFC-014: Layered Data Access Patterns](/rfc/rfc-014-layered-data-access-patterns) - Layer 1 primitives\n- [RFC-017: Multicast Registry Pattern](/rfc/rfc-017-multicast-registry-pattern) - First Layer 2 pattern\n- [RFC-018: POC Implementation Strategy](/rfc/rfc-018-poc-implementation-strategy) - Phased rollout plan\n- [RFC-008: Proxy Plugin Architecture](/rfc/rfc-008-proxy-plugin-architecture) - Plugin system\n\n## Revision History\n\n- 2025-10-09: Initial draft proposing layered API architecture (primitives + patterns)\n\n\n"})})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);