"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[7422],{8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>a});var i=r(6540);const t={},s=i.createContext(t);function l(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(s.Provider,{value:n},e.children)}},8506:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"rust-structured-logging","title":"ADR-021: Rust Structured Logging with Tracing","description":"Context","source":"@site/../docs-cms/adr/021-rust-structured-logging.md","sourceDirName":".","slug":"/rust-structured-logging","permalink":"/prism-data-layer/adr/rust-structured-logging","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/021-rust-structured-logging.md","tags":[{"inline":true,"label":"rust","permalink":"/prism-data-layer/adr/tags/rust"},{"inline":true,"label":"logging","permalink":"/prism-data-layer/adr/tags/logging"},{"inline":true,"label":"observability","permalink":"/prism-data-layer/adr/tags/observability"},{"inline":true,"label":"tracing","permalink":"/prism-data-layer/adr/tags/tracing"},{"inline":true,"label":"debugging","permalink":"/prism-data-layer/adr/tags/debugging"}],"version":"current","sidebarPosition":21,"frontMatter":{"title":"ADR-021: Rust Structured Logging with Tracing","status":"Accepted","date":"2025-10-07T00:00:00.000Z","deciders":"Core Team","tags":["rust","logging","observability","tracing","debugging"]},"sidebar":"adrSidebar","previous":{"title":"ADR-020: Rust Testing Strategy","permalink":"/prism-data-layer/adr/rust-testing-strategy"},"next":{"title":"ADR-022: Dynamic Client Configuration System","permalink":"/prism-data-layer/adr/dynamic-client-configuration"}}');var t=r(4848),s=r(8453);const l={title:"ADR-021: Rust Structured Logging with Tracing",status:"Accepted",date:new Date("2025-10-07T00:00:00.000Z"),deciders:"Core Team",tags:["rust","logging","observability","tracing","debugging"]},a=void 0,c={},o=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Why tracing",id:"why-tracing",level:3},{value:"Architecture",id:"architecture",level:3},{value:"Subscriber Configuration",id:"subscriber-configuration",level:3},{value:"Structured Events",id:"structured-events",level:3},{value:"Span Instrumentation",id:"span-instrumentation",level:3},{value:"OpenTelemetry Integration",id:"opentelemetry-integration",level:3},{value:"Log Levels and Filtering",id:"log-levels-and-filtering",level:3},{value:"Performance: Conditional Logging",id:"performance-conditional-logging",level:3},{value:"Alternatives Considered",id:"alternatives-considered",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Implementation Notes",id:"implementation-notes",level:2},{value:"Dependencies",id:"dependencies",level:3},{value:"Standard Fields",id:"standard-fields",level:3},{value:"Logging Guidelines",id:"logging-guidelines",level:3},{value:"Testing with Tracing",id:"testing-with-tracing",level:3},{value:"References",id:"references",level:2},{value:"Revision History",id:"revision-history",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,t.jsx)(n.p,{children:"Prism proxy requires production-grade logging and observability:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Structured logging for machine parsing"}),"\n",(0,t.jsx)(n.li,{children:"Distributed tracing for request flows"}),"\n",(0,t.jsx)(n.li,{children:"Span context for debugging"}),"\n",(0,t.jsx)(n.li,{children:"High performance (minimal overhead on hot path)"}),"\n",(0,t.jsx)(n.li,{children:"Integration with OpenTelemetry"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"tracing"})})," ecosystem for structured logging and distributed tracing:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"tracing"})," for instrumentation"]})," (spans, events, fields)"]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"tracing-subscriber"})," for collection and formatting"]})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"tracing-opentelemetry"})," for distributed tracing"]})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Structured fields over string formatting"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Span context for request correlation"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"rationale",children:"Rationale"}),"\n",(0,t.jsx)(n.h3,{id:"why-tracing",children:"Why tracing"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"tracing"})," is the Rust standard for structured, contextual logging:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use tracing::{info, warn, error, instrument};\n\n#[instrument(skip(backend), fields(namespace = %namespace))]\nasync fn handle_put(namespace: &str, items: Vec<Item>, backend: &Backend) -> Result<()> {\n    info!(item_count = items.len(), "processing put request");\n\n    match backend.put(namespace, items).await {\n        Ok(_) => {\n            info!("put request completed successfully");\n            Ok(())\n        }\n        Err(e) => {\n            error!(error = %e, "put request failed");\n            Err(e)\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Structured by default"}),": Key-value pairs, not string formatting"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Span context"}),": Automatic request correlation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Zero-cost when disabled"}),": Compile-time filtering"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"OpenTelemetry integration"}),": Distributed tracing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Async-aware"}),": Tracks spans across await points"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Rich ecosystem"}),": formatters, filters, subscribers"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"architecture",children:"Architecture"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Application Code\n      \u2502\n      \u251c\u2500 tracing::info!()      \u2500\u2510\n      \u251c\u2500 tracing::error!()      \u2502 Events\n      \u251c\u2500 #[instrument]          \u2502 + Spans\n      \u2502                         \u2502\n      \u25bc                         \u2502\n   Tracing Subscriber           \u2502\n      \u2502                         \u2502\n      \u251c\u2500 Layer: fmt (console)  \u2500\u2518\n      \u251c\u2500 Layer: json (file)\n      \u2514\u2500 Layer: opentelemetry (Jaeger/Tempo)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"subscriber-configuration",children:"Subscriber Configuration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use tracing_subscriber::{fmt, EnvFilter, layer::SubscriberExt, util::SubscriberInitExt};\n\nfn init_tracing() -> Result<()> {\n    let env_filter = EnvFilter::try_from_default_env()\n        .or_else(|_| EnvFilter::try_new("info"))?;\n\n    let fmt_layer = fmt::layer()\n        .with_target(true)\n        .with_level(true)\n        .json();  // JSON output for production\n\n    // For development: .pretty() or .compact()\n\n    tracing_subscriber::registry()\n        .with(env_filter)\n        .with(fmt_layer)\n        .init();\n\n    Ok(())\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"structured-events",children:"Structured Events"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use tracing::{info, warn, error, debug};\n\n// Structured fields\ninfo!(\n    namespace = "production",\n    item_count = 42,\n    duration_ms = 123,\n    "request completed"\n);\n\n// Error with context\nerror!(\n    error = %err,\n    error_debug = ?err,  // Debug representation\n    namespace = %namespace,\n    retry_count = retries,\n    "backend operation failed"\n);\n\n// Debug with expensive computation (only evaluated if enabled)\ndebug!(\n    items = ?items,  // Debug representation\n    "processing items"\n);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"span-instrumentation",children:"Span Instrumentation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use tracing::{info_span, instrument, Instrument};\n\n// Automatic instrumentation with #[instrument]\n#[instrument(skip(backend), fields(namespace = %req.namespace))]\nasync fn handle_request(req: PutRequest, backend: Arc<Backend>) -> Result<PutResponse> {\n    info!("handling request");\n\n    let result = backend.put(req.items).await?;\n\n    info!(items_written = result.count, "request completed");\n    Ok(PutResponse { success: true })\n}\n\n// Manual span\nasync fn manual_span_example() {\n    let span = info_span!("operation", operation = "migrate");\n    async {\n        info!("starting migration");\n        // ... work ...\n        info!("migration complete");\n    }\n    .instrument(span)\n    .await;\n}\n\n// Span fields can be set dynamically\nlet span = info_span!("request", user_id = tracing::field::Empty);\nspan.record("user_id", &user_id);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"opentelemetry-integration",children:"OpenTelemetry Integration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use opentelemetry::global;\nuse tracing_opentelemetry::OpenTelemetryLayer;\nuse opentelemetry_jaeger::JaegerPipeline;\n\nasync fn init_tracing_with_otel() -> Result<()> {\n    // Configure OpenTelemetry exporter\n    global::set_text_map_propagator(opentelemetry_jaeger::Propagator::new());\n\n    let tracer = opentelemetry_jaeger::new_pipeline()\n        .with_service_name("prism-proxy")\n        .install_batch(opentelemetry::runtime::Tokio)?;\n\n    let otel_layer = OpenTelemetryLayer::new(tracer);\n\n    let fmt_layer = fmt::layer().json();\n\n    tracing_subscriber::registry()\n        .with(EnvFilter::from_default_env())\n        .with(fmt_layer)\n        .with(otel_layer)\n        .init();\n\n    Ok(())\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"log-levels-and-filtering",children:"Log Levels and Filtering"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// Set via environment variable\n// RUST_LOG=prism_proxy=debug,sqlx=warn\n\n// Or programmatically\nlet filter = EnvFilter::new("prism_proxy=debug")\n    .add_directive("sqlx=warn".parse()?)\n    .add_directive("tonic=info".parse()?);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"performance-conditional-logging",children:"Performance: Conditional Logging"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use tracing::Level;\n\n// Only evaluate expensive computation if debug enabled\nif tracing::level_enabled!(Level::DEBUG) {\n    debug!(expensive_data = ?compute_expensive_debug_info(), "debug info");\n}\n\n// Or use span guards for hot paths\nlet _span = info_span!("hot_path").entered();\n// Span only recorded if info level enabled\n'})}),"\n",(0,t.jsx)(n.h3,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"log"})," crate"]})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Pros: Simpler API, widely used"}),"\n",(0,t.jsx)(n.li,{children:"Cons: No span context, no async support, less structured"}),"\n",(0,t.jsx)(n.li,{children:"Rejected: tracing is superior for async and structured logging"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"slog"})})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Pros: Mature, fast, structured"}),"\n",(0,t.jsx)(n.li,{children:"Cons: More complex, less async integration"}),"\n",(0,t.jsx)(n.li,{children:"Rejected: tracing is now the ecosystem standard"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Custom logging"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Pros: Full control"}),"\n",(0,t.jsx)(n.li,{children:"Cons: Complex, reinventing the wheel"}),"\n",(0,t.jsx)(n.li,{children:"Rejected: tracing ecosystem is battle-tested"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,t.jsx)(n.h3,{id:"positive",children:"Positive"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Structured by default"}),": All logs are machine-parsable"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Span context"}),": Automatic request correlation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Zero-cost abstraction"}),": No overhead when disabled"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"OpenTelemetry integration"}),": Distributed tracing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Async-aware"}),": Proper async span tracking"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Rich ecosystem"}),": Many formatters and exporters"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"negative",children:"Negative"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Learning curve"}),": More complex than simple logging"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Verbosity"}),": ",(0,t.jsx)(n.code,{children:"#[instrument]"})," adds code"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Compile times"}),": Heavy macro usage can slow compilation"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"neutral",children:"Neutral"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Must configure subscriber at startup"}),"\n",(0,t.jsx)(n.li,{children:"Requires thoughtful span design"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,t.jsx)(n.h3,{id:"dependencies",children:"Dependencies"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-toml",children:'[dependencies]\ntracing = "0.1"\ntracing-subscriber = { version = "0.3", features = ["json", "env-filter"] }\ntracing-opentelemetry = "0.22"\nopentelemetry = { version = "0.21", features = ["trace"] }\nopentelemetry-jaeger = { version = "0.20", features = ["rt-tokio"] }\n'})}),"\n",(0,t.jsx)(n.h3,{id:"standard-fields",children:"Standard Fields"}),"\n",(0,t.jsx)(n.p,{children:"Always include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"service.name"}),': "prism-proxy"']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"service.version"}),": from Cargo.toml"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"environment"}),': "production", "staging", "development"']}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"fn init_tracing() -> Result<()> {\n    tracing_subscriber::registry()\n        .with(EnvFilter::from_default_env())\n        .with(\n            fmt::layer()\n                .json()\n                .with_current_span(true)\n                .with_span_list(true)\n        )\n        .init();\n\n    Ok(())\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"logging-guidelines",children:"Logging Guidelines"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"DO:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"#[instrument]"})," on handler functions"]}),"\n",(0,t.jsx)(n.li,{children:"Add structured fields, not string interpolation"}),"\n",(0,t.jsx)(n.li,{children:"Use appropriate log levels"}),"\n",(0,t.jsxs)(n.li,{children:["Include error context with ",(0,t.jsx)(n.code,{children:"error = %e"})]}),"\n",(0,t.jsx)(n.li,{children:"Measure duration with spans"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"DON'T:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Log in tight loops (use sample or aggregate)"}),"\n",(0,t.jsx)(n.li,{children:"Log sensitive data (PII, credentials)"}),"\n",(0,t.jsxs)(n.li,{children:["Use string formatting (",(0,t.jsx)(n.code,{children:"format!()"}),") for fields"]}),"\n",(0,t.jsx)(n.li,{children:"Over-instrument (every function doesn't need a span)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"testing-with-tracing",children:"Testing with Tracing"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[cfg(test)]\nmod tests {\n    use tracing_subscriber::layer::SubscriberExt;\n    use tracing_subscriber::util::SubscriberInitExt;\n\n    #[tokio::test]\n    async fn test_with_tracing() {\n        // Initialize test subscriber\n        let subscriber = tracing_subscriber::registry()\n            .with(tracing_subscriber::fmt::layer().pretty());\n\n        tracing::subscriber::with_default(subscriber, || {\n            // Test code with tracing\n        });\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://docs.rs/tracing",children:"tracing documentation"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://docs.rs/tracing-subscriber",children:"tracing-subscriber documentation"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://docs.rs/tracing-opentelemetry",children:"tracing-opentelemetry"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://tokio.rs/tokio/topics/tracing",children:"Tokio Tracing Guide"})}),"\n",(0,t.jsx)(n.li,{children:"ADR-001: Rust for the Proxy"}),"\n",(0,t.jsx)(n.li,{children:"ADR-008: Observability Strategy"}),"\n",(0,t.jsx)(n.li,{children:"ADR-017: Go Structured Logging (parallel Go patterns)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"2025-10-07: Initial draft and acceptance"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);