"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[62600],{28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var s=i(96540);const a={},t=s.createContext(a);function r(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(t.Provider,{value:n},e.children)}},77562:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"adr-033","title":"Capability API for Prism Instance Queries","description":"Context","source":"@site/../docs-cms/adr/adr-033-capability-api.md","sourceDirName":".","slug":"/adr-033","permalink":"/prism-data-layer/adr/adr-033","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/adr-033-capability-api.md","tags":[{"inline":true,"label":"api-design","permalink":"/prism-data-layer/adr/tags/api-design"},{"inline":true,"label":"client-server","permalink":"/prism-data-layer/adr/tags/client-server"},{"inline":true,"label":"versioning","permalink":"/prism-data-layer/adr/tags/versioning"},{"inline":true,"label":"operations","permalink":"/prism-data-layer/adr/tags/operations"}],"version":"current","frontMatter":{"date":"2025-10-08T00:00:00.000Z","deciders":"System","doc_uuid":"6554cf2a-5da2-47a9-9e97-183305216b6c","id":"adr-033","project_id":"prism-data-layer","status":"Proposed","tags":["api-design","client-server","versioning","operations"],"title":"Capability API for Prism Instance Queries"},"sidebar":"adrSidebar","previous":{"title":"ADR-032 Object Storage","permalink":"/prism-data-layer/adr/adr-032"},"next":{"title":"Product/Feature Sharding Strategy \u2022 ADR-034","permalink":"/prism-data-layer/adr/adr-034"}}');var a=i(74848),t=i(28453);const r={date:new Date("2025-10-08T00:00:00.000Z"),deciders:"System",doc_uuid:"6554cf2a-5da2-47a9-9e97-183305216b6c",id:"adr-033",project_id:"prism-data-layer",status:"Proposed",tags:["api-design","client-server","versioning","operations"],title:"Capability API for Prism Instance Queries"},l=void 0,c={},o=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"API Definition",id:"api-definition",level:3},{value:"Usage Patterns",id:"usage-patterns",level:3},{value:"Rationale",id:"rationale",level:2},{value:"Why This Approach?",id:"why-this-approach",level:3},{value:"Netflix&#39;s Experience",id:"netflixs-experience",level:3},{value:"Alternatives Considered",id:"alternatives-considered",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Implementation Notes",id:"implementation-notes",level:2},{value:"Caching Capabilities",id:"caching-capabilities",level:3},{value:"Feature Flag Management",id:"feature-flag-management",level:3},{value:"Backend Capability Discovery",id:"backend-capability-discovery",level:3},{value:"References",id:"references",level:2},{value:"Revision History",id:"revision-history",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,a.jsx)(n.p,{children:"Client applications and admin tools need a way to discover what features, backends, and configurations are supported by a specific Prism instance before attempting to use them. Different Prism deployments may:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Support different backend types (some may have Kafka, others may not)"}),"\n",(0,a.jsx)(n.li,{children:"Have different versions of the data abstraction APIs"}),"\n",(0,a.jsx)(n.li,{children:"Support different cache strategies or consistency levels"}),"\n",(0,a.jsx)(n.li,{children:"Have different operational limits (max RPS, max connections, etc.)"}),"\n",(0,a.jsx)(n.li,{children:"Enable/disable specific features (shadow traffic, protocol recording, etc.)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Without a capability discovery mechanism, clients must either:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Hard-code assumptions"})," about what's available (brittle, breaks across environments)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Try and fail"})," with requests to unsupported backends (poor UX, unnecessary errors)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Rely on out-of-band configuration"})," (deployment-specific client configs, hard to maintain)"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Netflix's Data Gateway learned this lesson: different clusters support different backends and configurations. Their solution was to provide runtime capability queries."}),"\n",(0,a.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Implement a gRPC Capability API"})," that allows clients to query Prism instance capabilities at runtime."]}),"\n",(0,a.jsx)(n.p,{children:"The API will expose:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Supported Backends"}),": List of available backend types (postgres, redis, kafka, etc.)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"API Version"}),": Protobuf schema version and supported operations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Feature Flags"}),": Enabled/disabled features (shadow traffic, caching, protocol recording)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Operational Limits"}),": Max RPS per namespace, max connections, rate limits"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Backend-Specific Capabilities"}),": Per-backend features (e.g., Redis supports vector search)"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"api-definition",children:"API Definition"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-protobuf",children:'syntax = "proto3";\n\npackage prism.admin;\n\nservice CapabilityService {\n  // Get overall Prism instance capabilities\n  rpc GetCapabilities(GetCapabilitiesRequest) returns (GetCapabilitiesResponse);\n\n  // Get backend-specific capabilities\n  rpc GetBackendCapabilities(GetBackendCapabilitiesRequest) returns (GetBackendCapabilitiesResponse);\n}\n\nmessage GetCapabilitiesRequest {\n  // Optional: request capabilities as of a specific API version\n  optional string api_version = 1;\n}\n\nmessage GetCapabilitiesResponse {\n  // Prism instance metadata\n  string instance_id = 1;\n  string version = 2;  // e.g., "0.3.0"\n  string api_version = 3;  // e.g., "v1alpha1"\n\n  // Supported backends\n  repeated string backends = 4;  // ["postgres", "redis", "kafka", "nats", "clickhouse"]\n\n  // Feature flags\n  map<string, bool> features = 5;\n  // Example: {"shadow_traffic": true, "protocol_recording": false, "cache_strategies": true}\n\n  // Operational limits\n  OperationalLimits limits = 6;\n\n  // Supported data access patterns\n  repeated string patterns = 7;  // ["keyvalue", "stream", "timeseries", "graph"]\n}\n\nmessage OperationalLimits {\n  int64 max_namespaces = 1;\n  int64 max_rps_per_namespace = 2;\n  int64 max_connections_per_namespace = 3;\n  int64 max_payload_size_bytes = 4;\n  int64 max_stream_duration_seconds = 5;\n}\n\nmessage GetBackendCapabilitiesRequest {\n  string backend = 1;  // "redis", "postgres", etc.\n}\n\nmessage GetBackendCapabilitiesResponse {\n  string backend = 1;\n  bool available = 2;\n  string version = 3;  // Backend client library version\n\n  // Supported operations for this backend\n  repeated string operations = 4;  // ["get", "set", "mget", "scan"]\n\n  // Backend-specific features\n  map<string, bool> features = 5;\n  // Example for Redis: {"vector_search": true, "geo_queries": false, "streams": true}\n\n  // Backend-specific limits\n  map<string, int64> limits = 6;\n  // Example: {"max_key_size": 512000, "max_value_size": 104857600}\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"usage-patterns",children:"Usage Patterns"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Client Discovery on Startup"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'// Client queries capabilities on initialization\nlet caps = client.get_capabilities().await?;\n\nif !caps.backends.contains(&"redis".to_string()) {\n    return Err("Redis backend not available in this environment".into());\n}\n\nif !caps.features.get("shadow_traffic").unwrap_or(&false) {\n    warn!("Shadow traffic not supported, skipping migration setup");\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Admin CLI Feature Detection"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# CLI checks capabilities before presenting commands\nprism backend list  # Only shows available backends\n\n# Attempting unsupported operation fails gracefully\nprism shadow enable my-ns\n# Error: Shadow traffic not enabled in this Prism instance\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Version Compatibility Check"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# Python client checks API compatibility\ncaps = await client.get_capabilities()\nif caps.api_version != "v1alpha1":\n    raise ValueError(f"Client expects v1alpha1, server has {caps.api_version}")\n'})}),"\n",(0,a.jsx)(n.h2,{id:"rationale",children:"Rationale"}),"\n",(0,a.jsx)(n.h3,{id:"why-this-approach",children:"Why This Approach?"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Runtime Discovery"}),": Clients adapt to environment without redeployment"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Graceful Degradation"}),": Missing features can be handled gracefully"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Operational Visibility"}),": Admins can query what's available before creating namespaces"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Version Negotiation"}),": Clients can detect API mismatches early"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Multi-Tenancy Support"}),": Different Prism instances can have different capabilities"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"netflixs-experience",children:"Netflix's Experience"}),"\n",(0,a.jsx)(n.p,{children:"Netflix's Data Gateway exposes similar capability information:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Which data stores are available in a cluster"}),"\n",(0,a.jsx)(n.li,{children:"What consistency levels are supported"}),"\n",(0,a.jsx)(n.li,{children:"Regional deployment configurations"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This enabled them to:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Run different configurations per region (US, EU, APAC)"}),"\n",(0,a.jsx)(n.li,{children:"Gradually roll out new backends without breaking clients"}),"\n",(0,a.jsx)(n.li,{children:"Provide clear error messages when unsupported features are used"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Static Configuration Files"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Pros: Simple, no API needed"}),"\n",(0,a.jsx)(n.li,{children:"Cons: Out-of-band, must be distributed separately, version skew issues"}),"\n",(0,a.jsx)(n.li,{children:"Rejected because: Doesn't scale across environments, prone to drift"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Try-and-Fail Discovery"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Pros: No extra API needed"}),"\n",(0,a.jsx)(n.li,{children:"Cons: Poor UX, generates unnecessary errors, harder to debug"}),"\n",(0,a.jsx)(n.li,{children:"Rejected because: Creates operational noise, confusing error messages"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"OpenAPI/Swagger-Style Schema Introspection"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Pros: Standard approach for REST APIs"}),"\n",(0,a.jsx)(n.li,{children:"Cons: gRPC already has reflection, but it's schema-level not capability-level"}),"\n",(0,a.jsx)(n.li,{children:"Rejected because: Need runtime instance state, not just schema definition"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,a.jsx)(n.h3,{id:"positive",children:"Positive"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Clients can adapt to environment capabilities at runtime"}),"\n",(0,a.jsx)(n.li,{children:'Better error messages ("feature not available" vs "unknown error")'}),"\n",(0,a.jsx)(n.li,{children:"Enables gradual rollout of new features across environments"}),"\n",(0,a.jsx)(n.li,{children:"Admin tools can show only relevant commands"}),"\n",(0,a.jsx)(n.li,{children:"Easier to maintain multi-region deployments with different capabilities"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"negative",children:"Negative"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Additional API surface to maintain"}),"\n",(0,a.jsx)(n.li,{children:"Capability response must stay backward compatible"}),"\n",(0,a.jsx)(n.li,{children:"Clients need to handle varying capabilities (more complex logic)"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"neutral",children:"Neutral"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Feature flags become first-class API concept (good governance needed)"}),"\n",(0,a.jsx)(n.li,{children:"Need to document which capabilities are stable vs experimental"}),"\n",(0,a.jsx)(n.li,{children:"Capability API itself needs versioning strategy"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,a.jsx)(n.h3,{id:"caching-capabilities",children:"Caching Capabilities"}),"\n",(0,a.jsx)(n.p,{children:"Clients should cache capability responses:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"pub struct PrismClient {\n    capabilities: Arc<RwLock<Option<Capabilities>>>,\n    capabilities_ttl: Duration,\n}\n\nimpl PrismClient {\n    pub async fn get_capabilities(&self) -> Result<Capabilities> {\n        // Check cache first\n        if let Some(caps) = self.capabilities.read().await.as_ref() {\n            if caps.fetched_at.elapsed() < self.capabilities_ttl {\n                return Ok(caps.clone());\n            }\n        }\n\n        // Fetch from server\n        let caps = self.stub.get_capabilities(GetCapabilitiesRequest {}).await?;\n\n        // Update cache\n        *self.capabilities.write().await = Some(caps.clone());\n\n        Ok(caps)\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Cache TTL"}),": 5 minutes (capabilities rarely change at runtime)"]}),"\n",(0,a.jsx)(n.h3,{id:"feature-flag-management",children:"Feature Flag Management"}),"\n",(0,a.jsx)(n.p,{children:"Feature flags should be documented:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'# config/features.yaml\nfeatures:\n  shadow_traffic:\n    enabled: true\n    description: "Enable shadow traffic for zero-downtime migrations"\n    stability: stable\n    since: "0.2.0"\n\n  protocol_recording:\n    enabled: false\n    description: "Record request/response for debugging (PII concerns)"\n    stability: experimental\n    since: "0.3.0"\n\n  cache_strategies:\n    enabled: true\n    description: "Support RFC-007 cache strategies"\n    stability: stable\n    since: "0.2.0"\n'})}),"\n",(0,a.jsx)(n.h3,{id:"backend-capability-discovery",children:"Backend Capability Discovery"}),"\n",(0,a.jsx)(n.p,{children:"Backend plugins report their capabilities during initialization:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'impl BackendPlugin for RedisPlugin {\n    async fn initialize(&mut self, req: InitializeRequest) -> Result<InitializeResponse> {\n        // ... initialization ...\n\n        Ok(InitializeResponse {\n            success: true,\n            plugin_version: "0.1.0".to_string(),\n            supported_operations: vec!["get", "set", "mget", "scan"],\n            features: hashmap! {\n                "vector_search" => true,\n                "geo_queries" => false,\n                "streams" => true,\n            },\n            limits: hashmap! {\n                "max_key_size" => 512_000,\n                "max_value_size" => 100 * 1024 * 1024,  // 100MB\n            },\n            ..Default::default()\n        })\n    }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Proxy aggregates plugin capabilities and exposes via Capability API."}),"\n",(0,a.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"RFC-003: Admin gRPC API (where Capability API lives)"}),"\n",(0,a.jsx)(n.li,{children:"RFC-008: Proxy Plugin Architecture (backend capability reporting)"}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"/netflix/netflix-scale",children:"Netflix Data Gateway Multi-Region"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://github.com/grpc/grpc/blob/master/doc/server-reflection.md",children:"gRPC Server Reflection"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://kubernetes.io/docs/reference/using-api/api-concepts/#discovery",children:"Kubernetes API Discovery"})}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"2025-10-08: Initial draft proposing capability API based on Netflix lessons"}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);