"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[5274],{6339:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"adr-031","title":"TTL Defaults for Client-Configured Data","description":"Context","source":"@site/../docs-cms/adr/adr-031-ttl-defaults-client-data.md","sourceDirName":".","slug":"/adr-031","permalink":"/prism-data-layer/adr/adr-031","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/adr-031-ttl-defaults-client-data.md","tags":[{"inline":true,"label":"data-lifecycle","permalink":"/prism-data-layer/adr/tags/data-lifecycle"},{"inline":true,"label":"cache","permalink":"/prism-data-layer/adr/tags/cache"},{"inline":true,"label":"cleanup","permalink":"/prism-data-layer/adr/tags/cleanup"},{"inline":true,"label":"operations","permalink":"/prism-data-layer/adr/tags/operations"}],"version":"current","frontMatter":{"date":"2025-10-08T00:00:00.000Z","deciders":"System Architecture Team","doc_uuid":"d7f3ac9f-862f-4093-ace3-6dfdbe8a4157","id":"adr-031","project_id":"prism-data-layer","sidebar_label":"ADR-031 TTL Defaults","status":"Accepted","tags":["data-lifecycle","cache","cleanup","operations"],"title":"TTL Defaults for Client-Configured Data"},"sidebar":"adrSidebar","previous":{"title":"Schema Recording with Protobuf Tagging \u2022 ADR-030","permalink":"/prism-data-layer/adr/adr-030"},"next":{"title":"ADR-032 Object Storage","permalink":"/prism-data-layer/adr/adr-032"}}');var s=t(74848),a=t(28453);const r={date:new Date("2025-10-08T00:00:00.000Z"),deciders:"System Architecture Team",doc_uuid:"d7f3ac9f-862f-4093-ace3-6dfdbe8a4157",id:"adr-031",project_id:"prism-data-layer",sidebar_label:"ADR-031 TTL Defaults",status:"Accepted",tags:["data-lifecycle","cache","cleanup","operations"],title:"TTL Defaults for Client-Configured Data"},l="ADR-031: TTL Defaults for Client-Configured Dynamic Data",d={},c=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Principles",id:"principles",level:3},{value:"TTL Default Strategy",id:"ttl-default-strategy",level:2},{value:"Default TTL Values by Pattern",id:"default-ttl-values-by-pattern",level:3},{value:"TTL Precedence Rules",id:"ttl-precedence-rules",level:3}];function o(e){const n={code:"code",duration:"duration",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"adr-031-ttl-defaults-for-client-configured-dynamic-data",children:"ADR-031: TTL Defaults for Client-Configured Dynamic Data"})}),"\n",(0,s.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,s.jsx)(n.p,{children:"Prism manages dynamic data on behalf of clients across multiple backends (Redis cache, session storage, temporary records, etc.). Without proper Time-To-Live (TTL) policies, this data accumulates indefinitely, leading to:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Storage Exhaustion"}),": Backends run out of disk/memory"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance Degradation"}),": Large datasets slow down queries and operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cost Overruns"}),": Cloud storage costs grow unchecked"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Stale Data"}),": Old data persists beyond its useful lifetime"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Operational Burden"}),": Manual cleanup becomes necessary"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Clients may not always specify TTL values when creating dynamic data, either due to oversight, lack of domain knowledge, or API design that doesn't enforce it."}),"\n",(0,s.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"We will enforce TTL policies on all client-configured dynamic data with sensible defaults when clients do not specify explicit TTL values."})}),"\n",(0,s.jsx)(n.h3,{id:"principles",children:"Principles"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"TTL by Default"}),": Every piece of dynamic data MUST have a TTL"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Client Override"}),": Clients can specify custom TTL values"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Backend-Specific Defaults"}),": Different backends have different appropriate default TTLs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Pattern-Specific Defaults"}),": Data access patterns inform default TTL values"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Monitoring"}),": Track TTL distribution and expiration rates"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Documentation"}),": Make defaults visible and well-documented"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"ttl-default-strategy",children:"TTL Default Strategy"}),"\n",(0,s.jsx)(n.h3,{id:"default-ttl-values-by-pattern",children:"Default TTL Values by Pattern"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Pattern"}),(0,s.jsx)(n.th,{children:"Backend"}),(0,s.jsx)(n.th,{children:"Default TTL"}),(0,s.jsx)(n.th,{children:"Rationale"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Cache"})}),(0,s.jsx)(n.td,{children:"Redis"}),(0,s.jsx)(n.td,{children:"15 minutes"}),(0,s.jsx)(n.td,{children:"Most cache hits occur within minutes"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Session"})}),(0,s.jsx)(n.td,{children:"Redis"}),(0,s.jsx)(n.td,{children:"24 hours"}),(0,s.jsx)(n.td,{children:"Typical user session lifetime"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"PubSub"})}),(0,s.jsx)(n.td,{children:"NATS/Kafka"}),(0,s.jsx)(n.td,{children:"N/A"}),(0,s.jsx)(n.td,{children:"Messages consumed immediately"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"KeyValue"})}),(0,s.jsx)(n.td,{children:"PostgreSQL"}),(0,s.jsx)(n.td,{children:"30 days"}),(0,s.jsx)(n.td,{children:"Application data with moderate longevity"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"TimeSeries"})}),(0,s.jsx)(n.td,{children:"ClickHouse"}),(0,s.jsx)(n.td,{children:"90 days"}),(0,s.jsx)(n.td,{children:"Observability data retention standard"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Graph"})}),(0,s.jsx)(n.td,{children:"Neptune"}),(0,s.jsx)(n.td,{children:"Infinite"}),(0,s.jsx)(n.td,{children:"Relationships typically long-lived"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Vector Search"})}),(0,s.jsx)(n.td,{children:"Redis VSS"}),(0,s.jsx)(n.td,{children:"90 days"}),(0,s.jsx)(n.td,{children:"Embedding data for ML/search"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Object Store"})}),(0,s.jsx)(n.td,{children:"MinIO"}),(0,s.jsx)(n.td,{children:"90 days"}),(0,s.jsx)(n.td,{children:"Blob storage for artifacts/uploads"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"ttl-precedence-rules",children:"TTL Precedence Rules"}),"\n",(0,s.jsx)(n.p,{children:"Client-Specified TTL\n\u2193 (if not provided)\nNamespace-Level Default TTL\n\u2193 (if not configured)\nPattern-Specific Default TTL\n\u2193 (fallback)\nSystem-Wide Default TTL (30 days)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n### Implementation in Protobuf\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"// Client-specified TTL in requests\nmessage SetRequest {\nstring namespace = 1;\nstring key = 2;\nbytes value = 3;"}),"\n",(0,s.jsx)(n.p,{children:"// Optional: Client-specified TTL in seconds\n// If not provided, uses namespace or pattern defaults\noptional int64 ttl_seconds = 4;"}),"\n",(0,s.jsx)(n.p,{children:"// Optional: Explicit infinite TTL (use with caution)\noptional bool no_expiration = 5;\n}"}),"\n",(0,s.jsx)(n.p,{children:"// Namespace configuration with TTL defaults\nmessage NamespaceConfig {\nstring name = 1;\nstring backend = 2;\nstring pattern = 3;"}),"\n",(0,s.jsx)(n.p,{children:"// Namespace-level TTL override (applies to all operations)\noptional int64 default_ttl_seconds = 4;"}),"\n",(0,s.jsx)(n.p,{children:"// Allow clients to specify no expiration\nbool allow_infinite_ttl = 5 [default = false];"}),"\n",(0,s.jsx)(n.p,{children:"// Warn when data approaches expiration\nbool enable_ttl_warnings = 6 [default = true];\n}"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n### Configuration YAML Example\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"namespaces:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"name: user-sessions\nbackend: redis\npattern: cache\ndefault_ttl_seconds: 86400  # 24 hours\nallow_infinite_ttl: false"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"name: analytics-events\nbackend: clickhouse\npattern: timeseries\ndefault_ttl_seconds: 7776000  # 90 days\nenable_ttl_warnings: true"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"name: permanent-records\nbackend: postgres\npattern: keyvalue\nallow_infinite_ttl: true  # Explicit opt-in for infinite TTL"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n## Backend-Specific Implementation\n\n### Redis (Cache, Session, Vector)\n\n"})}),"\n",(0,s.jsxs)(n.p,{children:["// Rust implementation in Prism proxy\nasync fn set_with_ttl(\n&self,\nkey: &str,\nvalue: &[u8],\nttl: Option",(0,s.jsx)(n.duration,{children:",\nconfig: &NamespaceConfig,\n) -> Result<()> {\nlet effective_ttl = ttl\n.or(config.default_ttl)\n.unwrap_or(DEFAULT_CACHE_TTL); // 15 minutes"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"self.redis\n    .set_ex(key, value, effective_ttl.as_secs() as usize)\n    .await\n"})}),"\n",(0,s.jsx)(n.p,{children:"}"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n### PostgreSQL (KeyValue)\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"-- Table schema with TTL support\nCREATE TABLE keyvalue (\nnamespace VARCHAR(255) NOT NULL,\nkey VARCHAR(255) NOT NULL,\nvalue BYTEA NOT NULL,\ncreated_at TIMESTAMPTZ DEFAULT NOW(),\nexpires_at TIMESTAMPTZ NOT NULL, -- Always required\nPRIMARY KEY (namespace, key)\n);"}),"\n",(0,s.jsx)(n.p,{children:"-- Index for efficient TTL-based cleanup\nCREATE INDEX idx_keyvalue_expires ON keyvalue(expires_at)\nWHERE expires_at IS NOT NULL;"}),"\n",(0,s.jsx)(n.p,{children:"-- Background job to delete expired records\nDELETE FROM keyvalue\nWHERE expires_at < NOW()\nAND expires_at IS NOT NULL;"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n### ClickHouse (TimeSeries)\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"-- ClickHouse table with TTL\nCREATE TABLE events (\ntimestamp DateTime64(9),\nevent_type LowCardinality(String),\nnamespace LowCardinality(String),\npayload String\n)\nENGINE = MergeTree()\nPARTITION BY toYYYYMMDD(timestamp)\nORDER BY (namespace, event_type, timestamp)\nTTL timestamp + INTERVAL 90 DAY; -- Default 90 days"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n### MinIO (Object Storage)\n\n"})}),"\n",(0,s.jsx)(n.h1,{id:"minio-lifecycle-policy",children:"MinIO lifecycle policy"}),"\n",(0,s.jsx)(n.p,{children:'lifecycle_config = {\n"Rules": [\n{\n"ID": "default-ttl",\n"Status": "Enabled",\n"Expiration": {\n"Days": 90  # Default 90 days\n},\n"Filter": {\n"Prefix": "tmp/"  # Apply to temporary objects\n}\n}\n]\n}\nminio_client.set_bucket_lifecycle("prism-objects", lifecycle_config)'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n## Monitoring and Observability\n\n### Metrics\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"message TTLMetrics {\nstring namespace = 1;"}),"\n",(0,s.jsx)(n.p,{children:"// TTL distribution\nint64 items_with_ttl = 2;\nint64 items_without_ttl = 3;  // Should be 0\nint64 items_infinite_ttl = 4;"}),"\n",(0,s.jsx)(n.p,{children:"// Expiration stats\nint64 expired_last_hour = 5;\nint64 expiring_next_hour = 6;\nint64 expiring_next_day = 7;"}),"\n",(0,s.jsx)(n.p,{children:"// Storage impact\nint64 total_bytes = 8;\nint64 bytes_to_expire_soon = 9;\n}"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n### Alerting Rules\n\n"})}),"\n",(0,s.jsx)(n.h1,{id:"prometheus-alert-rules",children:"Prometheus alert rules"}),"\n",(0,s.jsx)(n.p,{children:"groups:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["name: ttl_alerts\nrules:\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:'alert: HighInfiniteTTLRatio\nexpr: |\n(prism_items_infinite_ttl / prism_items_total) > 0.1\nfor: 1h\nannotations:\nsummary: "More than 10% of data has infinite TTL"'}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:'alert: StorageGrowthUnbounded\nexpr: |\nrate(prism_total_bytes[1d]) > 0 AND\nrate(prism_expired_bytes[1d]) == 0\nfor: 6h\nannotations:\nsummary: "Storage growing without expiration"'}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n### Admin CLI Commands\n\n"})}),"\n",(0,s.jsx)(n.h1,{id:"show-ttl-distribution-for-namespace",children:"Show TTL distribution for namespace"}),"\n",(0,s.jsx)(n.p,{children:"prism namespace describe my-app --show-ttl-stats"}),"\n",(0,s.jsx)(n.h1,{id:"list-items-expiring-soon",children:"List items expiring soon"}),"\n",(0,s.jsx)(n.p,{children:"prism data list my-app --expiring-within 24h"}),"\n",(0,s.jsx)(n.h1,{id:"override-ttl-for-specific-keys",children:"Override TTL for specific keys"}),"\n",(0,s.jsx)(n.p,{children:"prism data set-ttl my-app key123 --ttl 1h"}),"\n",(0,s.jsx)(n.h1,{id:"disable-expiration-for-specific-item-requires-permission",children:"Disable expiration for specific item (requires permission)"}),"\n",(0,s.jsx)(n.p,{children:"prism data set-ttl my-app key456 --infinite"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n## Client SDK Examples\n\n### Python SDK\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"from prism_sdk import PrismClient"}),"\n",(0,s.jsx)(n.p,{children:'client = PrismClient(namespace="user-sessions")'}),"\n",(0,s.jsx)(n.h1,{id:"explicit-ttl-recommended",children:"Explicit TTL (recommended)"}),"\n",(0,s.jsx)(n.p,{children:'client.set("session:abc123", session_data, ttl_seconds=3600)'}),"\n",(0,s.jsx)(n.h1,{id:"uses-namespace-default-24-hours-for-sessions",children:"Uses namespace default (24 hours for sessions)"}),"\n",(0,s.jsx)(n.p,{children:'client.set("session:def456", session_data)'}),"\n",(0,s.jsx)(n.h1,{id:"infinite-ttl-requires-namespace-config-allow_infinite_ttltrue",children:"Infinite TTL (requires namespace config: allow_infinite_ttl=true)"}),"\n",(0,s.jsx)(n.p,{children:'client.set("permanent:record", data, no_expiration=True)'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n### Go SDK\n\n"})}),"\n",(0,s.jsx)(n.p,{children:'client := prism.NewClient("user-sessions")'}),"\n",(0,s.jsx)(n.p,{children:'// Explicit TTL\nclient.Set(ctx, "session:abc123", sessionData,\nprism.WithTTL(1*time.Hour))'}),"\n",(0,s.jsx)(n.p,{children:'// Uses namespace default\nclient.Set(ctx, "session:def456", sessionData)'}),"\n",(0,s.jsx)(n.p,{children:'// Infinite TTL (opt-in required)\nclient.Set(ctx, "permanent:record", data,\nprism.WithNoExpiration())'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:'\n## Migration Path\n\n### Phase 1: Audit and Baseline (Week 1)\n\n1. **Audit existing data**: Identify data without TTL\n2. **Baseline metrics**: Measure current storage usage and growth rates\n3. **Document patterns**: Map data types to appropriate TTL ranges\n\n### Phase 2: Implement Defaults (Week 2-3)\n\n1. **Add protobuf fields**: `ttl_seconds`, `no_expiration`\n2. **Update namespace configs**: Set pattern-specific defaults\n3. **Backend implementations**: Apply TTL at storage layer\n4. **Generate SDKs**: Update client libraries with TTL support\n\n### Phase 3: Enforcement and Monitoring (Week 4)\n\n1. **Enable TTL enforcement**: All new data gets TTL\n2. **Backfill existing data**: Apply default TTL to legacy data\n3. **Deploy monitoring**: Grafana dashboards, Prometheus alerts\n4. **Documentation**: Update API docs and client guides\n\n### Phase 4: Optimization (Ongoing)\n\n1. **Review TTL distributions**: Adjust defaults based on usage\n2. **Client feedback**: Refine TTL ranges per use case\n3. **Cost analysis**: Track storage cost reductions\n4. **Performance**: Measure impact on backend performance\n\n## Consequences\n\n### Positive\n\n- **Bounded Storage**: Data automatically expires, preventing unbounded growth\n- **Lower Costs**: Reduced storage requirements, especially in cloud environments\n- **Better Performance**: Smaller datasets improve query and scan performance\n- **Operational Safety**: No more manual cleanup scripts or emergency interventions\n- **Clear Expectations**: Clients understand data lifecycle from the start\n\n### Negative\n\n- **Breaking Change**: Existing clients may rely on infinite TTL behavior\n- **Migration Effort**: Backfilling TTL on existing data requires careful planning\n- **Complexity**: TTL precedence rules and overrides add API surface area\n- **Edge Cases**: Some use cases genuinely need infinite TTL (configuration, schemas)\n\n### Mitigations\n\n1. **Gradual Rollout**: Enable TTL enforcement gradually, namespace by namespace\n2. **Opt-In Infinite TTL**: Require explicit configuration for no-expiration data\n3. **Warning Period**: Emit warnings before enforcing TTL on existing namespaces\n4. **Documentation**: Comprehensive guides and migration playbooks\n5. **Client Support**: SDK helpers for common TTL patterns\n\n## Alternatives Considered\n\n### Alternative 1: Manual Cleanup Scripts\n\n**Approach**: Rely on periodic batch jobs to clean up old data.\n\n**Rejected because**:\n- Reactive rather than proactive\n- Requires custom logic per backend\n- Risk of deleting wrong data\n- Operational burden\n\n### Alternative 2: Infinite TTL by Default\n\n**Approach**: Default to no expiration, require clients to opt-in to TTL.\n\n**Rejected because**:\n- Clients often forget to set TTL\n- Storage grows unbounded\n- Contradicts "safe by default" principle\n\n### Alternative 3: Separate TTL Service\n\n**Approach**: Build a standalone service to manage TTL across backends.\n\n**Rejected because**:\n- Additional operational complexity\n- Backends already support TTL natively\n- Adds latency to data operations\n\n## Related ADRs\n\n- ADR-010: Redis Integration (Cache pattern TTL)\n- ADR-015: PostgreSQL Integration (KeyValue pattern TTL)\n- ADR-020: ClickHouse Integration (TimeSeries TTL)\n- ADR-032: Object Storage Pattern (Blob storage TTL) *(Pending)*\n\n## References\n\n- [Redis EXPIRE command](https://redis.io/commands/expire/)\n- [PostgreSQL DELETE with TTL](https://wiki.postgresql.org/wiki/Deleting_expired_rows)\n- [ClickHouse TTL](https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree#table_engine-mergetree-ttl)\n- [MinIO Lifecycle Management](https://min.io/docs/minio/linux/administration/object-management/lifecycle-management.html)\n- [AWS DynamoDB TTL](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/TTL.html)\n\n## Appendix: Default TTL Reference Table\n\n| Use Case                    | Pattern      | Backend      | Suggested TTL  |\n|-----------------------------|--------------|--------------|----------------|\n| HTTP session storage        | Cache        | Redis        | 24 hours       |\n| API response cache          | Cache        | Redis        | 5-15 minutes   |\n| User preferences            | KeyValue     | PostgreSQL   | Infinite       |\n| Temporary upload tokens     | Cache        | Redis        | 1 hour         |\n| Observability metrics       | TimeSeries   | ClickHouse   | 90 days        |\n| Application logs            | TimeSeries   | ClickHouse   | 30 days        |\n| ML feature vectors          | Vector       | Redis VSS    | 90 days        |\n| User profile cache          | Cache        | Redis        | 1 hour         |\n| Rate limiting counters      | Cache        | Redis        | 1 minute       |\n| Uploaded file artifacts     | Object Store | MinIO        | 90 days        |\n| Build artifacts (CI/CD)     | Object Store | MinIO        | 30 days        |\n| Database connection pool    | N/A          | Internal     | 10 minutes     |\n\n---\n\n**Status**: Accepted\n**Next Steps**:\n1. Update namespace configuration schema with TTL fields\n2. Implement TTL defaults in proxy for each backend\n3. Add TTL metrics to monitoring dashboards\n4. Document TTL best practices in client SDK guides\n\n'})})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var i=t(96540);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);