"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[3089],{7780:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"rfc-008","title":"RFC-008 Proxy Plugin Architecture","description":"Status: Draft","source":"@site/../docs-cms/rfcs/RFC-008-proxy-plugin-architecture.md","sourceDirName":".","slug":"/rfc-008","permalink":"/prism-data-layer/rfc/rfc-008","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/rfcs/RFC-008-proxy-plugin-architecture.md","tags":[],"version":"current","frontMatter":{"id":"rfc-008","title":"RFC-008 Proxy Plugin Architecture","sidebar_label":"RFC-008 Plugin Architecture","status":"Draft"},"sidebar":"rfcSidebar","previous":{"title":"RFC-007 Cache Strategies","permalink":"/prism-data-layer/rfc/rfc-007"},"next":{"title":"Request for Comments (RFCs)","permalink":"/prism-data-layer/rfc/"}}');var r=i(4848),t=i(8453);const l={id:"rfc-008",title:"RFC-008 Proxy Plugin Architecture",sidebar_label:"RFC-008 Plugin Architecture",status:"Draft"},a="RFC-008: Proxy Plugin Architecture and Responsibility Separation",c={},o=[{value:"Abstract",id:"abstract",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Current Challenges",id:"current-challenges",level:3},{value:"Desired State",id:"desired-state",level:3},{value:"Goals",id:"goals",level:2},{value:"Non-Goals",id:"non-goals",level:2},{value:"Responsibility Separation",id:"responsibility-separation",level:2},{value:"Proxy Core Responsibilities",id:"proxy-core-responsibilities",level:3},{value:"Backend Plugin Responsibilities",id:"backend-plugin-responsibilities",level:3},{value:"What Plugins Do NOT Do",id:"what-plugins-do-not-do",level:3},{value:"Plugin Interface",id:"plugin-interface",level:2},{value:"gRPC-Based Plugin Protocol",id:"grpc-based-plugin-protocol",level:3},{value:"Architecture Diagram",id:"architecture-diagram",level:2},{value:"Plugin Deployment Models",id:"plugin-deployment-models",level:2},{value:"Model 1: In-Process Plugins (Shared Library)",id:"model-1-in-process-plugins-shared-library",level:3},{value:"Model 2: Sidecar Plugins (Separate Process)",id:"model-2-sidecar-plugins-separate-process",level:3},{value:"Model 3: Remote Plugins (External Service)",id:"model-3-remote-plugins-external-service",level:3},{value:"Secure Channels",id:"secure-channels",level:2},{value:"Channel Security Requirements",id:"channel-security-requirements",level:3},{value:"Unix Socket Security (Sidecar Model)",id:"unix-socket-security-sidecar-model",level:3},{value:"gRPC Channel Security (Remote Model)",id:"grpc-channel-security-remote-model",level:3},{value:"Configuration Flow",id:"configuration-flow",level:2},{value:"Proxy \u2192 Plugin Configuration",id:"proxy--plugin-configuration",level:3},{value:"Configuration Example",id:"configuration-example",level:3},{value:"Hot-Reloading Plugins",id:"hot-reloading-plugins",level:2},{value:"Reload Sequence",id:"reload-sequence",level:3},{value:"Reload Trigger",id:"reload-trigger",level:3},{value:"Metrics and Observability",id:"metrics-and-observability",level:2},{value:"Plugin-Reported Metrics",id:"plugin-reported-metrics",level:3},{value:"Proxy Aggregation",id:"proxy-aggregation",level:3},{value:"Testing Strategy",id:"testing-strategy",level:2},{value:"Plugin Testing",id:"plugin-testing",level:3},{value:"Integration Testing with Mock Proxy",id:"integration-testing-with-mock-proxy",level:3},{value:"Migration Path",id:"migration-path",level:2},{value:"Phase 1: Plugin Interface Definition (Week 1-2)",id:"phase-1-plugin-interface-definition-week-1-2",level:3},{value:"Phase 2: First Plugin (PostgreSQL) (Week 3-4)",id:"phase-2-first-plugin-postgresql-week-3-4",level:3},{value:"Phase 3: Sidecar Model (Week 5-6)",id:"phase-3-sidecar-model-week-5-6",level:3},{value:"Phase 4: Hot-Reload and Remote Plugins (Week 7-8)",id:"phase-4-hot-reload-and-remote-plugins-week-7-8",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Plugin Isolation",id:"plugin-isolation",level:3},{value:"Plugin Verification",id:"plugin-verification",level:3},{value:"Related RFCs and ADRs",id:"related-rfcs-and-adrs",level:2},{value:"References",id:"references",level:2},{value:"Appendix: Plugin Development Guide",id:"appendix-plugin-development-guide",level:2},{value:"Creating a New Plugin",id:"creating-a-new-plugin",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"rfc-008-proxy-plugin-architecture-and-responsibility-separation",children:"RFC-008: Proxy Plugin Architecture and Responsibility Separation"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Status"}),": Draft\n",(0,r.jsx)(n.strong,{children:"Author"}),": System\n",(0,r.jsx)(n.strong,{children:"Created"}),": 2025-10-08\n",(0,r.jsx)(n.strong,{children:"Updated"}),": 2025-10-08"]}),"\n",(0,r.jsx)(n.h2,{id:"abstract",children:"Abstract"}),"\n",(0,r.jsxs)(n.p,{children:["This RFC defines the architectural separation between Prism's ",(0,r.jsx)(n.strong,{children:"proxy core"})," (minimal, stable, generic) and ",(0,r.jsx)(n.strong,{children:"backend plugins"})," (specialized, extensible, data-source-specific). By reducing the proxy's surface area and offloading backend-specific logic to plugins, we achieve:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Minimal Proxy Core"}),": Handles networking, configuration, authentication, observability"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Backend Plugins"}),": Implement data-source-specific protocols via secure channels"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Clear Boundaries"}),": Plugins receive configuration, credentials, and tunneled connections"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Extensibility"}),": Add new backends without modifying proxy core"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Security"}),": Plugins operate in isolated contexts with limited capabilities"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The proxy becomes a ",(0,r.jsx)(n.strong,{children:"lightweight orchestrator"})," that tunnels traffic to specialized shims, rather than a monolithic component that understands every backend protocol."]}),"\n",(0,r.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,r.jsx)(n.h3,{id:"current-challenges",children:"Current Challenges"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Monolithic Proxy Problem"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Proxy must understand Kafka, NATS, PostgreSQL, Redis, ClickHouse, MinIO protocols"}),"\n",(0,r.jsx)(n.li,{children:"Each backend adds complexity to proxy codebase"}),"\n",(0,r.jsx)(n.li,{children:"Testing matrix grows combinatorially (N backends \xd7 M features)"}),"\n",(0,r.jsx)(n.li,{children:"Deployment coupling: Backend changes require proxy redeployment"}),"\n",(0,r.jsx)(n.li,{children:"Security surface: Proxy vulnerabilities affect all backends"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"desired-state",children:"Desired State"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Plugin-Based Architecture"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Proxy knows only about gRPC, HTTP/2, auth, config, metrics"}),"\n",(0,r.jsxs)(n.li,{children:["Backends implemented as ",(0,r.jsx)(n.strong,{children:"plugins"})," (WASM, native shared libraries, or sidecar processes)"]}),"\n",(0,r.jsxs)(n.li,{children:["Proxy provides ",(0,r.jsx)(n.strong,{children:"secure channels"})," to plugins (mTLS, Unix sockets, gRPC streams)"]}),"\n",(0,r.jsx)(n.li,{children:"Plugins handle backend-specific logic (connection pooling, query translation, caching)"}),"\n",(0,r.jsx)(n.li,{children:"Plugins receive configuration but don't manage it"}),"\n",(0,r.jsx)(n.li,{children:"Plugins report metrics but don't aggregate them"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"goals",children:"Goals"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Define clear responsibilities for proxy vs. plugins"}),"\n",(0,r.jsx)(n.li,{children:"Establish plugin interface (gRPC-based, extensible)"}),"\n",(0,r.jsx)(n.li,{children:"Support multiple plugin deployment models (in-process, sidecar, remote)"}),"\n",(0,r.jsx)(n.li,{children:"Enable hot-reloading of plugins without proxy restart"}),"\n",(0,r.jsx)(n.li,{children:"Maintain security isolation between proxy and plugins"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"non-goals",children:"Non-Goals"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Not replacing existing backends"}),": Existing backends can be wrapped as plugins"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Not a full plugin ecosystem"}),": Focus on Prism-maintained plugins initially"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Not supporting arbitrary code"}),": Plugins must conform to secure interface"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"responsibility-separation",children:"Responsibility Separation"}),"\n",(0,r.jsx)(n.h3,{id:"proxy-core-responsibilities",children:"Proxy Core Responsibilities"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Responsibility"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Network Termination"})}),(0,r.jsx)(n.td,{children:"Accept gRPC/HTTP connections from clients"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Authentication"})}),(0,r.jsx)(n.td,{children:"Validate mTLS certificates, OAuth2 tokens"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Authorization"})}),(0,r.jsx)(n.td,{children:"Enforce namespace-level access control"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Configuration Management"})}),(0,r.jsx)(n.td,{children:"Load, validate, distribute namespace configs to plugins"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Routing"})}),(0,r.jsx)(n.td,{children:"Route requests to appropriate backend plugins"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Observability"})}),(0,r.jsx)(n.td,{children:"Collect metrics, traces, logs from plugins"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Health Checking"})}),(0,r.jsx)(n.td,{children:"Monitor plugin health, restart on failure"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Rate Limiting"})}),(0,r.jsx)(n.td,{children:"Apply namespace-level rate limits"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Circuit Breaking"})}),(0,r.jsx)(n.td,{children:"Prevent cascading failures across plugins"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"backend-plugin-responsibilities",children:"Backend Plugin Responsibilities"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Responsibility"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Protocol Implementation"})}),(0,r.jsx)(n.td,{children:"Implement backend-specific wire protocols"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Connection Pooling"})}),(0,r.jsx)(n.td,{children:"Manage connections to backend (e.g., PostgreSQL pool)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Query Translation"})}),(0,r.jsx)(n.td,{children:"Translate generic requests to backend-specific queries"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Caching Logic"})}),(0,r.jsx)(n.td,{children:"Implement cache strategies (see RFC-007)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Error Handling"})}),(0,r.jsx)(n.td,{children:"Map backend errors to gRPC status codes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Schema Management"})}),(0,r.jsx)(n.td,{children:"Create tables, indexes, buckets as needed"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Performance Optimization"})}),(0,r.jsx)(n.td,{children:"Backend-specific optimizations (batching, pipelining)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Metrics Reporting"})}),(0,r.jsx)(n.td,{children:"Report plugin-level metrics to proxy"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"what-plugins-do-not-do",children:"What Plugins Do NOT Do"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No Configuration Storage"}),": Proxy provides config; plugins consume it"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No Authentication"}),": Proxy authenticates clients; plugins trust proxy"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No Direct Client Access"}),": Clients always go through proxy"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No Cross-Plugin Communication"}),": Plugins are isolated"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No Global State"}),": Plugins operate per-namespace"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"plugin-interface",children:"Plugin Interface"}),"\n",(0,r.jsx)(n.h3,{id:"grpc-based-plugin-protocol",children:"gRPC-Based Plugin Protocol"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-protobuf",children:'syntax = "proto3";\n\npackage prism.plugin;\n\n// Backend Plugin Service (implemented by plugins)\nservice BackendPlugin {\n  // Initialize plugin with configuration\n  rpc Initialize(InitializeRequest) returns (InitializeResponse);\n\n  // Health check\n  rpc HealthCheck(HealthCheckRequest) returns (HealthCheckResponse);\n\n  // Execute operation (generic interface)\n  rpc Execute(ExecuteRequest) returns (ExecuteResponse);\n\n  // Stream operations (for subscriptions, long-polls)\n  rpc ExecuteStream(stream StreamRequest) returns (stream StreamResponse);\n\n  // Shutdown gracefully\n  rpc Shutdown(ShutdownRequest) returns (ShutdownResponse);\n}\n\n// Plugin initialization\nmessage InitializeRequest {\n  string namespace = 1;\n  string backend_type = 2;  // "postgres", "redis", "kafka", etc.\n\n  // Backend-specific configuration (JSON or protobuf Any)\n  string config_json = 3;\n\n  // Credentials (encrypted in transit)\n  map<string, string> credentials = 4;\n\n  // Proxy capabilities\n  ProxyCapabilities capabilities = 5;\n}\n\nmessage InitializeResponse {\n  bool success = 1;\n  string error = 2;\n\n  // Plugin metadata\n  string plugin_version = 3;\n  repeated string supported_operations = 4;\n}\n\n// Generic execute request\nmessage ExecuteRequest {\n  string operation = 1;  // "get", "set", "query", "subscribe", etc.\n\n  // Operation-specific parameters (JSON or protobuf Any)\n  string params_json = 2;\n\n  // Request metadata (trace ID, user ID, etc.)\n  map<string, string> metadata = 3;\n}\n\nmessage ExecuteResponse {\n  bool success = 1;\n  string error = 2;\n  int32 error_code = 3;\n\n  // Response data (JSON or protobuf Any)\n  string result_json = 4;\n\n  // Plugin metrics\n  PluginMetrics metrics = 5;\n}\n\n// Streaming for subscriptions, long-running queries\nmessage StreamRequest {\n  string operation = 1;\n  string params_json = 2;\n}\n\nmessage StreamResponse {\n  string result_json = 1;\n  bool is_final = 2;\n}\n\n// Health check\nmessage HealthCheckRequest {\n  // Optional: check specific backend connection\n  optional string connection_id = 1;\n}\n\nmessage HealthCheckResponse {\n  enum Status {\n    HEALTHY = 0;\n    DEGRADED = 1;\n    UNHEALTHY = 2;\n  }\n  Status status = 1;\n  string message = 2;\n  map<string, string> details = 3;\n}\n\n// Plugin metrics (reported to proxy)\nmessage PluginMetrics {\n  int64 requests_total = 1;\n  int64 requests_failed = 2;\n  double latency_ms = 3;\n  int64 connections_active = 4;\n  int64 cache_hits = 5;\n}\n\n// Proxy capabilities (what proxy can do for plugins)\nmessage ProxyCapabilities {\n  bool supports_metrics_push = 1;\n  bool supports_distributed_tracing = 2;\n  bool supports_hot_reload = 3;\n  string proxy_version = 4;\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"architecture-diagram",children:"Architecture Diagram"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mermaid",children:'graph TB\n    subgraph "Client Layer"\n        Client1[Client App 1]\n        Client2[Client App 2]\n    end\n\n    subgraph "Prism Proxy Core"\n        GRPCServer[gRPC Server<br/>Port 50051]\n        Auth[Authentication<br/>mTLS / OAuth2]\n        Router[Request Router<br/>Namespace \u2192 Plugin]\n        ConfigMgr[Config Manager<br/>Namespace Configs]\n        Metrics[Metrics Aggregator<br/>Prometheus]\n        HealthMgr[Health Manager<br/>Plugin Monitoring]\n    end\n\n    subgraph "Backend Plugins (In-Process)"\n        PGPlugin[PostgreSQL Plugin]\n        RedisPlugin[Redis Plugin]\n    end\n\n    subgraph "Backend Plugins (Sidecar)"\n        KafkaPlugin[Kafka Plugin<br/>Sidecar Process]\n        ClickHousePlugin[ClickHouse Plugin<br/>Sidecar Process]\n    end\n\n    subgraph "Data Sources"\n        Postgres[(PostgreSQL)]\n        Redis[(Redis)]\n        Kafka[(Kafka)]\n        ClickHouse[(ClickHouse)]\n    end\n\n    Client1 --\x3e|gRPC| GRPCServer\n    Client2 --\x3e|gRPC| GRPCServer\n    GRPCServer --\x3e Auth\n    Auth --\x3e Router\n    Router --\x3e ConfigMgr\n\n    Router --\x3e|Secure Channel| PGPlugin\n    Router --\x3e|Secure Channel| RedisPlugin\n    Router --\x3e|Unix Socket| KafkaPlugin\n    Router --\x3e|gRPC| ClickHousePlugin\n\n    PGPlugin --\x3e Postgres\n    RedisPlugin --\x3e Redis\n    KafkaPlugin --\x3e Kafka\n    ClickHousePlugin --\x3e ClickHouse\n\n    PGPlugin -.Metrics.-> Metrics\n    RedisPlugin -.Metrics.-> Metrics\n    KafkaPlugin -.Metrics.-> Metrics\n    ClickHousePlugin -.Metrics.-> Metrics\n\n    HealthMgr -.Health Check.-> PGPlugin\n    HealthMgr -.Health Check.-> RedisPlugin\n    HealthMgr -.Health Check.-> KafkaPlugin\n    HealthMgr -.Health Check.-> ClickHousePlugin\n'})}),"\n",(0,r.jsx)(n.h2,{id:"plugin-deployment-models",children:"Plugin Deployment Models"}),"\n",(0,r.jsx)(n.h3,{id:"model-1-in-process-plugins-shared-library",children:"Model 1: In-Process Plugins (Shared Library)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Low latency, high throughput backends (Redis, PostgreSQL)"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// Plugin loaded as dynamic library\npub struct RedisPlugin {\n    connection_pool: RedisConnectionPool,\n    config: RedisConfig,\n}\n\n// Plugin implements standard interface\nimpl BackendPlugin for RedisPlugin {\n    async fn initialize(&mut self, req: InitializeRequest) -> Result<InitializeResponse> {\n        self.config = serde_json::from_str(&req.config_json)?;\n        self.connection_pool = RedisConnectionPool::new(&self.config).await?;\n\n        Ok(InitializeResponse {\n            success: true,\n            plugin_version: env!("CARGO_PKG_VERSION").to_string(),\n            supported_operations: vec!["get", "set", "delete", "mget"],\n            ..Default::default()\n        })\n    }\n\n    async fn execute(&self, req: ExecuteRequest) -> Result<ExecuteResponse> {\n        match req.operation.as_str() {\n            "get" => self.handle_get(&req).await,\n            "set" => self.handle_set(&req).await,\n            _ => Err(format!("Unsupported operation: {}", req.operation).into()),\n        }\n    }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pros"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Lowest latency (no IPC overhead)"}),"\n",(0,r.jsx)(n.li,{children:"Shared memory access"}),"\n",(0,r.jsx)(n.li,{children:"Simplest deployment"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cons"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Plugin crash can crash proxy"}),"\n",(0,r.jsx)(n.li,{children:"Security: Plugin has proxy's memory access"}),"\n",(0,r.jsx)(n.li,{children:"Versioning: Plugin must be compatible with proxy ABI"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"model-2-sidecar-plugins-separate-process",children:"Model 2: Sidecar Plugins (Separate Process)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Complex backends with large dependencies (Kafka, ClickHouse)"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'# docker-compose.yml\nservices:\n  prism-proxy:\n    image: prism/proxy:latest\n    ports:\n      - "50051:50051"\n    volumes:\n      - /var/run/plugins:/var/run/plugins\n\n  kafka-plugin:\n    image: prism/kafka-plugin:latest\n    volumes:\n      - /var/run/plugins:/var/run/plugins\n    environment:\n      PLUGIN_SOCKET: /var/run/plugins/kafka.sock\n\n  clickhouse-plugin:\n    image: prism/clickhouse-plugin:latest\n    ports:\n      - "50100:50100"\n    environment:\n      PLUGIN_GRPC_PORT: 50100\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Communication"}),": Unix socket or gRPC over localhost"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pros"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Process isolation (plugin crash doesn't affect proxy)"}),"\n",(0,r.jsx)(n.li,{children:"Independent deployment and versioning"}),"\n",(0,r.jsx)(n.li,{children:"Different runtime (e.g., plugin in Python, proxy in Rust)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cons"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"IPC latency (~1-2ms)"}),"\n",(0,r.jsx)(n.li,{children:"More complex deployment"}),"\n",(0,r.jsx)(n.li,{children:"Resource overhead (separate process)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"model-3-remote-plugins-external-service",children:"Model 3: Remote Plugins (External Service)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Proprietary backends, cloud-managed plugins"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'# Namespace config pointing to remote plugin\nnamespaces:\n  - name: custom-backend\n    backend: remote\n    plugin:\n      type: grpc\n      endpoint: "custom-plugin.example.com:50100"\n      tls:\n        enabled: true\n        ca_cert: /path/to/ca.pem\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pros"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Maximum isolation"}),"\n",(0,r.jsx)(n.li,{children:"Can run in different regions/clusters"}),"\n",(0,r.jsx)(n.li,{children:"Proprietary plugin implementations"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cons"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Network latency (10-50ms)"}),"\n",(0,r.jsx)(n.li,{children:"Requires network security (mTLS)"}),"\n",(0,r.jsx)(n.li,{children:"Higher operational complexity"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"secure-channels",children:"Secure Channels"}),"\n",(0,r.jsx)(n.h3,{id:"channel-security-requirements",children:"Channel Security Requirements"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Encryption"}),": All plugin communication encrypted (TLS, Unix sockets with permissions)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Authentication"}),": Proxy authenticates plugins (mTLS, shared secrets)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Authorization"}),": Plugins can only access their namespace's data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Isolation"}),": Plugins cannot communicate with each other"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Audit"}),": All plugin calls logged with namespace/user context"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"unix-socket-security-sidecar-model",children:"Unix Socket Security (Sidecar Model)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// Proxy creates Unix socket with restricted permissions\nlet socket_path = "/var/run/plugins/postgres.sock";\nlet listener = UnixListener::bind(socket_path)?;\n\n// Set permissions: only proxy user can access\nstd::fs::set_permissions(socket_path, Permissions::from_mode(0o600))?;\n\n// Accept plugin connection\nlet (stream, _) = listener.accept().await?;\n\n// Wrap in secure channel\nlet secure_stream = SecureChannel::new(stream, ChannelSecurity::UnixSocket);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"grpc-channel-security-remote-model",children:"gRPC Channel Security (Remote Model)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// mTLS configuration for remote plugin\nlet tls = ClientTlsConfig::new()\n    .ca_certificate(Certificate::from_pem(ca_cert))\n    .identity(Identity::from_pem(client_cert, client_key));\n\nlet channel = Channel::from_static("https://plugin.example.com:50100")\n    .tls_config(tls)?\n    .connect()\n    .await?;\n\nlet plugin_client = BackendPluginClient::new(channel);\n'})}),"\n",(0,r.jsx)(n.h2,{id:"configuration-flow",children:"Configuration Flow"}),"\n",(0,r.jsx)(n.h3,{id:"proxy--plugin-configuration",children:"Proxy \u2192 Plugin Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mermaid",children:'sequenceDiagram\n    participant Proxy as Proxy Core\n    participant ConfigMgr as Config Manager\n    participant Plugin as PostgreSQL Plugin\n    participant Postgres as PostgreSQL DB\n\n    Note over Proxy,Postgres: Startup Sequence\n\n    Proxy->>ConfigMgr: Load namespace configs\n    ConfigMgr--\x3e>Proxy: Namespaces (user-profiles, etc.)\n\n    Proxy->>Plugin: Initialize(config, credentials)\n    activate Plugin\n    Plugin->>Postgres: Connect with credentials\n    Postgres--\x3e>Plugin: Connection established\n    Plugin--\x3e>Proxy: InitializeResponse(success=true)\n    deactivate Plugin\n\n    Note over Proxy,Postgres: Runtime Request\n\n    Proxy->>Plugin: Execute(operation="get", key="user:123")\n    activate Plugin\n    Plugin->>Postgres: SELECT * FROM users WHERE id=123\n    Postgres--\x3e>Plugin: User data\n    Plugin--\x3e>Proxy: ExecuteResponse(result=<data>)\n    deactivate Plugin\n'})}),"\n",(0,r.jsx)(n.h3,{id:"configuration-example",children:"Configuration Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'# Namespace configuration (managed by proxy)\nnamespaces:\n  - name: user-profiles\n    backend: postgres\n    plugin:\n      type: in_process\n      library: libprism_postgres_plugin.so\n\n    # Backend-specific config (passed to plugin)\n    config:\n      connection_string: "postgres://user:pass@localhost:5432/prism"\n      pool_size: 20\n      idle_timeout: 300\n      statement_cache_size: 100\n\n    # Credentials (encrypted, passed to plugin securely)\n    credentials:\n      username: "prism_user"\n      password: "{{ secret:postgres_password }}"\n\n  - name: event-stream\n    backend: kafka\n    plugin:\n      type: sidecar\n      socket: /var/run/plugins/kafka.sock\n\n    config:\n      brokers:\n        - kafka-1:9092\n        - kafka-2:9092\n        - kafka-3:9092\n      topic_prefix: "prism_"\n      consumer_group: "prism-proxy"\n\n    credentials:\n      sasl_username: "prism"\n      sasl_password: "{{ secret:kafka_password }}"\n'})}),"\n",(0,r.jsx)(n.h2,{id:"hot-reloading-plugins",children:"Hot-Reloading Plugins"}),"\n",(0,r.jsx)(n.h3,{id:"reload-sequence",children:"Reload Sequence"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mermaid",children:'sequenceDiagram\n    participant Admin as Admin CLI\n    participant Proxy as Proxy Core\n    participant OldPlugin as Old Plugin v1.2\n    participant NewPlugin as New Plugin v1.3\n    participant Backend as PostgreSQL\n\n    Admin->>Proxy: Reload plugin(namespace="user-profiles")\n    Proxy->>NewPlugin: Initialize(config, credentials)\n    NewPlugin->>Backend: Connect\n    Backend--\x3e>NewPlugin: Connected\n    NewPlugin--\x3e>Proxy: InitializeResponse(success=true)\n\n    Note over Proxy: Drain old plugin (no new requests)\n\n    OldPlugin->>Backend: Complete in-flight requests\n    Backend--\x3e>OldPlugin: Responses\n\n    Proxy->>OldPlugin: Shutdown()\n    OldPlugin->>Backend: Close connections\n    OldPlugin--\x3e>Proxy: ShutdownResponse\n\n    Proxy->>Proxy: Swap old \u2192 new plugin\n\n    Note over Proxy: New plugin handles all requests\n'})}),"\n",(0,r.jsx)(n.h3,{id:"reload-trigger",children:"Reload Trigger"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# Admin CLI triggers plugin reload\nprism plugin reload user-profiles --version v1.3\n\n# Or via API\ncurl -X POST https://proxy:50052/admin/plugin/reload \\\n  -d \'{"namespace": "user-profiles", "version": "v1.3"}\'\n'})}),"\n",(0,r.jsx)(n.h2,{id:"metrics-and-observability",children:"Metrics and Observability"}),"\n",(0,r.jsx)(n.h3,{id:"plugin-reported-metrics",children:"Plugin-Reported Metrics"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-protobuf",children:"message PluginMetrics {\n  // Request metrics\n  int64 requests_total = 1;\n  int64 requests_failed = 2;\n  double latency_ms = 3;\n\n  // Backend metrics\n  int64 connections_active = 4;\n  int64 connections_idle = 5;\n  int64 queries_executed = 6;\n\n  // Cache metrics (if applicable)\n  int64 cache_hits = 7;\n  int64 cache_misses = 8;\n\n  // Custom backend metrics (JSON)\n  string custom_metrics_json = 9;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"proxy-aggregation",children:"Proxy Aggregation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// Proxy aggregates plugin metrics\npub struct MetricsAggregator {\n    plugin_metrics: HashMap<String, PluginMetrics>,\n}\n\nimpl MetricsAggregator {\n    pub fn record_plugin_metrics(&mut self, namespace: &str, metrics: PluginMetrics) {\n        // Store latest metrics\n        self.plugin_metrics.insert(namespace.to_string(), metrics);\n\n        // Export to Prometheus\n        metrics::gauge!("plugin_requests_total", metrics.requests_total as f64,\n            "namespace" => namespace);\n        metrics::gauge!("plugin_connections_active", metrics.connections_active as f64,\n            "namespace" => namespace);\n        // ...\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"testing-strategy",children:"Testing Strategy"}),"\n",(0,r.jsx)(n.h3,{id:"plugin-testing",children:"Plugin Testing"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_plugin_lifecycle() {\n        let mut plugin = PostgresPlugin::new();\n\n        // Initialize\n        let init_req = InitializeRequest {\n            namespace: "test".to_string(),\n            config_json: r#"{"connection_string": "postgres://localhost"}"#.to_string(),\n            ..Default::default()\n        };\n        let init_resp = plugin.initialize(init_req).await.unwrap();\n        assert!(init_resp.success);\n\n        // Execute\n        let exec_req = ExecuteRequest {\n            operation: "get".to_string(),\n            params_json: r#"{"key": "test:123"}"#.to_string(),\n            ..Default::default()\n        };\n        let exec_resp = plugin.execute(exec_req).await.unwrap();\n        assert!(exec_resp.success);\n\n        // Shutdown\n        let shutdown_resp = plugin.shutdown(ShutdownRequest {}).await.unwrap();\n        assert!(shutdown_resp.success);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"integration-testing-with-mock-proxy",children:"Integration Testing with Mock Proxy"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// Mock proxy provides plugin interface\nstruct MockProxy {\n    config: NamespaceConfig,\n}\n\nimpl MockProxy {\n    async fn test_plugin(plugin: &dyn BackendPlugin) {\n        // Initialize plugin\n        plugin.initialize(...).await.unwrap();\n\n        // Run test scenarios\n        // ...\n\n        // Shutdown\n        plugin.shutdown(...).await.unwrap();\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"migration-path",children:"Migration Path"}),"\n",(0,r.jsx)(n.h3,{id:"phase-1-plugin-interface-definition-week-1-2",children:"Phase 1: Plugin Interface Definition (Week 1-2)"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Protobuf Service"}),": Define BackendPlugin gRPC service"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Rust Trait"}),": Define ",(0,r.jsx)(n.code,{children:"BackendPlugin"})," trait for in-process plugins"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Plugin Manager"}),": Proxy component to load/manage plugins"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Documentation"}),": Plugin development guide"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Deliverable"}),": Plugin interface specification"]}),"\n",(0,r.jsx)(n.h3,{id:"phase-2-first-plugin-postgresql-week-3-4",children:"Phase 2: First Plugin (PostgreSQL) (Week 3-4)"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Wrap Existing Backend"}),": Convert PostgreSQL backend to plugin"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"In-Process Loading"}),": Dynamic library loading in proxy"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Testing"}),": Integration tests with plugin model"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Metrics"}),": Plugin metrics reporting"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Deliverable"}),": PostgreSQL plugin (backward compatible)"]}),"\n",(0,r.jsx)(n.h3,{id:"phase-3-sidecar-model-week-5-6",children:"Phase 3: Sidecar Model (Week 5-6)"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unix Socket Channel"}),": Proxy \u2194 Plugin communication"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Kafka Plugin"}),": Implement as sidecar"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Docker Compose"}),": Multi-container deployment"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Health Checks"}),": Plugin health monitoring"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Deliverable"}),": Sidecar plugin deployment"]}),"\n",(0,r.jsx)(n.h3,{id:"phase-4-hot-reload-and-remote-plugins-week-7-8",children:"Phase 4: Hot-Reload and Remote Plugins (Week 7-8)"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Hot-Reload"}),": Swap plugins without proxy restart"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"gRPC Remote Plugins"}),": Support external plugin services"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Security Hardening"}),": mTLS, credential encryption"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Admin CLI"}),": Plugin management commands"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Deliverable"}),": Production-ready plugin system"]}),"\n",(0,r.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"plugin-isolation",children:"Plugin Isolation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Process Isolation"}),": Sidecar plugins run in separate processes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Resource Limits"}),": cgroups for CPU/memory limits per plugin"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Network Isolation"}),": Plugins can only access their backend"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Credential Encryption"}),": Credentials encrypted in transit to plugins"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Audit Logging"}),": All plugin operations logged with namespace context"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"plugin-verification",children:"Plugin Verification"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// Verify plugin before loading\npub fn verify_plugin(plugin_path: &Path) -> Result<()> {\n    // 1. Check file permissions (must be owned by prism user)\n    let metadata = std::fs::metadata(plugin_path)?;\n    let permissions = metadata.permissions();\n    if permissions.mode() & 0o002 != 0 {\n        return Err("Plugin is world-writable".into());\n    }\n\n    // 2. Verify signature (if applicable)\n    let signature = std::fs::read(format!("{}.sig", plugin_path.display()))?;\n    verify_signature(plugin_path, &signature)?;\n\n    // 3. Load and check version compatibility\n    let plugin = load_plugin(plugin_path)?;\n    if !is_compatible_version(&plugin.version()) {\n        return Err("Plugin version incompatible".into());\n    }\n\n    Ok(())\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"related-rfcs-and-adrs",children:"Related RFCs and ADRs"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"RFC-003: Admin gRPC API (proxy management)"}),"\n",(0,r.jsx)(n.li,{children:"RFC-004: Redis Integration (example backend \u2192 plugin)"}),"\n",(0,r.jsx)(n.li,{children:"RFC-007: Cache Strategies (plugin-level caching)"}),"\n",(0,r.jsx)(n.li,{children:"ADR-010: Redis Integration (backend implementation)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://grpc.io/docs/what-is-grpc/introduction/",children:"gRPC Plugin System Design"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/hashicorp/go-plugin",children:"HashiCorp go-plugin"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/WebAssembly/component-model",children:"WebAssembly Component Model"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://man7.org/linux/man-pages/man7/capabilities.7.html",children:"Linux Capabilities"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"appendix-plugin-development-guide",children:"Appendix: Plugin Development Guide"}),"\n",(0,r.jsx)(n.h3,{id:"creating-a-new-plugin",children:"Creating a New Plugin"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement BackendPlugin Trait"}),":"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use prism_plugin::{BackendPlugin, InitializeRequest, ExecuteRequest};\n\npub struct MyBackendPlugin {\n    config: MyConfig,\n    client: MyBackendClient,\n}\n\n#[async_trait]\nimpl BackendPlugin for MyBackendPlugin {\n    async fn initialize(&mut self, req: InitializeRequest) -> Result<InitializeResponse> {\n        self.config = serde_json::from_str(&req.config_json)?;\n        self.client = MyBackendClient::connect(&self.config).await?;\n\n        Ok(InitializeResponse {\n            success: true,\n            plugin_version: "0.1.0".to_string(),\n            supported_operations: vec!["get", "set"],\n            ..Default::default()\n        })\n    }\n\n    async fn execute(&self, req: ExecuteRequest) -> Result<ExecuteResponse> {\n        match req.operation.as_str() {\n            "get" => self.handle_get(&req).await,\n            "set" => self.handle_set(&req).await,\n            _ => Err(format!("Unsupported: {}", req.operation).into()),\n        }\n    }\n}\n'})}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Build as Shared Library"}),":"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-toml",children:'[lib]\ncrate-type = ["cdylib"]  # Dynamic library\n\n[dependencies]\nprism-plugin-sdk = "0.1"\n'})}),"\n",(0,r.jsxs)(n.ol,{start:"3",children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Register Plugin"}),":"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"# Add to proxy configuration\nplugins:\n  - name: my-backend\n    library: /path/to/libmy_backend_plugin.so\n    type: in_process\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Status"}),": Draft\n",(0,r.jsx)(n.strong,{children:"Next Steps"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Define BackendPlugin gRPC service in protobuf"}),"\n",(0,r.jsx)(n.li,{children:"Implement plugin trait in Rust"}),"\n",(0,r.jsx)(n.li,{children:"Convert PostgreSQL backend to plugin architecture"}),"\n",(0,r.jsx)(n.li,{children:"Document plugin development process"}),"\n",(0,r.jsx)(n.li,{children:"Implement sidecar plugin support with Unix sockets"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>a});var s=i(6540);const r={},t=s.createContext(r);function l(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);