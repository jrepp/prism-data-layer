"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[92417],{7621:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"memo-006","title":"Backend Interface Decomposition and Schema Registry","description":"Purpose","source":"@site/../docs-cms/memos/memo-006-backend-interface-decomposition-schema-registry.md","sourceDirName":".","slug":"/memo-006","permalink":"/prism-data-layer/memos/memo-006","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/memos/memo-006-backend-interface-decomposition-schema-registry.md","tags":[{"inline":true,"label":"architecture","permalink":"/prism-data-layer/memos/tags/architecture"},{"inline":true,"label":"backend","permalink":"/prism-data-layer/memos/tags/backend"},{"inline":true,"label":"patterns","permalink":"/prism-data-layer/memos/tags/patterns"},{"inline":true,"label":"schemas","permalink":"/prism-data-layer/memos/tags/schemas"},{"inline":true,"label":"registry","permalink":"/prism-data-layer/memos/tags/registry"},{"inline":true,"label":"capabilities","permalink":"/prism-data-layer/memos/tags/capabilities"}],"version":"current","frontMatter":{"author":"Platform Team","created":"2025-10-09T00:00:00.000Z","doc_uuid":"588391f4-c72e-48d1-a1fb-14be1fa824ae","id":"memo-006","project_id":"prism-data-layer","tags":["architecture","backend","patterns","schemas","registry","capabilities"],"title":"Backend Interface Decomposition and Schema Registry","updated":"2025-10-09T00:00:00.000Z"},"sidebar":"memosSidebar","previous":{"title":"Client Protocol Design Philosophy - Composition vs Use-Case Specificity \u2022 MEMO-005","permalink":"/prism-data-layer/memos/memo-005"},"next":{"title":"Podman Demo for Scratch-Based Containers with Native Runtime \u2022 MEMO-007","permalink":"/prism-data-layer/memos/memo-007"}}');var i=s(74848),r=s(28453);const a={author:"Platform Team",created:new Date("2025-10-09T00:00:00.000Z"),doc_uuid:"588391f4-c72e-48d1-a1fb-14be1fa824ae",id:"memo-006",project_id:"prism-data-layer",tags:["architecture","backend","patterns","schemas","registry","capabilities"],title:"Backend Interface Decomposition and Schema Registry",updated:new Date("2025-10-09T00:00:00.000Z")},c="MEMO-006: Backend Interface Decomposition and Schema Registry",l={},o=[{value:"Purpose",id:"purpose",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Solution: Three-Layer Schema Architecture",id:"solution-three-layer-schema-architecture",level:2},{value:"Layer 1: Backend Interface Schemas",id:"layer-1-backend-interface-schemas",level:3},{value:"Layer 2: Backend Implementation Matrix",id:"layer-2-backend-implementation-matrix",level:3},{value:"Layer 3: Pattern Schemas with Slots",id:"layer-3-pattern-schemas-with-slots",level:3},{value:"Capabilities Expressed Through Interfaces",id:"capabilities-expressed-through-interfaces",level:2},{value:"Schema Registry Filesystem Layout",id:"schema-registry-filesystem-layout",level:2},{value:"2. <strong>Straightforward Configuration Generation</strong>",id:"2-straightforward-configuration-generation",level:3},{value:"4. <strong>Pattern Portability</strong>",id:"4-pattern-portability",level:3},{value:"Validation Rules",id:"validation-rules",level:2},{value:"Backend Validation",id:"backend-validation",level:3},{value:"Pattern Validation",id:"pattern-validation",level:3},{value:"Configuration Validation",id:"configuration-validation",level:3}];function d(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"memo-006-backend-interface-decomposition-and-schema-registry",children:"MEMO-006: Backend Interface Decomposition and Schema Registry"})}),"\n",(0,i.jsx)(n.h2,{id:"purpose",children:"Purpose"}),"\n",(0,i.jsx)(n.p,{children:"Define how backend interfaces should be decomposed into thin, composable proto services, and establish a registry system for backend interfaces, pattern schemas, and slot schemas to enable straightforward configuration generation."}),"\n",(0,i.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,i.jsx)(n.p,{children:'Current architecture treats backends as monolithic units (e.g., "Redis backend", "Postgres backend"). This creates several issues:'}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Coarse granularity"}),": Redis supports 6+ distinct data models (KeyValue, PubSub, Streams, Lists, Sets, SortedSets), but we treat it as single unit"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Unclear capabilities"}),": No explicit mapping of which backends support which interfaces"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pattern composition ambiguity"}),": Pattern executors need specific backend capabilities, but relationship isn't formally defined"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Configuration complexity"}),": Hard to generate configs that compose patterns with appropriate backends"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"solution-three-layer-schema-architecture",children:"Solution: Three-Layer Schema Architecture"}),"\n",(0,i.jsx)(n.h3,{id:"layer-1-backend-interface-schemas",children:"Layer 1: Backend Interface Schemas"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Design Decision: Explicit Interface Flavors (Not Capability Flags)"})}),"\n",(0,i.jsxs)(n.p,{children:["We use ",(0,i.jsx)(n.strong,{children:"thin, purpose-specific interfaces"})," rather than monolithic interfaces with capability flags because:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type Safety"}),": Compiler enforces contracts. If backend implements ",(0,i.jsx)(n.code,{children:"KeyValueScanInterface"}),", scanning MUST work."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Clear Contracts"}),": No runtime surprises. Interface presence guarantees functionality."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Composability"}),": Backends compose multiple interfaces like traits/mixins."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Proto-First"}),": All contracts in ",(0,i.jsx)(n.code,{children:".proto"})," files, not separate metadata."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pattern"}),": Each data model has multiple interface flavors:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"<Model>Basic"})," - Core CRUD operations (required)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"<Model>Scan"})," - Enumeration capability (optional)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"<Model>TTL"})," - Time-to-live expiration (optional)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"<Model>Transactional"})," - Multi-operation atomicity (optional)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"<Model>Batch"})," - Bulk operations (optional)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Examples"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:'// proto/interfaces/keyvalue_basic.proto\nsyntax = "proto3";\npackage prism.interfaces.keyvalue;\n\n// Core key-value operations - ALL backends must implement\nservice KeyValueBasicInterface {\n  rpc Set(SetRequest) returns (SetResponse);\n  rpc Get(GetRequest) returns (GetResponse);\n  rpc Delete(DeleteRequest) returns (DeleteResponse);\n  rpc Exists(ExistsRequest) returns (ExistsResponse);\n}\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:'// proto/interfaces/keyvalue_scan.proto\nsyntax = "proto3";\npackage prism.interfaces.keyvalue;\n\n// Enumeration support - backends with efficient iteration\nservice KeyValueScanInterface {\n  rpc Scan(ScanRequest) returns (stream ScanResponse);\n  rpc ScanKeys(ScanKeysRequest) returns (stream KeyResponse);\n  rpc Count(CountRequest) returns (CountResponse);\n}\n\n// Implemented by: Redis, PostgreSQL, etcd, DynamoDB\n// NOT implemented by: MemStore (small only), S3 (expensive)\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:'// proto/interfaces/keyvalue_ttl.proto\nsyntax = "proto3";\npackage prism.interfaces.keyvalue;\n\n// Time-to-live expiration\nservice KeyValueTTLInterface {\n  rpc Expire(ExpireRequest) returns (ExpireResponse);\n  rpc GetTTL(GetTTLRequest) returns (GetTTLResponse);\n  rpc Persist(PersistRequest) returns (PersistResponse);  // Remove TTL\n}\n\n// Implemented by: Redis, DynamoDB, etcd, MemStore\n// NOT implemented by: PostgreSQL (requires cron), S3 (lifecycle policies)\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:'// proto/interfaces/keyvalue_transactional.proto\nsyntax = "proto3";\npackage prism.interfaces.keyvalue;\n\n// Multi-operation transactions\nservice KeyValueTransactionalInterface {\n  rpc BeginTransaction(BeginTransactionRequest) returns (TransactionHandle);\n  rpc SetInTransaction(TransactionSetRequest) returns (SetResponse);\n  rpc GetInTransaction(TransactionGetRequest) returns (GetResponse);\n  rpc Commit(CommitRequest) returns (CommitResponse);\n  rpc Rollback(RollbackRequest) returns (RollbackResponse);\n}\n\n// Implemented by: Redis (MULTI/EXEC), PostgreSQL (ACID), DynamoDB (TransactWriteItems)\n// NOT implemented by: MemStore, S3, etcd (single-key only)\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:'// proto/interfaces/keyvalue_batch.proto\nsyntax = "proto3";\npackage prism.interfaces.keyvalue;\n\n// Bulk operations for efficiency\nservice KeyValueBatchInterface {\n  rpc BatchSet(BatchSetRequest) returns (BatchSetResponse);\n  rpc BatchGet(BatchGetRequest) returns (BatchGetResponse);\n  rpc BatchDelete(BatchDeleteRequest) returns (BatchDeleteResponse);\n}\n\n// Implemented by: Redis (MGET/MSET), PostgreSQL (bulk INSERT), DynamoDB (BatchWriteItem)\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:'// proto/interfaces/pubsub_basic.proto\nsyntax = "proto3";\npackage prism.interfaces.pubsub;\n\n// Core publish/subscribe - ALL backends must implement\nservice PubSubBasicInterface {\n  rpc Publish(PublishRequest) returns (PublishResponse);\n  rpc Subscribe(SubscribeRequest) returns (stream Message);\n  rpc Unsubscribe(UnsubscribeRequest) returns (UnsubscribeResponse);\n}\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:'// proto/interfaces/pubsub_wildcards.proto\nsyntax = "proto3";\npackage prism.interfaces.pubsub;\n\n// Wildcard subscriptions (e.g., topic.*, topic.>)\nservice PubSubWildcardsInterface {\n  rpc SubscribePattern(SubscribePatternRequest) returns (stream Message);\n}\n\n// Implemented by: NATS, Redis Pub/Sub, RabbitMQ\n// NOT implemented by: Kafka (topics are explicit)\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:'// proto/interfaces/pubsub_persistent.proto\nsyntax = "proto3";\npackage prism.interfaces.pubsub;\n\n// Durable pub/sub with message persistence\nservice PubSubPersistentInterface {\n  rpc PublishPersistent(PublishRequest) returns (PublishResponse);\n  rpc SubscribeDurable(SubscribeDurableRequest) returns (stream Message);\n  rpc GetLastMessageID(GetLastMessageIDRequest) returns (MessageIDResponse);\n}\n\n// Implemented by: Kafka, NATS JetStream, Redis Streams (as pub/sub)\n// NOT implemented by: Redis Pub/Sub, NATS Core\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:'// proto/interfaces/stream_basic.proto\nsyntax = "proto3";\npackage prism.interfaces.stream;\n\n// Append-only log with offset-based reads\nservice StreamBasicInterface {\n  rpc Append(AppendRequest) returns (AppendResponse);\n  rpc Read(ReadRequest) returns (stream StreamRecord);\n  rpc GetLatestOffset(GetLatestOffsetRequest) returns (OffsetResponse);\n}\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:'// proto/interfaces/stream_consumer_groups.proto\nsyntax = "proto3";\npackage prism.interfaces.stream;\n\n// Consumer group coordination\nservice StreamConsumerGroupsInterface {\n  rpc CreateConsumerGroup(CreateConsumerGroupRequest) returns (CreateConsumerGroupResponse);\n  rpc JoinConsumerGroup(JoinConsumerGroupRequest) returns (stream StreamRecord);\n  rpc Ack(AckRequest) returns (AckResponse);\n  rpc GetConsumerGroupInfo(GetConsumerGroupInfoRequest) returns (ConsumerGroupInfo);\n}\n\n// Implemented by: Kafka, Redis Streams, NATS JetStream\n// NOT implemented by: Kafka (different model), S3 (no coordination)\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:'// proto/interfaces/stream_replay.proto\nsyntax = "proto3";\npackage prism.interfaces.stream;\n\n// Read from arbitrary historical offset\nservice StreamReplayInterface {\n  rpc SeekToOffset(SeekToOffsetRequest) returns (SeekResponse);\n  rpc SeekToTimestamp(SeekToTimestampRequest) returns (SeekResponse);\n  rpc ReplayRange(ReplayRangeRequest) returns (stream StreamRecord);\n}\n\n// Implemented by: Kafka, Redis Streams, NATS JetStream\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Complete Interface Catalog"})," (45 thin interfaces across 10 data models):"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"KeyValue (6 interfaces)"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"keyvalue_basic.proto"})," - Core CRUD (Set, Get, Delete, Exists)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"keyvalue_scan.proto"})," - Enumeration (Scan, ScanKeys, Count)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"keyvalue_ttl.proto"})," - Expiration (Expire, GetTTL, Persist)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"keyvalue_transactional.proto"})," - Transactions (Begin, Commit, Rollback)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"keyvalue_batch.proto"})," - Bulk operations (BatchSet, BatchGet, BatchDelete)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"keyvalue_cas.proto"})," - Compare-and-swap (CompareAndSwap, CompareAndDelete)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"PubSub (5 interfaces)"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pubsub_basic.proto"})," - Core pub/sub (Publish, Subscribe, Unsubscribe)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pubsub_wildcards.proto"})," - Pattern subscriptions (SubscribePattern)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pubsub_persistent.proto"})," - Durable messages (PublishPersistent, SubscribeDurable)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pubsub_filtering.proto"})," - Server-side filtering (PublishWithAttributes, SubscribeFiltered)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pubsub_ordering.proto"})," - Message ordering guarantees (PublishOrdered)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Stream (5 interfaces)"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"stream_basic.proto"})," - Append-only log (Append, Read, GetLatestOffset)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"stream_consumer_groups.proto"})," - Coordination (CreateGroup, Join, Ack)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"stream_replay.proto"})," - Historical reads (SeekToOffset, SeekToTimestamp, ReplayRange)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"stream_retention.proto"})," - Lifecycle management (SetRetention, GetRetention, Compact)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"stream_partitioning.proto"})," - Parallel processing (GetPartitions, AppendToPartition)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Queue (5 interfaces)"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"queue_basic.proto"})," - FIFO operations (Enqueue, Dequeue, Peek)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"queue_visibility.proto"})," - Visibility timeout (DequeueWithTimeout, ExtendVisibility, Release)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"queue_dead_letter.proto"})," - Failed message handling (ConfigureDeadLetter, GetDeadLetterQueue)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"queue_priority.proto"})," - Priority queues (EnqueueWithPriority)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"queue_delayed.proto"})," - Delayed delivery (EnqueueDelayed, GetScheduledCount)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"List (4 interfaces)"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"list_basic.proto"})," - Ordered operations (PushLeft, PushRight, PopLeft, PopRight)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"list_indexing.proto"})," - Random access (Get, Set, Insert, Remove)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"list_range.proto"})," - Bulk operations (GetRange, Trim)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"list_blocking.proto"})," - Blocking pops (BlockingPopLeft, BlockingPopRight)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Set (4 interfaces)"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"set_basic.proto"})," - Membership (Add, Remove, Contains, GetMembers)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"set_operations.proto"})," - Set algebra (Union, Intersection, Difference)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"set_cardinality.proto"})," - Size tracking (GetSize, IsMember)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"set_random.proto"})," - Random sampling (GetRandomMember, PopRandomMember)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"SortedSet (5 interfaces)"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"sortedset_basic.proto"})," - Scored operations (Add, Remove, GetScore)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"sortedset_range.proto"})," - Range queries (GetRange, GetRangeByScore)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"sortedset_rank.proto"})," - Ranking (GetRank, GetReverseRank)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"sortedset_operations.proto"})," - Set operations with scores (Union, Intersection)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"sortedset_lex.proto"})," - Lexicographic range (GetRangeByLex)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"TimeSeries (4 interfaces)"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"timeseries_basic.proto"})," - Time-indexed writes (Insert, Query)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"timeseries_aggregation.proto"})," - Downsampling (Aggregate, Rollup)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"timeseries_retention.proto"})," - Data lifecycle (SetRetention, Compact)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"timeseries_interpolation.proto"})," - Gap filling (InterpolateLinear, InterpolateStep)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Graph (4 interfaces)"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"graph_basic.proto"})," - Node/edge CRUD (AddNode, AddEdge, DeleteNode, DeleteEdge)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"graph_traversal.proto"})," - Graph walks (TraverseDepthFirst, TraverseBreadthFirst)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"graph_query.proto"})," - Query languages (GremlinQuery, CypherQuery, SparqlQuery)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"graph_analytics.proto"})," - Graph algorithms (ShortestPath, PageRank, ConnectedComponents)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Document (3 interfaces)"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"document_basic.proto"})," - JSON/BSON storage (Insert, Update, Delete, Get)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"document_query.proto"})," - Document queries (Find, FindOne, Aggregate)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"document_indexing.proto"})," - Secondary indexes (CreateIndex, DropIndex, ListIndexes)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"layer-2-backend-implementation-matrix",children:"Layer 2: Backend Implementation Matrix"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Definition"}),": Mapping of which backends implement which interfaces."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Example Matrix"})," (stored as ",(0,i.jsx)(n.code,{children:"registry/backends/redis.yaml"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'backend: redis\ndescription: "In-memory data structure store"\nplugin: prism-redis:v1.2.0\nconnection_string_format: "redis://host:port/db"\n\n# Redis implements 16 interfaces across 6 data models\nimplements:\n  # KeyValue (5 of 6) - Missing only CAS\n  - keyvalue_basic          # Set, Get, Delete, Exists\n  - keyvalue_scan           # Scan, ScanKeys, Count\n  - keyvalue_ttl            # Expire, GetTTL, Persist\n  - keyvalue_transactional  # MULTI/EXEC transactions\n  - keyvalue_batch          # MGET, MSET, MDEL\n\n  # PubSub (2 of 5) - Fire-and-forget messaging\n  - pubsub_basic            # Publish, Subscribe, Unsubscribe\n  - pubsub_wildcards        # Pattern subscriptions (*)\n\n  # Stream (4 of 5) - Redis Streams\n  - stream_basic            # XADD, XREAD, XINFO\n  - stream_consumer_groups  # XGROUP, XREADGROUP, XACK\n  - stream_replay           # XREAD with offset\n  - stream_retention        # MAXLEN, XTRIM\n\n  # List (4 of 4) - Complete list support\n  - list_basic              # LPUSH, RPUSH, LPOP, RPOP\n  - list_indexing           # LINDEX, LSET, LINSERT, LREM\n  - list_range              # LRANGE, LTRIM\n  - list_blocking           # BLPOP, BRPOP\n\n  # Set (4 of 4) - Complete set support\n  - set_basic               # SADD, SREM, SISMEMBER, SMEMBERS\n  - set_operations          # SUNION, SINTER, SDIFF\n  - set_cardinality         # SCARD\n  - set_random              # SRANDMEMBER, SPOP\n\n  # SortedSet (5 of 5) - Complete sorted set support\n  - sortedset_basic         # ZADD, ZREM, ZSCORE\n  - sortedset_range         # ZRANGE, ZRANGEBYSCORE\n  - sortedset_rank          # ZRANK, ZREVRANK\n  - sortedset_operations    # ZUNION, ZINTER\n  - sortedset_lex           # ZRANGEBYLEX\n\n# 16 interfaces total\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Postgres Backend"})," (stored as ",(0,i.jsx)(n.code,{children:"registry/backends/postgres.yaml"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'backend: postgres\ndescription: "Relational database with strong consistency"\nplugin: prism-postgres:v1.5.0\nconnection_string_format: "postgresql://user:pass@host:port/db"\n\n# Postgres implements 9 interfaces across 5 data models\nimplements:\n  # KeyValue (4 of 6) - No TTL (requires cron), no CAS\n  - keyvalue_basic          # INSERT, SELECT, DELETE via KV table\n  - keyvalue_scan           # SELECT * FROM kv WHERE key LIKE ...\n  - keyvalue_transactional  # ACID transactions\n  - keyvalue_batch          # Bulk INSERT, SELECT IN (...)\n\n  # Queue (4 of 5) - Using queue table with SKIP LOCKED\n  - queue_basic             # INSERT INTO queue, SELECT FOR UPDATE SKIP LOCKED\n  - queue_visibility        # Visibility timeout via timestamp\n  - queue_dead_letter       # Failed messages to DLQ table\n  - queue_delayed           # Scheduled delivery via timestamp\n\n  # TimeSeries (3 of 4) - With TimescaleDB extension\n  - timeseries_basic        # Hypertables for time-series data\n  - timeseries_aggregation  # Continuous aggregates\n  - timeseries_retention    # Retention policies\n\n  # Document (3 of 3) - JSONB support\n  - document_basic          # INSERT, UPDATE, DELETE with JSONB column\n  - document_query          # WHERE jsonb_column @> \'{"key": "value"}\'\n  - document_indexing       # GIN indexes on JSONB\n\n  # Graph (2 of 4) - Limited graph support\n  - graph_basic             # Nodes and edges tables\n  - graph_traversal         # Recursive CTEs (WITH RECURSIVE)\n\n# 16 interfaces total (different mix than Redis)\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"MemStore Backend"})," (stored as ",(0,i.jsx)(n.code,{children:"registry/backends/memstore.yaml"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'backend: memstore\ndescription: "In-memory Go map and list for local testing"\nplugin: built-in\nconnection_string_format: "mem://local"\n\n# MemStore implements 6 interfaces across 2 data models\nimplements:\n  # KeyValue (2 of 6) - Minimal key-value storage\n  - keyvalue_basic  # sync.Map operations\n  - keyvalue_ttl    # TTL with time.AfterFunc cleanup\n\n  # List (4 of 4) - Complete in-memory list support\n  - list_basic      # Slice-based FIFO/LIFO operations\n  - list_indexing   # Direct slice indexing\n  - list_range      # Slice range operations\n  - list_blocking   # Blocking pops with channels\n\n# 6 interfaces total - intentionally minimal for fast local testing\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Kafka Backend"})," (stored as ",(0,i.jsx)(n.code,{children:"registry/backends/kafka.yaml"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'backend: kafka\ndescription: "Distributed event streaming platform"\nplugin: prism-kafka:v2.0.0\nconnection_string_format: "kafka://broker1:9092,broker2:9092"\n\n# Kafka implements 5 stream interfaces + pub/sub\nimplements:\n  # Stream (5 of 5) - Complete streaming platform\n  - stream_basic                # Produce, Consume\n  - stream_consumer_groups      # Consumer group coordination\n  - stream_replay               # Seek to offset/timestamp\n  - stream_retention            # Retention policies\n  - stream_partitioning         # Topic partitions\n\n  # PubSub (2 of 5) - Topics as pub/sub channels\n  - pubsub_basic                # Publish to topic, subscribe to topic\n  - pubsub_persistent           # Durable messages with offsets\n\n# 7 interfaces total - focused on streaming\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Backend Interface Count Comparison"}),":"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Backend"}),(0,i.jsx)(n.th,{children:"Interfaces"}),(0,i.jsx)(n.th,{children:"Data Models"}),(0,i.jsx)(n.th,{children:"Notes"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Redis"}),(0,i.jsx)(n.td,{children:"16"}),(0,i.jsx)(n.td,{children:"KeyValue, PubSub, Stream, List, Set, SortedSet"}),(0,i.jsx)(n.td,{children:"Most versatile general-purpose backend"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Postgres"}),(0,i.jsx)(n.td,{children:"16"}),(0,i.jsx)(n.td,{children:"KeyValue, Queue, TimeSeries, Document, Graph"}),(0,i.jsx)(n.td,{children:"Different mix, strong consistency"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Kafka"}),(0,i.jsx)(n.td,{children:"7"}),(0,i.jsx)(n.td,{children:"Stream, PubSub"}),(0,i.jsx)(n.td,{children:"Specialized for event streaming"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Meilisearch"}),(0,i.jsx)(n.td,{children:"8"}),(0,i.jsx)(n.td,{children:"Document, KeyValue, Set"}),(0,i.jsx)(n.td,{children:"Specialized for full-text search"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"NATS"}),(0,i.jsx)(n.td,{children:"8"}),(0,i.jsx)(n.td,{children:"PubSub, Stream, Queue"}),(0,i.jsx)(n.td,{children:"Lightweight messaging"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"DynamoDB"}),(0,i.jsx)(n.td,{children:"9"}),(0,i.jsx)(n.td,{children:"KeyValue, Document, Set"}),(0,i.jsx)(n.td,{children:"AWS managed NoSQL"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"MemStore"}),(0,i.jsx)(n.td,{children:"6"}),(0,i.jsx)(n.td,{children:"KeyValue, List"}),(0,i.jsx)(n.td,{children:"Minimal for local testing"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"ClickHouse"}),(0,i.jsx)(n.td,{children:"3"}),(0,i.jsx)(n.td,{children:"TimeSeries, Stream"}),(0,i.jsx)(n.td,{children:"Specialized for analytics"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Neptune"}),(0,i.jsx)(n.td,{children:"4"}),(0,i.jsx)(n.td,{children:"Graph"}),(0,i.jsx)(n.td,{children:"Specialized for graph queries"})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Insights"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Redis & Postgres are workhorses"}),": Both implement 16 interfaces but different mixes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Specialized backends focus"}),": Kafka (streaming), Neptune (graph), ClickHouse (analytics), Meilisearch (search)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Test backends minimal"}),": MemStore implements just enough for local development (KeyValue + List)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"No backend implements all 45 interfaces"}),": Backends specialize in what they're good at"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"layer-3-pattern-schemas-with-slots",children:"Layer 3: Pattern Schemas with Slots"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Definition"}),": High-level patterns that compose multiple backend interfaces."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pattern Schema Example"})," (stored as ",(0,i.jsx)(n.code,{children:"registry/patterns/multicast_registry.yaml"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'pattern: multicast-registry\nversion: v1\ndescription: "Register identities with metadata and multicast messages to filtered subsets"\nexecutor: prism-pattern-multicast-registry:v1.0.0\n\n# Pattern requires two slots (+ one optional) to be filled\nslots:\n  registry:\n    description: "Stores identity \u2192 metadata mappings"\n    required_interfaces:\n      - keyvalue_basic  # MUST implement basic KV operations\n      - keyvalue_scan   # MUST support enumeration\n    optional_interfaces:\n      - keyvalue_ttl    # Nice to have: auto-expire offline identities\n    recommended_backends:\n      - redis           # Has all 3 interfaces\n      - postgres        # Has basic + scan (no TTL)\n      - dynamodb        # Has all 3 interfaces\n      - etcd            # Has all 3 interfaces\n\n  messaging:\n    description: "Delivers multicast messages to identities"\n    required_interfaces:\n      - pubsub_basic    # MUST implement basic pub/sub\n    optional_interfaces:\n      - pubsub_persistent  # Nice to have: durable delivery\n    recommended_backends:\n      - nats            # Has basic (+ wildcards if needed)\n      - redis           # Has basic + wildcards\n      - kafka           # Has basic + persistent\n\n  # Optional third slot for durability\n  durability:\n    description: "Persists undelivered messages for offline identities"\n    required_interfaces:\n      - queue_basic           # MUST implement basic queue ops\n      - queue_visibility      # MUST support visibility timeout\n      - queue_dead_letter     # MUST handle failed deliveries\n    recommended_backends:\n      - postgres        # Has all 3 queue interfaces\n      - sqs             # Has all 3 queue interfaces (AWS)\n      - rabbitmq        # Has all 3 queue interfaces\n    optional: true\n\n# Pattern-level API (different from backend interfaces)\napi:\n  proto_file: "proto/patterns/multicast_registry.proto"\n  service: MulticastRegistryService\n  methods:\n    - Register(RegisterRequest) returns (RegisterResponse)\n    - Enumerate(EnumerateRequest) returns (EnumerateResponse)\n    - Multicast(MulticastRequest) returns (MulticastResponse)\n    - Deregister(DeregisterRequest) returns (DeregisterResponse)\n\n# How pattern executor uses slots\nimplementation:\n  register_flow:\n    - slot: registry\n      operation: Set(identity, metadata)\n    - slot: messaging\n      operation: Subscribe(identity)  # Pre-subscribe for receiving\n\n  enumerate_flow:\n    - slot: registry\n      operation: Scan(filter)\n\n  multicast_flow:\n    - slot: registry\n      operation: Scan(filter)  # Get matching identities\n    - slot: messaging\n      operation: Publish(identity, message)  # Fan-out\n    - slot: durability  # If configured\n      operation: Enqueue(identity, message)  # For offline identities\n\n**Example Configuration** (using the pattern):\n\n'})}),"\n",(0,i.jsx)(n.p,{children:"namespaces:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"name: iot-devices\npattern: multicast-registry\npattern_version: v1"}),"\n",(0,i.jsx)(n.h1,{id:"fill-the-required-slots-with-backends-that-implement-required-interfaces",children:"Fill the required slots with backends that implement required interfaces"}),"\n",(0,i.jsx)(n.p,{children:'slots:\nregistry:\nbackend: redis\n# Redis implements: keyvalue_basic, keyvalue_scan, keyvalue_ttl \u2713\ninterfaces:\n- keyvalue_basic\n- keyvalue_scan\n- keyvalue_ttl  # Optional but Redis has it\nconfig:\nconnection: "redis://localhost:6379/0"\nkey_prefix: "iot:"\nttl_seconds: 3600'}),"\n",(0,i.jsx)(n.p,{children:'messaging:\nbackend: nats\n# NATS implements: pubsub_basic, pubsub_wildcards \u2713\ninterfaces:\n- pubsub_basic\nconfig:\nconnection: "nats://localhost:4222"\nsubject_prefix: "iot.devices."'}),"\n",(0,i.jsx)(n.h1,{id:"optional-durability-slot",children:"Optional durability slot"}),"\n",(0,i.jsx)(n.p,{children:'durability:\nbackend: postgres\n# Postgres implements: queue_basic, queue_visibility, queue_dead_letter \u2713\ninterfaces:\n- queue_basic\n- queue_visibility\n- queue_dead_letter\nconfig:\nconnection: "postgresql://localhost:5432/prism"\ntable: "iot_message_queue"\nvisibility_timeout: 30'}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"capabilities-expressed-through-interfaces",children:"Capabilities Expressed Through Interfaces"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Design Note"}),": We do NOT use separate capability flags. Instead, ",(0,i.jsx)(n.strong,{children:"capabilities are expressed through interface presence"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Examples"}),":"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Capability"}),(0,i.jsx)(n.th,{children:"How It's Expressed"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"TTL Support"}),(0,i.jsxs)(n.td,{children:["Backend implements ",(0,i.jsx)(n.code,{children:"keyvalue_ttl"})," interface"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Scan Support"}),(0,i.jsxs)(n.td,{children:["Backend implements ",(0,i.jsx)(n.code,{children:"keyvalue_scan"})," interface"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Transactions"}),(0,i.jsxs)(n.td,{children:["Backend implements ",(0,i.jsx)(n.code,{children:"keyvalue_transactional"})," interface"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Wildcards in Pub/Sub"}),(0,i.jsxs)(n.td,{children:["Backend implements ",(0,i.jsx)(n.code,{children:"pubsub_wildcards"})," interface"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Consumer Groups"}),(0,i.jsxs)(n.td,{children:["Backend implements ",(0,i.jsx)(n.code,{children:"stream_consumer_groups"})," interface"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Replay"}),(0,i.jsxs)(n.td,{children:["Backend implements ",(0,i.jsx)(n.code,{children:"stream_replay"})," interface"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Persistence"}),(0,i.jsxs)(n.td,{children:["Backend implements ",(0,i.jsx)(n.code,{children:"pubsub_persistent"})," interface"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Visibility Timeout"}),(0,i.jsxs)(n.td,{children:["Backend implements ",(0,i.jsx)(n.code,{children:"queue_visibility"})," interface"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Dead Letter Queue"}),(0,i.jsxs)(n.td,{children:["Backend implements ",(0,i.jsx)(n.code,{children:"queue_dead_letter"})," interface"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Priority Queues"}),(0,i.jsxs)(n.td,{children:["Backend implements ",(0,i.jsx)(n.code,{children:"queue_priority"})," interface"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Graph Traversal"}),(0,i.jsxs)(n.td,{children:["Backend implements ",(0,i.jsx)(n.code,{children:"graph_traversal"})," interface"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Document Indexing"}),(0,i.jsxs)(n.td,{children:["Backend implements ",(0,i.jsx)(n.code,{children:"document_indexing"})," interface"]})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Why This is Better"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type-safe"}),": Compiler checks backend has required interfaces"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Self-documenting"}),": Look at implemented interfaces to know capabilities"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"No runtime surprises"}),": If interface is present, capability MUST work"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Proto-first"}),": Everything in ",(0,i.jsx)(n.code,{children:".proto"})," files, not separate YAML metadata"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"schema-registry-filesystem-layout",children:"Schema Registry Filesystem Layout"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"registry/\n\u251c\u2500\u2500 interfaces/              # Layer 1: Backend interface schemas\n\u2502   \u251c\u2500\u2500 keyvalue.yaml       # Interface definition + capabilities\n\u2502   \u251c\u2500\u2500 pubsub.yaml\n\u2502   \u251c\u2500\u2500 stream.yaml\n\u2502   \u251c\u2500\u2500 list.yaml\n\u2502   \u251c\u2500\u2500 set.yaml\n\u2502   \u251c\u2500\u2500 sortedset.yaml\n\u2502   \u251c\u2500\u2500 timeseries.yaml\n\u2502   \u251c\u2500\u2500 graph.yaml\n\u2502   \u251c\u2500\u2500 document.yaml\n\u2502   \u2514\u2500\u2500 queue.yaml\n\u2502\n\u251c\u2500\u2500 backends/                # Layer 2: Backend implementation matrix\n\u2502   \u251c\u2500\u2500 redis.yaml          # Which interfaces Redis implements\n\u2502   \u251c\u2500\u2500 postgres.yaml\n\u2502   \u251c\u2500\u2500 nats.yaml\n\u2502   \u251c\u2500\u2500 kafka.yaml\n\u2502   \u251c\u2500\u2500 dynamodb.yaml\n\u2502   \u251c\u2500\u2500 clickhouse.yaml\n\u2502   \u251c\u2500\u2500 neptune.yaml\n\u2502   \u2514\u2500\u2500 memstore.yaml\n\u2502\n\u251c\u2500\u2500 patterns/                # Layer 3: Pattern schemas with slots\n\u2502   \u251c\u2500\u2500 multicast-registry.yaml\n\u2502   \u251c\u2500\u2500 saga.yaml\n\u2502   \u251c\u2500\u2500 event-sourcing.yaml\n\u2502   \u251c\u2500\u2500 cache-aside.yaml\n\u2502   \u2514\u2500\u2500 work-queue.yaml\n\u2502\n\u251c\u2500\u2500 capabilities.yaml        # Cross-cutting capabilities definitions\n\u251c\u2500\u2500 matrix.yaml              # Complete backend \xd7 interface matrix\n\u2514\u2500\u2500 README.md                # Registry documentation\n\nproto/\n\u251c\u2500\u2500 interfaces/              # Protobuf definitions for interfaces\n\u2502   \u251c\u2500\u2500 keyvalue.proto\n\u2502   \u251c\u2500\u2500 pubsub.proto\n\u2502   \u251c\u2500\u2500 stream.proto\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u2514\u2500\u2500 patterns/                # Protobuf definitions for patterns\n    \u251c\u2500\u2500 multicast_registry.proto\n    \u251c\u2500\u2500 saga.proto\n    \u2514\u2500\u2500 ...\n\n## Benefits\n\n### 1. **Explicit Capability Mapping**\n\n"})}),"\n",(0,i.jsx)(n.h1,{id:"before-ambiguous",children:"Before (ambiguous)"}),"\n",(0,i.jsx)(n.p,{children:"backend: redis"}),"\n",(0,i.jsx)(n.h1,{id:"after-explicit",children:"After (explicit)"}),"\n",(0,i.jsx)(n.p,{children:"slots:\nregistry:\nbackend: redis\ninterface: keyvalue  # Clear which Redis interface\nrequired_capabilities:\nscan_support: true\nttl_support: true"}),"\n",(0,i.jsxs)(n.h3,{id:"2-straightforward-configuration-generation",children:["2. ",(0,i.jsx)(n.strong,{children:"Straightforward Configuration Generation"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Generate config from requirements\nrequirements = {\n    "pattern": "multicast-registry",\n    "needs_ttl": True,\n    "needs_persistence": False\n}\n\n# Find backends that satisfy requirements\nregistry_backends = find_backends(\n    interface="keyvalue",\n    capabilities={"scan_support": True, "ttl_support": True}\n)\n# \u2192 [redis, dynamodb, etcd]\n\nmessaging_backends = find_backends(\n    interface="pubsub",\n    capabilities={"persistence": False}\n)\n# \u2192 [nats, redis]\n\n# Generate config\nconfig = generate_namespace_config(\n    pattern="multicast-registry",\n    registry_backend="redis",\n    messaging_backend="nats"\n)\n\n### 3. **Backend Substitutability**\n\n'})}),"\n",(0,i.jsx)(n.h1,{id:"development-fast-local-testing",children:"Development (fast local testing)"}),"\n",(0,i.jsx)(n.p,{children:"slots:\nregistry:\nbackend: memstore\ninterface: keyvalue\nmessaging:\nbackend: nats\ninterface: pubsub"}),"\n",(0,i.jsx)(n.h1,{id:"production-durable",children:"Production (durable)"}),"\n",(0,i.jsx)(n.p,{children:"slots:\nregistry:\nbackend: redis\ninterface: keyvalue\nmessaging:\nbackend: kafka\ninterface: pubsub"}),"\n",(0,i.jsxs)(n.h3,{id:"4-pattern-portability",children:["4. ",(0,i.jsx)(n.strong,{children:"Pattern Portability"})]}),"\n",(0,i.jsx)(n.p,{children:"Same pattern works with different backend combinations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# Combination 1: Redis + NATS\nslots: {registry: redis, messaging: nats}\n\n# Combination 2: Postgres + Kafka\nslots: {registry: postgres, messaging: kafka}\n\n# Combination 3: DynamoDB + SNS\nslots: {registry: dynamodb, messaging: sns}\n\n## Implementation Phases\n\n### Phase 1: Define Interface Schemas (Week 1)\n1. Create `registry/interfaces/` with 10 core interface definitions\n2. Document capabilities per interface in `registry/capabilities.yaml`\n3. Generate protobuf files in `proto/interfaces/`\n\n### Phase 2: Backend Implementation Matrix (Week 2)\n1. Create `registry/backends/` with 8 backend definitions\n2. Map which interfaces each backend implements\n3. Document backend-specific capabilities\n4. Generate `registry/matrix.yaml` (complete backend \xd7 interface matrix)\n\n### Phase 3: Pattern Schemas (Week 3)\n1. Create `registry/patterns/` with 5 initial pattern definitions\n2. Define slots for each pattern\n3. Specify required vs optional capabilities per slot\n4. Generate pattern protobuf files in `proto/patterns/`\n\n### Phase 4: Configuration Generator (Week 4)\n1. Build `prismctl generate config` command\n2. Input: Pattern requirements + constraints\n3. Output: Valid namespace configuration\n4. Validation: Check backend implements required interfaces/capabilities\n\n### Phase 5: Registry Validation Tool (Week 5)\n1. Validate all YAML schemas\n2. Check backend \xd7 interface matrix consistency\n3. Verify capability references are valid\n4. Ensure pattern slot requirements are satisfiable\n\n## Example: Full Configuration Generation Flow\n\n"})}),"\n",(0,i.jsx)(n.h1,{id:"1-list-available-patterns",children:"1. List available patterns"}),"\n",(0,i.jsx)(n.p,{children:"$ prismctl registry patterns list\nmulticast-registry    v1    Register identities and multicast to subsets\nevent-sourcing        v1    Append-only event log with replay\nsaga                  v1    Distributed transaction coordinator\nwork-queue            v1    Background job processing with retries"}),"\n",(0,i.jsx)(n.h1,{id:"2-show-pattern-requirements",children:"2. Show pattern requirements"}),"\n",(0,i.jsx)(n.p,{children:"$ prismctl registry patterns describe multicast-registry\nPattern: multicast-registry v1\nSlots:\nregistry (required):\nInterface: keyvalue\nRequired capabilities: scan_support\nOptional capabilities: ttl_support\nRecommended backends: redis, postgres, dynamodb, etcd"}),"\n",(0,i.jsx)(n.p,{children:"messaging (required):\nInterface: pubsub\nRecommended backends: nats, redis, kafka"}),"\n",(0,i.jsx)(n.h1,{id:"3-find-backends-that-satisfy-requirements",children:"3. Find backends that satisfy requirements"}),"\n",(0,i.jsx)(n.p,{children:"$ prismctl registry backends find --interface=keyvalue --capability=scan_support\nredis       \u2713 keyvalue with scan_support, ttl_support\npostgres    \u2713 keyvalue with scan_support\ndynamodb    \u2713 keyvalue with scan_support, ttl_support\netcd        \u2713 keyvalue with scan_support, ttl_support"}),"\n",(0,i.jsx)(n.h1,{id:"4-generate-configuration",children:"4. Generate configuration"}),"\n",(0,i.jsxs)(n.p,{children:["$ prismctl generate config ",(0,i.jsx)(n.br,{}),"\n--pattern=multicast-registry ",(0,i.jsx)(n.br,{}),"\n--slot=registry:redis ",(0,i.jsx)(n.br,{}),"\n--slot=messaging:nats ",(0,i.jsx)(n.br,{}),"\n--namespace=iot-devices"]}),"\n",(0,i.jsx)(n.p,{children:"Generated config:\nnamespaces:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'name: iot-devices\npattern: multicast-registry\npattern_version: v1\nslots:\nregistry:\nbackend: redis\ninterface: keyvalue\nconfig:\nconnection: "redis://localhost:6379/0"\nmessaging:\nbackend: nats\ninterface: pubsub\nconfig:\nconnection: "nats://localhost:4222"'}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"validation-rules",children:"Validation Rules"}),"\n",(0,i.jsx)(n.h3,{id:"backend-validation",children:"Backend Validation"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Backend must declare which interfaces it implements (list of interface names)"}),"\n",(0,i.jsx)(n.li,{children:"Backend plugin must exist and match version"}),"\n",(0,i.jsxs)(n.li,{children:["All listed interfaces must have corresponding ",(0,i.jsx)(n.code,{children:".proto"})," definitions"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"pattern-validation",children:"Pattern Validation"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Pattern must declare all required slots"}),"\n",(0,i.jsx)(n.li,{children:"Each slot must specify required interfaces (list of interface names)"}),"\n",(0,i.jsx)(n.li,{children:"Optional interfaces must be marked as such"}),"\n",(0,i.jsx)(n.li,{children:"Pattern executor plugin must exist and match version"}),"\n",(0,i.jsx)(n.li,{children:"Pattern API proto file must exist"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"configuration-validation",children:"Configuration Validation"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"All required slots must be filled"}),"\n",(0,i.jsx)(n.li,{children:"Each slot's backend must implement ALL required interfaces for that slot"}),"\n",(0,i.jsxs)(n.li,{children:["Backend is validated at config-load time: ",(0,i.jsx)(n.code,{children:"prismctl validate config.yaml"})]}),"\n",(0,i.jsx)(n.li,{children:"Connection strings must match backend's expected format"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Example Validation"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ prismctl validate namespace-config.yaml\n\nValidating namespace: iot-devices\nPattern: multicast-registry v1\n\nSlot: registry\n  Backend: redis\n  Required interfaces:\n    \u2713 keyvalue_basic       (redis implements)\n    \u2713 keyvalue_scan        (redis implements)\n  Optional interfaces:\n    \u2713 keyvalue_ttl         (redis implements)\n\nSlot: messaging\n  Backend: nats\n  Required interfaces:\n    \u2713 pubsub_basic         (nats implements)\n\n\u2705 Configuration valid\n\n## Related Documents\n\n- [RFC-014: Layered Data Access Patterns](/rfc/rfc-014) - Layer 1 primitives\n- [RFC-017: Multicast Registry Pattern](/rfc/rfc-017) - Example pattern with slots\n- [MEMO-005: Client Protocol Design Philosophy](/memos/memo-005) - Layered API architecture\n- [RFC-008: Proxy Plugin Architecture](/rfc/rfc-008) - Plugin system\n\n## Revision History\n\n- 2025-10-09: Initial draft defining three-layer schema architecture (interfaces, backends, patterns)\n\n"})})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>c});var t=s(96540);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);