"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[7090],{5908:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"rust-testing-strategy","title":"ADR-020: Rust Testing Strategy","description":"Context","source":"@site/../docs-cms/adr/020-rust-testing-strategy.md","sourceDirName":".","slug":"/rust-testing-strategy","permalink":"/prism-data-layer/adr/rust-testing-strategy","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/020-rust-testing-strategy.md","tags":[{"inline":true,"label":"rust","permalink":"/prism-data-layer/adr/tags/rust"},{"inline":true,"label":"testing","permalink":"/prism-data-layer/adr/tags/testing"},{"inline":true,"label":"quality","permalink":"/prism-data-layer/adr/tags/quality"},{"inline":true,"label":"ci-cd","permalink":"/prism-data-layer/adr/tags/ci-cd"}],"version":"current","sidebarPosition":20,"frontMatter":{"title":"ADR-020: Rust Testing Strategy","status":"Accepted","date":"2025-10-07T00:00:00.000Z","deciders":"Core Team","tags":["rust","testing","quality","ci-cd"]},"sidebar":"adrSidebar","previous":{"title":"ADR-019: Rust Async Concurrency Patterns","permalink":"/prism-data-layer/adr/rust-async-concurrency-patterns"},"next":{"title":"ADR-021: Rust Structured Logging with Tracing","permalink":"/prism-data-layer/adr/rust-structured-logging"}}');var r=t(4848),i=t(8453);const l={title:"ADR-020: Rust Testing Strategy",status:"Accepted",date:new Date("2025-10-07T00:00:00.000Z"),deciders:"Core Team",tags:["rust","testing","quality","ci-cd"]},a=void 0,c={},o=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Coverage Requirements",id:"coverage-requirements",level:3},{value:"Rationale",id:"rationale",level:2},{value:"Testing Tiers",id:"testing-tiers",level:3},{value:"Tier 1: Unit Tests",id:"tier-1-unit-tests",level:4},{value:"Tier 2: Integration Tests",id:"tier-2-integration-tests",level:4},{value:"Tier 3: End-to-End Tests",id:"tier-3-end-to-end-tests",level:4},{value:"Test Utilities and Fixtures",id:"test-utilities-and-fixtures",level:3},{value:"Property-Based Testing",id:"property-based-testing",level:3},{value:"Benchmarking",id:"benchmarking",level:3},{value:"Alternatives Considered",id:"alternatives-considered",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Implementation Notes",id:"implementation-notes",level:2},{value:"Directory Structure",id:"directory-structure",level:3},{value:"Running Tests",id:"running-tests",level:3},{value:"CI Configuration",id:"ci-configuration",level:3},{value:"Dependencies",id:"dependencies",level:3},{value:"References",id:"references",level:2},{value:"Revision History",id:"revision-history",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,r.jsx)(n.p,{children:"Prism proxy requires comprehensive testing that:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Ensures correctness at multiple levels"}),"\n",(0,r.jsx)(n.li,{children:"Maintains 80%+ code coverage"}),"\n",(0,r.jsx)(n.li,{children:"Supports rapid development"}),"\n",(0,r.jsx)(n.li,{children:"Catches regressions early"}),"\n",(0,r.jsx)(n.li,{children:"Validates async code and concurrency"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Testing pyramid: Unit tests (base) \u2192 Integration tests \u2192 E2E tests (top)"}),"\n",(0,r.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,r.jsxs)(n.p,{children:["Implement ",(0,r.jsx)(n.strong,{children:"three-tier testing strategy"})," with Rust best practices:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unit Tests"}),": Module-level, test individual functions and types"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Integration Tests"}),": Test crate interactions with real backends"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"E2E Tests"}),": Validate full gRPC API with test clients"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"coverage-requirements",children:"Coverage Requirements"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Minimum"}),": 80% per crate (CI enforced)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Target"}),": 90%+ for critical crates (",(0,r.jsx)(n.code,{children:"proxy-core"}),", ",(0,r.jsx)(n.code,{children:"backend"}),", ",(0,r.jsx)(n.code,{children:"keyvalue"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"New code"}),": 100% coverage required"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"rationale",children:"Rationale"}),"\n",(0,r.jsx)(n.h3,{id:"testing-tiers",children:"Testing Tiers"}),"\n",(0,r.jsx)(n.h4,{id:"tier-1-unit-tests",children:"Tier 1: Unit Tests"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Scope"}),": Individual functions, types, and modules"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Location"}),": ",(0,r.jsx)(n.code,{children:"#[cfg(test)] mod tests"})," in same file or ",(0,r.jsx)(n.code,{children:"tests/"})," subdirectory"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pattern"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// src/backend/postgres.rs\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_validate_config_valid() {\n        let config = Config {\n            host: "localhost".to_string(),\n            port: 5432,\n            database: "test".to_string(),\n        };\n        assert!(validate_config(&config).is_ok());\n    }\n\n    #[test]\n    fn test_validate_config_invalid_port() {\n        let config = Config {\n            host: "localhost".to_string(),\n            port: 0,\n            database: "test".to_string(),\n        };\n        assert!(validate_config(&config).is_err());\n    }\n\n    #[tokio::test]\n    async fn test_connect_to_backend() {\n        let pool = create_test_pool().await;\n        let result = connect(&pool).await;\n        assert!(result.is_ok());\n    }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Characteristics"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Fast (milliseconds)"}),"\n",(0,r.jsx)(n.li,{children:"No external dependencies (use mocks)"}),"\n",(0,r.jsx)(n.li,{children:"Test edge cases and error conditions"}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"#[tokio::test]"})," for async tests"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"tier-2-integration-tests",children:"Tier 2: Integration Tests"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Scope"}),": Crate interactions, real backend integration"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Location"}),": ",(0,r.jsx)(n.code,{children:"tests/"})," directory (separate from source)"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pattern"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// tests/integration_test.rs\nuse prism_proxy::{Backend, KeyValueBackend, SqliteBackend};\nuse sqlx::SqlitePool;\n\n#[tokio::test]\nasync fn test_sqlite_backend_put_get() {\n    // Create in-memory SQLite database\n    let pool = SqlitePool::connect(":memory:").await.unwrap();\n\n    // Run migrations\n    sqlx::migrate!("./migrations")\n        .run(&pool)\n        .await\n        .unwrap();\n\n    // Create backend\n    let backend = SqliteBackend::new(pool);\n\n    // Test put\n    let items = vec![Item {\n        key: b"test-key".to_vec(),\n        value: b"test-value".to_vec(),\n        metadata: None,\n    }];\n\n    backend\n        .put("test-namespace", "test-id", items)\n        .await\n        .unwrap();\n\n    // Test get\n    let result = backend\n        .get("test-namespace", "test-id", vec![b"test-key"])\n        .await\n        .unwrap();\n\n    assert_eq!(result.len(), 1);\n    assert_eq!(result[0].key, b"test-key");\n    assert_eq!(result[0].value, b"test-value");\n}\n\n#[tokio::test]\nasync fn test_postgres_backend() {\n    // Use testcontainers for real Postgres\n    let docker = clients::Cli::default();\n    let postgres = docker.run(images::postgres::Postgres::default());\n    let port = postgres.get_host_port_ipv4(5432);\n\n    let database_url = format!("postgres://postgres:postgres@localhost:{}/test", port);\n    let pool = PgPool::connect(&database_url).await.unwrap();\n\n    // Run tests against real Postgres...\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"tier-3-end-to-end-tests",children:"Tier 3: End-to-End Tests"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Scope"}),": Full gRPC API with real server"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Location"}),": ",(0,r.jsx)(n.code,{children:"tests/e2e/"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pattern"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// tests/e2e/keyvalue_test.rs\nuse prism_proto::keyvalue::v1::{\n    key_value_service_client::KeyValueServiceClient,\n    GetRequest, PutRequest, Item,\n};\nuse tonic::transport::Channel;\n\n#[tokio::test]\nasync fn test_keyvalue_put_get_e2e() {\n    // Start test server\n    let addr = start_test_server().await;\n\n    // Connect client\n    let mut client = KeyValueServiceClient::connect(format!("http://{}", addr))\n        .await\n        .unwrap();\n\n    // Put request\n    let put_req = PutRequest {\n        namespace: "test".to_string(),\n        id: "user123".to_string(),\n        items: vec![Item {\n            key: b"profile".to_vec(),\n            value: b"Alice".to_vec(),\n            metadata: None,\n        }],\n        item_priority_token: 0,\n    };\n\n    let response = client.put(put_req).await.unwrap();\n    assert!(response.into_inner().success);\n\n    // Get request\n    let get_req = GetRequest {\n        namespace: "test".to_string(),\n        id: "user123".to_string(),\n        predicate: None,\n    };\n\n    let response = client.get(get_req).await.unwrap();\n    let items = response.into_inner().items;\n\n    assert_eq!(items.len(), 1);\n    assert_eq!(items[0].key, b"profile");\n    assert_eq!(items[0].value, b"Alice");\n}\n\nasync fn start_test_server() -> std::net::SocketAddr {\n    // Start server in background task\n    // Return address when ready\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"test-utilities-and-fixtures",children:"Test Utilities and Fixtures"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// tests/common/mod.rs\nuse sqlx::SqlitePool;\n\npub async fn create_test_db() -> SqlitePool {\n    let pool = SqlitePool::connect(":memory:").await.unwrap();\n    sqlx::migrate!("./migrations").run(&pool).await.unwrap();\n    pool\n}\n\npub fn sample_item() -> Item {\n    Item {\n        key: b"test".to_vec(),\n        value: b"value".to_vec(),\n        metadata: None,\n    }\n}\n\npub struct TestBackend {\n    pool: SqlitePool,\n}\n\nimpl TestBackend {\n    pub async fn new() -> Self {\n        Self {\n            pool: create_test_db().await,\n        }\n    }\n\n    pub async fn insert_item(&self, namespace: &str, id: &str, item: Item) {\n        // Helper for test setup\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"property-based-testing",children:"Property-Based Testing"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use proptest::prelude::*;\n\nproptest! {\n    #[test]\n    fn test_key_roundtrip(key in "\\\\PC*", value in "\\\\PC*") {\n        // Property: put then get should return same value\n        let rt = tokio::runtime::Runtime::new().unwrap();\n        rt.block_on(async {\n            let backend = TestBackend::new().await;\n            let item = Item {\n                key: key.as_bytes().to_vec(),\n                value: value.as_bytes().to_vec(),\n                metadata: None,\n            };\n\n            backend.put("test", "id", vec![item.clone()]).await.unwrap();\n            let result = backend.get("test", "id", vec![&item.key]).await.unwrap();\n\n            prop_assert_eq!(result[0].value, item.value);\n            Ok(())\n        }).unwrap();\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"benchmarking",children:"Benchmarking"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// benches/keyvalue_bench.rs\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\n\nfn bench_put(c: &mut Criterion) {\n    let rt = tokio::runtime::Runtime::new().unwrap();\n    let backend = rt.block_on(async { TestBackend::new().await });\n\n    c.bench_function("put single item", |b| {\n        b.to_async(&rt).iter(|| async {\n            let item = sample_item();\n            backend.put("test", "id", vec![item]).await.unwrap()\n        });\n    });\n}\n\ncriterion_group!(benches, bench_put);\ncriterion_main!(benches);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Only unit tests"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Pros: Fast, simple"}),"\n",(0,r.jsx)(n.li,{children:"Cons: Miss integration bugs"}),"\n",(0,r.jsx)(n.li,{children:"Rejected: Insufficient for complex system"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mock all dependencies"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Pros: Tests run fast, no external dependencies"}),"\n",(0,r.jsx)(n.li,{children:"Cons: Tests don't validate real integrations"}),"\n",(0,r.jsx)(n.li,{children:"Rejected: Integration tests must use real backends"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Fuzzing instead of property tests"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Pros: Finds deep bugs"}),"\n",(0,r.jsx)(n.li,{children:"Cons: Slow, complex setup"}),"\n",(0,r.jsx)(n.li,{children:"Deferred: Add cargo-fuzz later for critical parsers"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,r.jsx)(n.h3,{id:"positive",children:"Positive"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"High confidence in correctness"}),"\n",(0,r.jsx)(n.li,{children:"Fast unit tests (seconds)"}),"\n",(0,r.jsx)(n.li,{children:"Integration tests catch real issues"}),"\n",(0,r.jsx)(n.li,{children:"E2E tests validate gRPC API"}),"\n",(0,r.jsx)(n.li,{children:"Property tests catch edge cases"}),"\n",(0,r.jsx)(n.li,{children:"Benchmarks prevent regressions"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"negative",children:"Negative"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"More code to maintain"}),"\n",(0,r.jsx)(n.li,{children:"Integration tests require database setup"}),"\n",(0,r.jsx)(n.li,{children:"E2E tests slower (seconds)"}),"\n",(0,r.jsx)(n.li,{children:"Async tests more complex"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"neutral",children:"Neutral"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"80%+ coverage enforced in CI"}),"\n",(0,r.jsx)(n.li,{children:"Test utilities shared across tests"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,r.jsx)(n.h3,{id:"directory-structure",children:"Directory Structure"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"proxy/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 lib.rs\n\u2502   \u251c\u2500\u2500 main.rs\n\u2502   \u251c\u2500\u2500 backend/\n\u2502   \u2502   \u251c\u2500\u2500 mod.rs          # Contains #[cfg(test)] mod tests\n\u2502   \u2502   \u251c\u2500\u2500 sqlite.rs\n\u2502   \u2502   \u2514\u2500\u2500 postgres.rs\n\u2502   \u2514\u2500\u2500 keyvalue/\n\u2502       \u251c\u2500\u2500 mod.rs\n\u2502       \u2514\u2500\u2500 service.rs      # Contains #[cfg(test)] mod tests\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 common/\n\u2502   \u2502   \u2514\u2500\u2500 mod.rs          # Shared test utilities\n\u2502   \u251c\u2500\u2500 integration_test.rs\n\u2502   \u2514\u2500\u2500 e2e/\n\u2502       \u2514\u2500\u2500 keyvalue_test.rs\n\u2514\u2500\u2500 benches/\n    \u2514\u2500\u2500 keyvalue_bench.rs\n"})}),"\n",(0,r.jsx)(n.h3,{id:"running-tests",children:"Running Tests"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Unit tests only (fast)\ncargo test --lib\n\n# Integration tests\ncargo test --test integration_test\n\n# E2E tests\ncargo test --test keyvalue_test\n\n# All tests\ncargo test\n\n# With coverage\ncargo tarpaulin --out Html --output-dir coverage\n\n# Benchmarks\ncargo bench\n\n# Property tests (more iterations)\nPROPTEST_CASES=10000 cargo test\n"})}),"\n",(0,r.jsx)(n.h3,{id:"ci-configuration",children:"CI Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"# .github/workflows/rust-test.yml\njobs:\n  test:\n    steps:\n      - name: Unit Tests\n        run: cargo test --lib\n\n      - name: Integration Tests\n        run: |\n          # Start test databases\n          docker-compose -f docker-compose.test.yml up -d\n          cargo test --tests\n          docker-compose -f docker-compose.test.yml down\n\n      - name: Coverage\n        run: |\n          cargo tarpaulin --out Xml\n          if [ $(grep -oP 'line-rate=\"\\K[0-9.]+' coverage.xml | head -1 | awk '{print ($1 < 0.8)}') -eq 1 ]; then\n            echo \"Coverage below 80%\"\n            exit 1\n          fi\n\n      - name: Benchmarks (ensure no regression)\n        run: cargo bench --no-fail-fast\n"})}),"\n",(0,r.jsx)(n.h3,{id:"dependencies",children:"Dependencies"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-toml",children:'[dev-dependencies]\ntokio-test = "0.4"\nproptest = "1.4"\ncriterion = { version = "0.5", features = ["async_tokio"] }\ntestcontainers = "0.15"\n'})}),"\n",(0,r.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://doc.rust-lang.org/book/ch11-00-testing.html",children:"Rust Book: Testing"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://docs.rs/tokio/latest/tokio/attr.test.html",children:"tokio::test documentation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://docs.rs/proptest",children:"proptest documentation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://docs.rs/criterion",children:"criterion documentation"})}),"\n",(0,r.jsx)(n.li,{children:"ADR-001: Rust for the Proxy"}),"\n",(0,r.jsx)(n.li,{children:"ADR-019: Rust Async Concurrency Patterns"}),"\n",(0,r.jsx)(n.li,{children:"ADR-015: Go Testing Strategy (parallel Go patterns)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"2025-10-07: Initial draft and acceptance"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>a});var s=t(6540);const r={},i=s.createContext(r);function l(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);