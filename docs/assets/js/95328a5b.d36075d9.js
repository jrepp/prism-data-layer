"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[8990],{8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>a});var o=r(6540);const t={},s=o.createContext(t);function i(e){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),o.createElement(s.Provider,{value:n},e.children)}},9058:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"protocol-recording-protobuf-tags","title":"ADR-029: Protocol Recording with Protobuf Tagging","description":"Context","source":"@site/../docs-cms/adr/029-protocol-recording-protobuf-tags.md","sourceDirName":".","slug":"/protocol-recording-protobuf-tags","permalink":"/prism-data-layer/adr/protocol-recording-protobuf-tags","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/029-protocol-recording-protobuf-tags.md","tags":[{"inline":true,"label":"protobuf","permalink":"/prism-data-layer/adr/tags/protobuf"},{"inline":true,"label":"protocols","permalink":"/prism-data-layer/adr/tags/protocols"},{"inline":true,"label":"observability","permalink":"/prism-data-layer/adr/tags/observability"},{"inline":true,"label":"debugging","permalink":"/prism-data-layer/adr/tags/debugging"}],"version":"current","sidebarPosition":29,"frontMatter":{"title":"ADR-029: Protocol Recording with Protobuf Tagging","status":"Accepted","date":"2025-10-07T00:00:00.000Z","deciders":"Core Team","tags":["protobuf","protocols","observability","debugging"]},"sidebar":"adrSidebar","previous":{"title":"ADR-028: Admin UI with FastAPI and gRPC-Web","permalink":"/prism-data-layer/adr/admin-ui-fastapi-grpc-web"},"next":{"title":"ADR-030: Schema Recording with Protobuf Tagging","permalink":"/prism-data-layer/adr/schema-recording-protobuf-tags"}}');var t=r(4848),s=r(8453);const i={title:"ADR-029: Protocol Recording with Protobuf Tagging",status:"Accepted",date:new Date("2025-10-07T00:00:00.000Z"),deciders:"Core Team",tags:["protobuf","protocols","observability","debugging"]},a=void 0,l={},c=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Why Custom Protobuf Options",id:"why-custom-protobuf-options",level:3},{value:"Protocol Option Definition",id:"protocol-option-definition",level:3},{value:"Tagged Message Examples",id:"tagged-message-examples",level:3},{value:"Recording Infrastructure",id:"recording-infrastructure",level:3},{value:"Storage Backends",id:"storage-backends",level:3},{value:"Query Interface",id:"query-interface",level:3},{value:"Privacy Considerations",id:"privacy-considerations",level:3},{value:"Configuration",id:"configuration",level:3},{value:"Alternatives Considered",id:"alternatives-considered",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Implementation Notes",id:"implementation-notes",level:2},{value:"Code Generation",id:"code-generation",level:3},{value:"Database Schema",id:"database-schema",level:3},{value:"References",id:"references",level:2},{value:"Revision History",id:"revision-history",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,t.jsx)(n.p,{children:"Prism handles complex distributed protocols (Queue, PubSub, Transact) across multiple services. Need to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Record protocol interactions for debugging"}),"\n",(0,t.jsx)(n.li,{children:"Trace multi-step operations"}),"\n",(0,t.jsx)(n.li,{children:"Reconstruct failure scenarios"}),"\n",(0,t.jsx)(n.li,{children:"Audit protocol compliance"}),"\n",(0,t.jsx)(n.li,{children:"Enable replay for testing"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Requirements:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Capture protocol messages without code changes"}),"\n",(0,t.jsx)(n.li,{children:"Tag messages for categorization and filtering"}),"\n",(0,t.jsx)(n.li,{children:"Support sampling (don't record everything)"}),"\n",(0,t.jsx)(n.li,{children:"Queryable storage"}),"\n",(0,t.jsx)(n.li,{children:"Privacy-aware (PII handling)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.strong,{children:"Protobuf custom options for protocol recording tags"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["Custom option ",(0,t.jsx)(n.code,{children:"(prism.protocol)"})]}),": Tag messages for recording"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Recording levels"}),": ",(0,t.jsx)(n.code,{children:"NONE"}),", ",(0,t.jsx)(n.code,{children:"METADATA"}),", ",(0,t.jsx)(n.code,{children:"FULL"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sampling policy"}),": Configurable per message type"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Storage backend"}),": Pluggable (file, database, S3)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Query interface"}),": Filter by tags, time, session, operation"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"rationale",children:"Rationale"}),"\n",(0,t.jsx)(n.h3,{id:"why-custom-protobuf-options",children:"Why Custom Protobuf Options"}),"\n",(0,t.jsxs)(n.p,{children:["Protobuf options allow ",(0,t.jsx)(n.strong,{children:"declarative metadata"})," on messages:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"No code changes needed"}),"\n",(0,t.jsx)(n.li,{children:"Centralized configuration"}),"\n",(0,t.jsx)(n.li,{children:"Type-safe"}),"\n",(0,t.jsx)(n.li,{children:"Code generation aware"}),"\n",(0,t.jsx)(n.li,{children:"Version controlled"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"protocol-option-definition",children:"Protocol Option Definition"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-protobuf",children:'// proto/prism/options.proto\nsyntax = "proto3";\n\npackage prism;\n\nimport "google/protobuf/descriptor.proto";\n\n// Protocol recording options\nextend google.protobuf.MessageOptions {\n  ProtocolOptions protocol = 50100;\n}\n\nmessage ProtocolOptions {\n  // Recording level for this message type\n  RecordingLevel recording = 1;\n\n  // Protocol category\n  string category = 2;  // "queue", "pubsub", "transact", "session"\n\n  // Operation name\n  string operation = 3;  // "publish", "subscribe", "write", "commit"\n\n  // Sampling rate (0.0 - 1.0)\n  float sample_rate = 4 [default = 1.0];\n\n  // Include in protocol trace\n  bool trace = 5 [default = true];\n\n  // Tags for filtering\n  repeated string tags = 6;\n}\n\nenum RecordingLevel {\n  RECORDING_LEVEL_UNSPECIFIED = 0;\n  RECORDING_LEVEL_NONE = 1;        // Don\'t record\n  RECORDING_LEVEL_METADATA = 2;    // Record metadata only (no payload)\n  RECORDING_LEVEL_FULL = 3;        // Record complete message\n  RECORDING_LEVEL_SAMPLED = 4;     // Sample based on sample_rate\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"tagged-message-examples",children:"Tagged Message Examples"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Queue Protocol:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-protobuf",children:'// proto/prism/queue/v1/queue.proto\nimport "prism/options.proto";\n\nmessage PublishRequest {\n  option (prism.protocol) = {\n    recording: RECORDING_LEVEL_FULL\n    category: "queue"\n    operation: "publish"\n    sample_rate: 0.1  // Record 10% of publish requests\n    tags: ["write", "producer"]\n  };\n\n  string session_token = 1;\n  string topic = 2;\n  bytes payload = 3;\n  // ...\n}\n\nmessage PublishResponse {\n  option (prism.protocol) = {\n    recording: RECORDING_LEVEL_METADATA\n    category: "queue"\n    operation: "publish_response"\n    tags: ["write", "producer"]\n  };\n\n  string message_id = 1;\n  int64 offset = 2;\n  // ...\n}\n\nmessage Message {\n  option (prism.protocol) = {\n    recording: RECORDING_LEVEL_SAMPLED\n    category: "queue"\n    operation: "message_delivery"\n    sample_rate: 0.05  // Record 5% of messages\n    tags: ["read", "consumer"]\n  };\n\n  string message_id = 1;\n  bytes payload = 2;\n  // ...\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Transaction Protocol:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-protobuf",children:'// proto/prism/transact/v1/transact.proto\nmessage WriteRequest {\n  option (prism.protocol) = {\n    recording: RECORDING_LEVEL_FULL\n    category: "transact"\n    operation: "write"\n    sample_rate: 1.0  // Record all transactions\n    trace: true\n    tags: ["transaction", "write", "critical"]\n  };\n\n  DataWrite data = 1;\n  MailboxWrite mailbox = 2;\n  // ...\n}\n\nmessage TransactionStarted {\n  option (prism.protocol) = {\n    recording: RECORDING_LEVEL_METADATA\n    category: "transact"\n    operation: "begin"\n    tags: ["transaction", "lifecycle"]\n  };\n\n  string transaction_id = 1;\n  // ...\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"recording-infrastructure",children:"Recording Infrastructure"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Protocol Recorder Interface:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// proxy/src/protocol/recorder.rs\nuse prost::Message;\n\n#[async_trait]\npub trait ProtocolRecorder: Send + Sync {\n    async fn record(&self, entry: ProtocolEntry) -> Result<()>;\n    async fn query(&self, filter: ProtocolFilter) -> Result<Vec<ProtocolEntry>>;\n}\n\npub struct ProtocolEntry {\n    pub id: String,\n    pub timestamp: Timestamp,\n    pub session_id: Option<String>,\n    pub category: String,\n    pub operation: String,\n    pub message_type: String,\n    pub recording_level: RecordingLevel,\n    pub metadata: HashMap<String, String>,\n    pub payload: Option<Vec<u8>>,  // Only if FULL recording\n    pub tags: Vec<String>,\n}\n\npub struct ProtocolFilter {\n    pub start_time: Option<Timestamp>,\n    pub end_time: Option<Timestamp>,\n    pub session_id: Option<String>,\n    pub category: Option<String>,\n    pub operation: Option<String>,\n    pub tags: Vec<String>,\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Interceptor for Recording:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// proxy/src/protocol/interceptor.rs\npub struct RecordingInterceptor {\n    recorder: Arc<dyn ProtocolRecorder>,\n    sampler: Arc<Sampler>,\n}\n\nimpl Interceptor for RecordingInterceptor {\n    fn call(&mut self, req: Request<()>) -> Result<Request<()>, Status> {\n        let message_type = req.extensions().get::<MessageType>().unwrap();\n\n        // Get protocol options from generated code\n        let options = get_protocol_options(message_type);\n\n        // Check if should record\n        if !should_record(&options, &self.sampler) {\n            return Ok(req);\n        }\n\n        // Extract metadata\n        let metadata = extract_metadata(&req);\n\n        // Get payload based on recording level\n        let payload = match options.recording {\n            RecordingLevel::Full => Some(req.get_ref().encode_to_vec()),\n            _ => None,\n        };\n\n        // Record\n        let entry = ProtocolEntry {\n            id: Uuid::new_v4().to_string(),\n            timestamp: Utc::now(),\n            session_id: metadata.get("session_id").cloned(),\n            category: options.category.clone(),\n            operation: options.operation.clone(),\n            message_type: message_type.clone(),\n            recording_level: options.recording,\n            metadata,\n            payload,\n            tags: options.tags.clone(),\n        };\n\n        tokio::spawn(async move {\n            recorder.record(entry).await.ok();\n        });\n\n        Ok(req)\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Sampling Logic:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct Sampler {\n    rng: ThreadRng,\n}\n\nimpl Sampler {\n    fn should_sample(&self, sample_rate: f32) -> bool {\n        if sample_rate >= 1.0 {\n            return true;\n        }\n        if sample_rate <= 0.0 {\n            return false;\n        }\n\n        self.rng.gen::<f32>() < sample_rate\n    }\n}\n\nfn should_record(options: &ProtocolOptions, sampler: &Sampler) -> bool {\n    match options.recording {\n        RecordingLevel::None => false,\n        RecordingLevel::Metadata | RecordingLevel::Full => true,\n        RecordingLevel::Sampled => sampler.should_sample(options.sample_rate),\n        RecordingLevel::Unspecified => false,\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"storage-backends",children:"Storage Backends"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"File Storage:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'pub struct FileProtocolRecorder {\n    path: PathBuf,\n}\n\nimpl ProtocolRecorder for FileProtocolRecorder {\n    async fn record(&self, entry: ProtocolEntry) -> Result<()> {\n        let json = serde_json::to_string(&entry)?;\n        let mut file = OpenOptions::new()\n            .create(true)\n            .append(true)\n            .open(&self.path)?;\n        writeln!(file, "{}", json)?;\n        Ok(())\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"PostgreSQL Storage:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'pub struct PostgresProtocolRecorder {\n    pool: PgPool,\n}\n\nimpl ProtocolRecorder for PostgresProtocolRecorder {\n    async fn record(&self, entry: ProtocolEntry) -> Result<()> {\n        sqlx::query(\n            r#"\n            INSERT INTO protocol_recordings\n            (id, timestamp, session_id, category, operation, message_type,\n             recording_level, metadata, payload, tags)\n            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)\n            "#\n        )\n        .bind(&entry.id)\n        .bind(&entry.timestamp)\n        .bind(&entry.session_id)\n        .bind(&entry.category)\n        .bind(&entry.operation)\n        .bind(&entry.message_type)\n        .bind(&entry.recording_level)\n        .bind(&entry.metadata)\n        .bind(&entry.payload)\n        .bind(&entry.tags)\n        .execute(&self.pool)\n        .await?;\n\n        Ok(())\n    }\n\n    async fn query(&self, filter: ProtocolFilter) -> Result<Vec<ProtocolEntry>> {\n        let mut query = QueryBuilder::new(\n            "SELECT * FROM protocol_recordings WHERE 1=1"\n        );\n\n        if let Some(start) = filter.start_time {\n            query.push(" AND timestamp >= ").push_bind(start);\n        }\n        if let Some(category) = filter.category {\n            query.push(" AND category = ").push_bind(category);\n        }\n        if !filter.tags.is_empty() {\n            query.push(" AND tags && ").push_bind(&filter.tags);\n        }\n\n        query.push(" ORDER BY timestamp DESC LIMIT 1000");\n\n        let entries = query\n            .build_query_as::<ProtocolEntry>()\n            .fetch_all(&self.pool)\n            .await?;\n\n        Ok(entries)\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"query-interface",children:"Query Interface"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"CLI Tool:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'# Query protocol recordings\nprism-admin protocol query \\\n  --category queue \\\n  --operation publish \\\n  --session abc123 \\\n  --start "2025-10-07T00:00:00Z" \\\n  --tags write,producer\n\n# Replay protocol sequence\nprism-admin protocol replay \\\n  --session abc123 \\\n  --start "2025-10-07T12:00:00Z" \\\n  --end "2025-10-07T12:05:00Z"\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"gRPC Admin API:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-protobuf",children:"service AdminService {\n  // Query protocol recordings\n  rpc QueryProtocol(QueryProtocolRequest) returns (stream ProtocolEntry);\n\n  // Replay protocol sequence\n  rpc ReplayProtocol(ReplayProtocolRequest) returns (stream ReplayEvent);\n}\n\nmessage QueryProtocolRequest {\n  optional google.protobuf.Timestamp start_time = 1;\n  optional google.protobuf.Timestamp end_time = 2;\n  optional string session_id = 3;\n  optional string category = 4;\n  optional string operation = 5;\n  repeated string tags = 6;\n  int32 limit = 7;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"privacy-considerations",children:"Privacy Considerations"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"PII in Protocol Messages:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-protobuf",children:'message UserProfile {\n  option (prism.protocol) = {\n    recording: RECORDING_LEVEL_METADATA  // Don\'t record full payload\n    category: "data"\n    operation: "user_profile"\n    tags: ["pii", "sensitive"]\n  };\n\n  string user_id = 1;\n  string email = 2 [(prism.pii) = "email"];  // Flagged as PII\n  string name = 3 [(prism.pii) = "name"];\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Automatic PII Scrubbing:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'fn scrub_pii(entry: &mut ProtocolEntry) {\n    if entry.tags.contains(&"pii".to_string()) {\n        // Scrub payload if contains PII\n        if let Some(payload) = &mut entry.payload {\n            *payload = scrub_pii_from_bytes(payload);\n        }\n\n        // Scrub metadata\n        for (key, value) in &mut entry.metadata {\n            if is_pii_field(key) {\n                *value = "[REDACTED]".to_string();\n            }\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"configuration",children:"Configuration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'# proxy/config.yaml\nprotocol_recording:\n  enabled: true\n  backend: postgres\n  postgres:\n    connection_string: postgres://...\n    table: protocol_recordings\n\n  # Override recording levels\n  overrides:\n    - message_type: "prism.queue.v1.Message"\n      recording: RECORDING_LEVEL_NONE  # Disable for performance\n    - category: "transact"\n      recording: RECORDING_LEVEL_FULL  # Always record transactions\n\n  # Global sampling\n  default_sample_rate: 0.1  # 10% by default\n\n  # Retention\n  retention_days: 30\n  auto_cleanup: true\n'})}),"\n",(0,t.jsx)(n.h3,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Application-level logging"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Pros: Simple, already exists"}),"\n",(0,t.jsx)(n.li,{children:"Cons: Not structured, hard to query, scattered"}),"\n",(0,t.jsx)(n.li,{children:"Rejected: Need structured protocol-specific recording"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Network packet capture"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Pros: Captures everything, no code changes"}),"\n",(0,t.jsx)(n.li,{children:"Cons: Binary parsing, performance impact, storage intensive"}),"\n",(0,t.jsx)(n.li,{children:"Rejected: Too low-level, hard to query"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"OpenTelemetry spans"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Pros: Standard, integrates with tracing"}),"\n",(0,t.jsx)(n.li,{children:"Cons: Not protocol-specific, limited queryability"}),"\n",(0,t.jsx)(n.li,{children:"Deferred: Use for tracing, protocol recording for detailed protocol analysis"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,t.jsx)(n.h3,{id:"positive",children:"Positive"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Declarative"}),": Protocol recording via protobuf tags"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type-safe"}),": Options validated at compile time"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Queryable"}),": Structured storage enables filtering"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sampling"}),": Control recording overhead"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Privacy-aware"}),": PII handling built-in"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Debuggable"}),": Reconstruct protocol sequences"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"negative",children:"Negative"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Storage overhead"}),": Recording consumes storage"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance impact"}),": Interceptor adds latency (mitigated by async)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Complexity"}),": Another system to manage"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"neutral",children:"Neutral"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Retention policy"}),": Must configure cleanup"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Query performance"}),": Depends on storage backend"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,t.jsx)(n.h3,{id:"code-generation",children:"Code Generation"}),"\n",(0,t.jsx)(n.p,{children:"Extract protocol options in build:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// build.rs\nfn main() {\n    // Generate protocol option extractors\n    prost_build::Config::new()\n        .type_attribute(".", "#[derive(serde::Serialize)]")\n        .compile_protos(&["proto/prism/queue/v1/queue.proto"], &["proto/"])\n        .unwrap();\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"database-schema",children:"Database Schema"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE protocol_recordings (\n    id UUID PRIMARY KEY,\n    timestamp TIMESTAMPTZ NOT NULL,\n    session_id TEXT,\n    category TEXT NOT NULL,\n    operation TEXT NOT NULL,\n    message_type TEXT NOT NULL,\n    recording_level TEXT NOT NULL,\n    metadata JSONB,\n    payload BYTEA,\n    tags TEXT[],\n\n    -- Indexes for querying\n    INDEX idx_timestamp ON protocol_recordings(timestamp),\n    INDEX idx_session ON protocol_recordings(session_id),\n    INDEX idx_category ON protocol_recordings(category),\n    INDEX idx_tags ON protocol_recordings USING GIN(tags)\n);\n\n-- Retention policy\nCREATE INDEX idx_retention ON protocol_recordings(timestamp)\nWHERE timestamp < NOW() - INTERVAL '30 days';\n"})}),"\n",(0,t.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://protobuf.dev/programming-guides/proto3/#options",children:"Protobuf Options"})}),"\n",(0,t.jsx)(n.li,{children:"ADR-003: Protobuf as Single Source of Truth"}),"\n",(0,t.jsx)(n.li,{children:"ADR-008: Observability Strategy"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"2025-10-07: Initial draft and acceptance"}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);