"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[74734],{28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>c});var t=r(96540);const s={},i=t.createContext(s);function o(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(i.Provider,{value:n},e.children)}},41699:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"adr-038","title":"Backend Connector Buffer Architecture","description":"Context","source":"@site/../docs-cms/adr/adr-038-backend-connector-buffers.md","sourceDirName":".","slug":"/adr-038","permalink":"/prism-data-layer/adr/adr-038","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/adr-038-backend-connector-buffers.md","tags":[{"inline":true,"label":"architecture","permalink":"/prism-data-layer/adr/tags/architecture"},{"inline":true,"label":"performance","permalink":"/prism-data-layer/adr/tags/performance"},{"inline":true,"label":"backend","permalink":"/prism-data-layer/adr/tags/backend"},{"inline":true,"label":"isolation","permalink":"/prism-data-layer/adr/tags/isolation"},{"inline":true,"label":"scalability","permalink":"/prism-data-layer/adr/tags/scalability"}],"version":"current","frontMatter":{"date":"2025-10-08T00:00:00.000Z","deciders":"System","doc_uuid":"43c93d9f-02f6-4391-873e-148c1d775fcd","id":"adr-038","project_id":"prism-data-layer","status":"Proposed","tags":["architecture","performance","backend","isolation","scalability"],"title":"Backend Connector Buffer Architecture"},"sidebar":"adrSidebar","previous":{"title":"Kubernetes Operator with Custom Resource Definitions \u2022 ADR-037","permalink":"/prism-data-layer/adr/adr-037"},"next":{"title":"CLI Acceptance Testing with testscript \u2022 ADR-039","permalink":"/prism-data-layer/adr/adr-039"}}');var s=r(74848),i=r(28453);const o={date:new Date("2025-10-08T00:00:00.000Z"),deciders:"System",doc_uuid:"43c93d9f-02f6-4391-873e-148c1d775fcd",id:"adr-038",project_id:"prism-data-layer",status:"Proposed",tags:["architecture","performance","backend","isolation","scalability"],title:"Backend Connector Buffer Architecture"},c=void 0,a={},l=[{value:"Context",id:"context",level:2},{value:"Current State: Connector Logic in Plugins",id:"current-state-connector-logic-in-plugins",level:3},{value:"Real-World Scenario (Netflix Scale)",id:"real-world-scenario-netflix-scale",level:3},{value:"Decision",id:"decision",level:2},{value:"Architecture",id:"architecture",level:3},{value:"References",id:"references",level:2},{value:"Revision History",id:"revision-history",level:2}];function d(e){const n={a:"a",code:"code",executeresponse:"executeresponse",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,s.jsx)(n.p,{children:"Backend connector logic (connection pooling, query buffering, batching, retries) currently lives inside backend plugins (RFC-008). As Prism scales, we face challenges:"}),"\n",(0,s.jsx)(n.h3,{id:"current-state-connector-logic-in-plugins",children:"Current State: Connector Logic in Plugins"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// PostgreSQL plugin manages its own connection pool and buffering\npub struct PostgresPlugin {\n    pool: deadpool_postgres::Pool,  // Connection pool\n    query_buffer: VecDeque<Query>,  // Buffering for batch execution\n    retry_queue: RetryQueue,         // Retry logic\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problems"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource Contention"}),": Plugin connection pools compete for database connections"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No Centralized Control"}),": Can't enforce global limits (e.g., max 500 connections to Postgres cluster)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Plugin Complexity"}),": Each plugin reimplements buffering, retries, batching"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scaling Challenges"}),": Can't scale connector independently of plugin business logic"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Observability Gaps"}),": Connection metrics scattered across plugins"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"real-world-scenario-netflix-scale",children:"Real-World Scenario (Netflix Scale)"}),"\n",(0,s.jsx)(n.p,{children:"From Netflix metrics:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"8M QPS"})," across key-value abstraction"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multiple backends"}),": Cassandra, EVCache, PostgreSQL"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": Without centralized connector management, connection storms during traffic spikes overwhelm databases"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Specific issues"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Connection pool exhaustion when one plugin has traffic spike"}),"\n",(0,s.jsx)(n.li,{children:"No global rate limiting (each plugin rate-limits independently)"}),"\n",(0,s.jsx)(n.li,{children:"Difficult to implement backend-wide circuit breaking"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:'Extract backend connector logic into separate, scalable "connector buffer" processes'}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"architecture",children:"Architecture"}),"\n",(0,s.jsx)(n.p,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        Prism Proxy (Rust)                       \u2502\n\u2502                                                                 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 PostgreSQL   \u2502      \u2502    Redis     \u2502      \u2502    Kafka     \u2502 \u2502\n\u2502  \u2502   Plugin     \u2502      \u2502   Plugin     \u2502      \u2502   Plugin     \u2502 \u2502\n\u2502  \u2502  (Business   \u2502      \u2502  (Business   \u2502      \u2502  (Business   \u2502 \u2502\n\u2502  \u2502   Logic)     \u2502      \u2502   Logic)     \u2502      \u2502   Logic)     \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502         \u2502                     \u2502                     \u2502         \u2502\n\u2502         \u2502 gRPC                \u2502 gRPC                \u2502 gRPC    \u2502\n\u2502         \u25bc                     \u25bc                     \u25bc         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2502                     \u2502                     \u2502\n\u2502                     \u2502                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  PostgreSQL       \u2502  \u2502  Redis          \u2502  \u2502  Kafka          \u2502\n\u2502  Connector        \u2502  \u2502  Connector      \u2502  \u2502  Connector      \u2502\n\u2502  Buffer           \u2502  \u2502  Buffer         \u2502  \u2502  Buffer         \u2502\n\u2502  (Go Process)     \u2502  \u2502  (Go Process)   \u2502  \u2502  (Go Process)   \u2502\n\u2502                   \u2502  \u2502                 \u2502  \u2502                 \u2502\n\u2502  - Conn Pool      \u2502  \u2502  - Conn Pool    \u2502  \u2502  - Producer     \u2502\n\u2502  - Batching       \u2502  \u2502  - Pipelining   \u2502  \u2502    Pool         \u2502\n\u2502  - Retries        \u2502  \u2502  - Clustering   \u2502  \u2502  - Batching     \u2502\n\u2502  - Rate Limiting  \u2502  \u2502  - Failover     \u2502  \u2502  - Partitioning \u2502\n\u2502  - Circuit Break  \u2502  \u2502                 \u2502  \u2502  - Compression  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2502                     \u2502                     \u2502\n\u25bc                     \u25bc                     \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  PostgreSQL  \u2502      \u2502    Redis     \u2502      \u2502    Kafka     \u2502\n\u2502   Cluster    \u2502      \u2502   Cluster    \u2502      \u2502   Cluster    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n### Connector Buffer Responsibilities\n\n| Responsibility | Description | Example |\n|----------------|-------------|---------|\n| **Connection Pooling** | Manage connections to backend, enforce limits | 500 connections max to Postgres |\n| **Request Batching** | Combine multiple requests into batches | MGET in Redis, batch INSERT in Postgres |\n| **Buffering** | Queue requests during transient failures | Buffer 10K requests during 5s outage |\n| **Retries** | Retry failed requests with backoff | Exponential backoff: 100ms, 200ms, 400ms |\n| **Rate Limiting** | Enforce backend-wide rate limits | Max 10K QPS to ClickHouse |\n| **Circuit Breaking** | Stop requests to unhealthy backend | Open circuit after 10 consecutive failures |\n| **Load Balancing** | Distribute requests across backend instances | Round-robin across 5 Postgres replicas |\n| **Health Checks** | Monitor backend health | TCP ping every 10s |\n\n### Plugin Simplification\n\n**Before** (plugin does everything):\n"})}),"\n",(0,s.jsxs)(n.p,{children:["impl PostgresPlugin {\nasync fn execute(&self, req: ExecuteRequest) -> Result",(0,s.jsx)(n.executeresponse,{children:" {\n// Plugin manages:\n// - Connection from pool\n// - Batching logic\n// - Retry on failure\n// - Metrics recording\nlet conn = self.pool.get().await?;\nlet result = self.execute_with_retry(conn, req).await?;\nself.record_metrics(&result);\nOk(result)\n}\n}"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n**After** (plugin delegates to connector):\n"})}),"\n",(0,s.jsxs)(n.p,{children:["impl PostgresPlugin {\nasync fn execute(&self, req: ExecuteRequest) -> Result",(0,s.jsx)(n.executeresponse,{children:" {\n// Plugin just translates request \u2192 connector format\nlet connector_req = self.to_connector_request(req);"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"    // Connector handles pooling, batching, retries\n    let response = self.connector_client.execute(connector_req).await?;\n\n    Ok(self.to_plugin_response(response))\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"}"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n## Rationale\n\n### Why Separate Connectors?\n\n**1. Independent Scaling**\n\nCompute-heavy backends (ClickHouse aggregations, graph queries) need more CPU than connection management:\n\n"})}),"\n",(0,s.jsx)(n.h1,{id:"scale-plugin-for-compute-rust",children:"Scale plugin for compute (Rust)"}),"\n",(0,s.jsx)(n.p,{children:'apiVersion: v1\nkind: Deployment\nmetadata:\nname: clickhouse-plugin\nspec:\nreplicas: 10  # Many instances for parallel aggregation\nresources:\ncpu: "4"    # CPU-heavy'}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h1,{id:"scale-connector-for-connections-go",children:"Scale connector for connections (Go)"}),"\n",(0,s.jsx)(n.p,{children:'apiVersion: v1\nkind: Deployment\nmetadata:\nname: clickhouse-connector\nspec:\nreplicas: 2   # Few instances, each holds many connections\nresources:\ncpu: "1"\nconnections: 500  # Many connections per instance'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n**2. Language Choice**\n\n- **Plugin (Rust)**: Business logic, high performance, type safety\n- **Connector (Go)**: Excellent database client libraries, mature connection pooling\n\n**Go advantages for connectors**:\n- `database/sql`: Standard connection pooling\n- Mature libraries: pgx (PostgreSQL), go-redis, sarama (Kafka)\n- Built-in connection management, health checks\n\n**3. Failure Isolation**\n\nPlugin crash doesn't lose connections:\n\nPlugin crashes \u2192 Connector keeps connections alive \u2192 New plugin instance reconnects to connector\n"})}),"\n",(0,s.jsx)(n.p,{children:"Without separation:\nPlugin crashes \u2192 All connections lost \u2192 Reconnect storm to database"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n**4. Global Resource Management**\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"// Connector enforces global limits across all plugin instances\ntype PostgresConnector struct {\nglobalPool *pgxpool.Pool  // Max 500 connections globally"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"// All plugin instances share this pool\nrateLimiter rate.Limiter  // Max 10K QPS globally\n"})}),"\n",(0,s.jsx)(n.p,{children:"}"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n### Why Go for Connectors?\n\n| Aspect | Rust | Go |\n|--------|------|-----|\n| **DB Libraries** | Emerging (tokio-postgres, redis-rs) | Mature (pgx, go-redis, mongo-driver) |\n| **Connection Pooling** | Manual (deadpool, r2d2) | Built-in (database/sql) |\n| **Goroutines** | Async tasks (tokio) | Native green threads |\n| **Ecosystem** | Growing | Established for databases |\n| **Development Speed** | Slower (lifetimes, trait complexity) | Faster (simple concurrency) |\n\n**Decision**: **Go for connectors, Rust for plugins**\n\n## Alternatives Considered\n\n### 1. Keep Connectors in Plugins (Current State)\n\n- **Pros**: Simpler architecture, no extra processes\n- **Cons**: Can't scale independently, resource contention, plugin complexity\n- **Rejected because**: Doesn't scale operationally at Netflix-level traffic\n\n### 2. Shared Rust Library for Connection Logic\n\n- **Pros**: Type safety, no IPC overhead\n- **Cons**: Still tightly coupled to plugin lifecycle, no independent scaling\n- **Rejected because**: Doesn't solve scaling and isolation problems\n\n### 3. Connector as Proxy Responsibility\n\n- **Pros**: Centralized in proxy\n- **Cons**: Proxy becomes bloated, can't scale connectors independently, language mismatch\n- **Rejected because**: Violates separation of concerns (RFC-008)\n\n## Consequences\n\n### Positive\n\n- **Independent Scaling**: Scale connectors for connection management, plugins for business logic\n- **Simplified Plugins**: Plugins focus on business logic (query translation, caching strategies)\n- **Global Resource Control**: Enforce limits across all instances (connections, rate limits)\n- **Better Isolation**: Connector failure doesn't affect plugin, plugin failure doesn't lose connections\n- **Language Optimization**: Use Go for connector (best DB libraries), Rust for plugin (best performance)\n\n### Negative\n\n- **Additional Processes**: More operational complexity (monitor, deploy, scale connectors)\n- **IPC Latency**: gRPC call from plugin \u2192 connector adds ~0.5-1ms\n- **State Synchronization**: Connector and plugin must agree on connection state\n\n### Neutral\n\n- **Deployment Complexity**: Must deploy connector alongside plugin (sidecar or separate pod)\n- **Observability**: Need metrics from both plugin and connector\n- **Configuration**: Connector needs separate config (pool size, timeouts, etc.)\n\n## Implementation Notes\n\n### Connector gRPC API\n\n"})}),"\n",(0,s.jsx)(n.p,{children:'syntax = "proto3";'}),"\n",(0,s.jsx)(n.p,{children:"package prism.connector;"}),"\n",(0,s.jsx)(n.p,{children:"service BackendConnector {\n// Execute single operation\nrpc Execute(ExecuteRequest) returns (ExecuteResponse);"}),"\n",(0,s.jsx)(n.p,{children:"// Execute batch (connector handles batching)\nrpc ExecuteBatch(stream ExecuteRequest) returns (stream ExecuteResponse);"}),"\n",(0,s.jsx)(n.p,{children:"// Health check\nrpc HealthCheck(HealthCheckRequest) returns (HealthCheckResponse);"}),"\n",(0,s.jsx)(n.p,{children:"// Connection pool stats\nrpc GetStats(GetStatsRequest) returns (ConnectorStats);\n}"}),"\n",(0,s.jsx)(n.p,{children:'message ExecuteRequest {\nstring operation = 1;  // "query", "insert", "get", etc.\nbytes params = 2;      // Backend-specific parameters\nmap<string, string> metadata = 3;\n}'}),"\n",(0,s.jsx)(n.p,{children:"message ExecuteResponse {\nbool success = 1;\nbytes result = 2;\nstring error = 3;\nConnectorMetrics metrics = 4;\n}"}),"\n",(0,s.jsx)(n.p,{children:"message ConnectorStats {\nint64 active_connections = 1;\nint64 idle_connections = 2;\nint64 total_requests = 3;\nint64 queued_requests = 4;\ndouble avg_latency_ms = 5;\n}"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n### PostgreSQL Connector Example (Go)\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"package main"}),"\n",(0,s.jsx)(n.p,{children:'import (\n"context"\n"github.com/jackc/pgx/v5/pgxpool"\npb "prism/proto/connector"\n)'}),"\n",(0,s.jsx)(n.p,{children:"type PostgresConnector struct {\npool *pgxpool.Pool\nrateLimiter *rate.Limiter\ncircuitBreaker *CircuitBreaker\n}"}),"\n",(0,s.jsx)(n.p,{children:"func (c *PostgresConnector) Execute(ctx context.Context, req *pb.ExecuteRequest) (*pb.ExecuteResponse, error) {\n// 1. Rate limiting\nif err := c.rateLimiter.Wait(ctx); err != nil {\nreturn nil, err\n}"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"// 2. Circuit breaker check\nif !c.circuitBreaker.Allow() {\n    return nil, ErrCircuitOpen\n}\n\n// 3. Get connection from pool\nconn, err := c.pool.Acquire(ctx)\nif err != nil {\n    return nil, err\n}\ndefer conn.Release()\n\n// 4. Execute query\nresult, err := conn.Query(ctx, req.Query, req.Params...)\nif err != nil {\n    c.circuitBreaker.RecordFailure()\n    return nil, err\n}\n\nc.circuitBreaker.RecordSuccess()\nreturn &pb.ExecuteResponse{Success: true, Result: result}, nil\n"})}),"\n",(0,s.jsx)(n.p,{children:"}"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n### Deployment Topology\n\n**Option 1: Sidecar Pattern** (Recommended for Kubernetes):\n"})}),"\n",(0,s.jsx)(n.p,{children:"apiVersion: v1\nkind: Pod\nmetadata:\nname: prism-playback-0\nspec:\ncontainers:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"name: prism-proxy\nimage: prism/proxy:latest"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"name: postgres-connector\nimage: prism/postgres-connector:latest\nenv:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'name: POSTGRES_URL\nvalue: "postgres://db:5432"'}),"\n",(0,s.jsx)(n.li,{children:'name: POOL_SIZE\nvalue: "100"'}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"name: postgres-plugin\nimage: prism/postgres-plugin:latest\nenv:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'name: CONNECTOR_ENDPOINT\nvalue: "localhost:50200"  # Talk to sidecar connector'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n**Option 2: Shared Connector Pool** (For bare metal):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Prism Instance 1   \u2502\u2500\u2500\u2510\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n                          \u251c\u2500\u25ba Shared Postgres Connector (500 connections)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502       \u2193\n\u2502  Prism Instance 2   \u2502\u2500\u2500\u2518   PostgreSQL Cluster\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"RFC-008: Proxy Plugin Architecture (plugins delegate to connectors)"}),"\n",(0,s.jsx)(n.li,{children:"ADR-035: Connection Pooling (connector implements pooling)"}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/jackc/pgx",children:"pgx Connection Pool"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/redis/go-redis",children:"go-redis Clustering"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/IBM/sarama",children:"Sarama Kafka Client"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/Netflix/Hystrix",children:"Netflix Hystrix"})," (circuit breaker pattern)"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"2025-10-08: Initial draft proposing Go-based connector buffers"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);