"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[3691],{5110:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"backend-plugin-architecture","title":"ADR-005: Backend Plugin Architecture","description":"Context","source":"@site/../docs-cms/adr/005-backend-plugin-architecture.md","sourceDirName":".","slug":"/backend-plugin-architecture","permalink":"/prism-data-layer/adr/backend-plugin-architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/005-backend-plugin-architecture.md","tags":[{"inline":true,"label":"backend","permalink":"/prism-data-layer/adr/tags/backend"},{"inline":true,"label":"architecture","permalink":"/prism-data-layer/adr/tags/architecture"},{"inline":true,"label":"dx","permalink":"/prism-data-layer/adr/tags/dx"}],"version":"current","sidebarPosition":5,"frontMatter":{"title":"ADR-005: Backend Plugin Architecture","status":"Accepted","date":"2025-10-05T00:00:00.000Z","deciders":"Core Team","tags":["backend","architecture","dx"]},"sidebar":"adrSidebar","previous":{"title":"ADR-004: Local-First Testing Strategy","permalink":"/prism-data-layer/adr/local-first-testing"},"next":{"title":"ADR-006: Namespace and Multi-Tenancy","permalink":"/prism-data-layer/adr/namespace-multi-tenancy"}}');var i=s(4848),r=s(8453);const a={title:"ADR-005: Backend Plugin Architecture",status:"Accepted",date:new Date("2025-10-05T00:00:00.000Z"),deciders:"Core Team",tags:["backend","architecture","dx"]},c=void 0,l={},d=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Architecture",id:"architecture",level:3},{value:"Backend Registry",id:"backend-registry",level:3},{value:"Namespace Configuration",id:"namespace-configuration",level:3},{value:"Routing",id:"routing",level:3},{value:"Alternatives Considered",id:"alternatives-considered",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Implementation Notes",id:"implementation-notes",level:2},{value:"Backend Interface Per Abstraction",id:"backend-interface-per-abstraction",level:3},{value:"Backend Capabilities",id:"backend-capabilities",level:3},{value:"Extension Traits for Backend-Specific Features",id:"extension-traits-for-backend-specific-features",level:3},{value:"Testing",id:"testing",level:3},{value:"References",id:"references",level:2},{value:"Revision History",id:"revision-history",level:2}];function o(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,i.jsx)(n.p,{children:"Prism must support multiple backend storage engines (Postgres, Kafka, NATS, SQLite, Neptune) for different data abstractions (KeyValue, TimeSeries, Graph). Each backend has unique characteristics:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Postgres"}),": Relational, ACID transactions, SQL queries"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Kafka"}),": Append-only log, high throughput, event streaming"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"NATS"}),": Lightweight messaging, JetStream for persistence"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"SQLite"}),": Embedded, file-based, perfect for local testing"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Neptune"}),": Graph database, Gremlin/SPARQL queries"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"We need to:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Add new backends without changing application-facing APIs"}),"\n",(0,i.jsx)(n.li,{children:"Swap backends transparently (e.g., Postgres \u2192 Cassandra)"}),"\n",(0,i.jsx)(n.li,{children:"Reuse common functionality (connection pooling, retries, metrics)"}),"\n",(0,i.jsx)(n.li,{children:"Keep backend-specific code isolated"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,i.jsxs)(n.p,{children:["Implement a ",(0,i.jsx)(n.strong,{children:"trait-based plugin architecture"})," where each data abstraction defines a trait, and backends implement the trait."]}),"\n",(0,i.jsx)(n.h2,{id:"rationale",children:"Rationale"}),"\n",(0,i.jsx)(n.h3,{id:"architecture",children:"Architecture"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// Core abstraction trait\n#[async_trait]\npub trait KeyValueBackend: Send + Sync {\n    async fn put(&self, namespace: &str, id: &str, items: Vec<Item>) -> Result<()>;\n    async fn get(&self, namespace: &str, id: &str, keys: Vec<&[u8]>) -> Result<Vec<Item>>;\n    async fn delete(&self, namespace: &str, id: &str, keys: Vec<&[u8]>) -> Result<()>;\n    async fn scan(&self, namespace: &str, id: &str) -> Result<ScanIterator>;\n}\n\n// Postgres implementation\npub struct PostgresKeyValue {\n    pool: PgPool,\n}\n\n#[async_trait]\nimpl KeyValueBackend for PostgresKeyValue {\n    async fn put(&self, namespace: &str, id: &str, items: Vec<Item>) -> Result<()> {\n        // Postgres-specific implementation\n        let mut tx = self.pool.begin().await?;\n        for item in items {\n            sqlx::query("INSERT INTO kv (namespace, id, key, value) VALUES ($1, $2, $3, $4)")\n                .bind(namespace)\n                .bind(id)\n                .bind(&item.key)\n                .bind(&item.value)\n                .execute(&mut tx)\n                .await?;\n        }\n        tx.commit().await?;\n        Ok(())\n    }\n    // ... other methods\n}\n\n// Kafka implementation\npub struct KafkaKeyValue {\n    producer: FutureProducer,\n}\n\n#[async_trait]\nimpl KeyValueBackend for KafkaKeyValue {\n    async fn put(&self, namespace: &str, id: &str, items: Vec<Item>) -> Result<()> {\n        // Kafka-specific implementation\n        for item in items {\n            let record = FutureRecord::to(&format!("kv-{}", namespace))\n                .key(&format!("{}:{}", id, String::from_utf8_lossy(&item.key)))\n                .payload(&item.value);\n            self.producer.send(record, Duration::from_secs(5)).await?;\n        }\n        Ok(())\n    }\n    // ... other methods\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"backend-registry",children:"Backend Registry"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'pub struct BackendRegistry {\n    keyvalue_backends: HashMap<String, Arc<dyn KeyValueBackend>>,\n    timeseries_backends: HashMap<String, Arc<dyn TimeSeriesBackend>>,\n    graph_backends: HashMap<String, Arc<dyn GraphBackend>>,\n}\n\nimpl BackendRegistry {\n    pub fn new() -> Self {\n        let mut registry = Self::default();\n\n        // Register built-in backends\n        registry.register_keyvalue("postgres", Arc::new(PostgresKeyValue::new()));\n        registry.register_keyvalue("kafka", Arc::new(KafkaKeyValue::new()));\n        registry.register_keyvalue("sqlite", Arc::new(SqliteKeyValue::new()));\n\n        registry\n    }\n\n    pub fn get_keyvalue(&self, backend_name: &str) -> Option<&Arc<dyn KeyValueBackend>> {\n        self.keyvalue_backends.get(backend_name)\n    }\n\n    // Plugin registration (for third-party backends)\n    pub fn register_keyvalue(&mut self, name: impl Into<String>, backend: Arc<dyn KeyValueBackend>) {\n        self.keyvalue_backends.insert(name.into(), backend);\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"namespace-configuration",children:"Namespace Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# namespace-config.yaml\nnamespaces:\n  - name: user-profiles\n    abstraction: keyvalue\n    backend: postgres\n    config:\n      connection_string: postgres://localhost/prism\n      pool_size: 20\n\n  - name: user-events\n    abstraction: timeseries\n    backend: kafka\n    config:\n      brokers: localhost:9092\n      topic_prefix: events\n      partitions: 20\n"})}),"\n",(0,i.jsx)(n.h3,{id:"routing",children:"Routing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub struct Router {\n    registry: BackendRegistry,\n    namespace_configs: HashMap<String, NamespaceConfig>,\n}\n\nimpl Router {\n    pub async fn route_put(&self, namespace: &str, request: PutRequest) -> Result<PutResponse> {\n        let config = self.namespace_configs.get(namespace)\n            .ok_or_else(|| Error::NamespaceNotFound)?;\n\n        let backend = self.registry.get_keyvalue(&config.backend)\n            .ok_or_else(|| Error::BackendNotFound)?;\n\n        backend.put(namespace, &request.id, request.items).await?;\n        Ok(PutResponse { success: true })\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Hard-coded backends"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Pros: Simple, no abstraction overhead"}),"\n",(0,i.jsx)(n.li,{children:"Cons: Can't add backends without changing core code"}),"\n",(0,i.jsx)(n.li,{children:"Rejected: Not extensible"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Dynamic library plugins (",(0,i.jsx)(n.code,{children:".so"}),"/",(0,i.jsx)(n.code,{children:".dll"}),")"]})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Pros: True runtime plugins"}),"\n",(0,i.jsx)(n.li,{children:"Cons: ABI compatibility nightmares, unsafe, complex"}),"\n",(0,i.jsx)(n.li,{children:"Rejected: Over-engineered for our needs"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Separate microservices per backend"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Pros: Complete isolation"}),"\n",(0,i.jsx)(n.li,{children:"Cons: Network overhead, operational complexity"}),"\n",(0,i.jsx)(n.li,{children:"Rejected: Too much overhead for data path"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Enum dispatch"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Pros: Zero-cost abstraction"}),"\n",(0,i.jsx)(n.li,{children:"Cons: Still need to modify core code to add backends"}),"\n",(0,i.jsx)(n.li,{children:"Rejected: Not extensible enough"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,i.jsx)(n.h3,{id:"positive",children:"Positive"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pluggable"}),": Add new backends by implementing trait"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Swappable"}),": Change backend without changing client code"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Testable"}),": Mock backends for unit tests"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type-safe"}),": Compiler enforces contract"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance"}),": Trait objects have minimal overhead (~1 vtable indirection)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"negative",children:"Negative"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Trait object complexity"}),": Must use ",(0,i.jsx)(n.code,{children:"Arc<dyn Trait>"})," and ",(0,i.jsx)(n.code,{children:"async_trait"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Mitigation"}),": Well-documented patterns, helper macros"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Common denominator"}),": Traits must work for all backends","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Mitigation"}),": Backend-specific features exposed via extension traits"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"neutral",children:"Neutral"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Registration boilerplate"}),": Each backend needs registration code"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Configuration variety"}),": Each backend has different config needs"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,i.jsx)(n.h3,{id:"backend-interface-per-abstraction",children:"Backend Interface Per Abstraction"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"KeyValue"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"#[async_trait]\npub trait KeyValueBackend: Send + Sync {\n    async fn put(&self, namespace: &str, id: &str, items: Vec<Item>) -> Result<()>;\n    async fn get(&self, namespace: &str, id: &str, keys: Vec<&[u8]>) -> Result<Vec<Item>>;\n    async fn delete(&self, namespace: &str, id: &str, keys: Vec<&[u8]>) -> Result<()>;\n    async fn scan(&self, namespace: &str, id: &str, cursor: Option<Cursor>) -> Result<ScanResult>;\n    async fn compare_and_swap(&self, namespace: &str, id: &str, key: &[u8], old: Option<&[u8]>, new: &[u8]) -> Result<bool>;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"TimeSeries"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"#[async_trait]\npub trait TimeSeriesBackend: Send + Sync {\n    async fn append(&self, stream: &str, events: Vec<Event>) -> Result<()>;\n    async fn query(&self, stream: &str, range: TimeRange, filter: Filter) -> Result<EventStream>;\n    async fn tail(&self, stream: &str, from: Timestamp) -> Result<EventStream>;\n    async fn create_stream(&self, stream: &str, config: StreamConfig) -> Result<()>;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Graph"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"#[async_trait]\npub trait GraphBackend: Send + Sync {\n    async fn create_node(&self, node: Node) -> Result<()>;\n    async fn get_node(&self, id: &str) -> Result<Option<Node>>;\n    async fn create_edge(&self, edge: Edge) -> Result<()>;\n    async fn get_edges(&self, node_id: &str, direction: Direction, filters: EdgeFilters) -> Result<Vec<Edge>>;\n    async fn traverse(&self, start: &str, query: TraversalQuery) -> Result<TraversalResult>;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"backend-capabilities",children:"Backend Capabilities"}),"\n",(0,i.jsx)(n.p,{children:"Backends can declare capabilities:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub struct BackendCapabilities {\n    pub supports_transactions: bool,\n    pub supports_compare_and_swap: bool,\n    pub supports_range_scans: bool,\n    pub max_item_size: usize,\n    pub max_batch_size: usize,\n}\n\npub trait Backend {\n    fn capabilities(&self) -> BackendCapabilities;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"extension-traits-for-backend-specific-features",children:"Extension Traits for Backend-Specific Features"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// Postgres-specific features\n#[async_trait]\npub trait PostgresBackendExt {\n    async fn execute_sql(&self, query: &str) -> Result<QueryResult>;\n}\n\nimpl PostgresBackendExt for PostgresKeyValue {\n    async fn execute_sql(&self, query: &str) -> Result<QueryResult> {\n        // Direct SQL access for advanced use cases\n    }\n}\n\n// Usage\nif let Some(pg) = backend.downcast_ref::<PostgresKeyValue>() {\n    pg.execute_sql("SELECT * FROM kv WHERE ...").await?;\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"testing",children:"Testing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// Mock backend for unit tests\npub struct MockKeyValue {\n    data: Arc<Mutex<HashMap<(String, String, Vec<u8>), Vec<u8>>>>,\n}\n\n#[async_trait]\nimpl KeyValueBackend for MockKeyValue {\n    async fn put(&self, namespace: &str, id: &str, items: Vec<Item>) -> Result<()> {\n        let mut data = self.data.lock().unwrap();\n        for item in items {\n            data.insert((namespace.to_string(), id.to_string(), item.key.clone()), item.value);\n        }\n        Ok(())\n    }\n    // ... in-memory implementation\n}\n\n#[tokio::test]\nasync fn test_router() {\n    let mut registry = BackendRegistry::new();\n    registry.register_keyvalue("mock", Arc::new(MockKeyValue::new()));\n\n    // Test without real databases\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://docs.rs/async-trait/",children:"Rust Async Trait"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://doc.rust-lang.org/book/ch17-02-trait-objects.html",children:"Trait Objects in Rust"})}),"\n",(0,i.jsx)(n.li,{children:"ADR-001: Rust for the Proxy"}),"\n",(0,i.jsx)(n.li,{children:"ADR-003: Protobuf as Single Source of Truth"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"2025-10-05: Initial draft and acceptance"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>c});var t=s(6540);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);