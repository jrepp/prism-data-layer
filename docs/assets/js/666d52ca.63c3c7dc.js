"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[7124],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var a=t(96540);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}},66365:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"adr-036","title":"Local SQLite Storage for Namespace Configuration","description":"Context","source":"@site/../docs-cms/adr/adr-036-sqlite-config-storage.md","sourceDirName":".","slug":"/adr-036","permalink":"/prism-data-layer/adr/adr-036","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/adr-036-sqlite-config-storage.md","tags":[{"inline":true,"label":"configuration","permalink":"/prism-data-layer/adr/tags/configuration"},{"inline":true,"label":"deployment","permalink":"/prism-data-layer/adr/tags/deployment"},{"inline":true,"label":"reliability","permalink":"/prism-data-layer/adr/tags/reliability"},{"inline":true,"label":"operations","permalink":"/prism-data-layer/adr/tags/operations"}],"version":"current","frontMatter":{"date":"2025-10-08T00:00:00.000Z","deciders":"System","doc_uuid":"60fbdbbd-7374-4b88-abe0-815093ff15f8","id":"adr-036","project_id":"prism-data-layer","status":"Proposed","tags":["configuration","deployment","reliability","operations"],"title":"Local SQLite Storage for Namespace Configuration"},"sidebar":"adrSidebar","previous":{"title":"Database Connection Pooling vs Direct Connections \u2022 ADR-035","permalink":"/prism-data-layer/adr/adr-035"},"next":{"title":"Kubernetes Operator with Custom Resource Definitions \u2022 ADR-037","permalink":"/prism-data-layer/adr/adr-037"}}');var s=t(74848),i=t(28453);const r={date:new Date("2025-10-08T00:00:00.000Z"),deciders:"System",doc_uuid:"60fbdbbd-7374-4b88-abe0-815093ff15f8",id:"adr-036",project_id:"prism-data-layer",status:"Proposed",tags:["configuration","deployment","reliability","operations"],title:"Local SQLite Storage for Namespace Configuration"},o=void 0,c={},l=[{value:"Context",id:"context",level:2},{value:"Current State: File-Based Configuration",id:"current-state-file-based-configuration",level:3},{value:"Requirements",id:"requirements",level:3},{value:"Decision",id:"decision",level:2},{value:"Schema Design",id:"schema-design",level:3},{value:"File Location",id:"file-location",level:3}];function d(e){const n={code:"code",configstore:"configstore",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",self:"self",sqliteconnectionmanager:"sqliteconnectionmanager",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,s.jsx)(n.p,{children:"Prism proxy instances need to store and query namespace configurations:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Backend connection strings"}),"\n",(0,s.jsx)(n.li,{children:"Access pattern settings (consistency, cache TTL, rate limits)"}),"\n",(0,s.jsx)(n.li,{children:"Feature flags per namespace"}),"\n",(0,s.jsx)(n.li,{children:"Shadow traffic configuration"}),"\n",(0,s.jsx)(n.li,{children:"Operational metadata (created_at, updated_at, owner)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"current-state-file-based-configuration",children:"Current State: File-Based Configuration"}),"\n",(0,s.jsx)(n.p,{children:"Currently, configurations are loaded from YAML files:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"# config/namespaces.yaml\nnamespaces:\n  - name: user-profiles\n    backend: postgres\n    pattern: keyvalue\n    consistency: strong\n    connection_string: postgres://db:5432/profiles\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problems with file-based config"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No transactional updates"}),": Partial writes on crash leave inconsistent state"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No query capabilities"}),": Can't filter namespaces by backend, SLA, or tags"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Slow at scale"}),": Linear scan through 1000s of namespaces on startup"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No versioning"}),": Can't rollback bad config changes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Admin API complexity"}),": Must parse YAML, validate, rewrite entire file"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"requirements",children:"Requirements"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fast reads"}),": Lookup namespace config in <1ms"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Transactional writes"}),": Atomic updates prevent corruption"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Query support"}),": Filter by backend, tags, status, etc."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Version history"}),": Track config changes over time"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Embedded"}),": No external database dependency"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Durability"}),": Survive proxy restarts and crashes"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use SQLite as embedded configuration storage"})," for Prism proxy instances."]}),"\n",(0,s.jsx)(n.h3,{id:"schema-design",children:"Schema Design"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Namespace configuration (primary table)\nCREATE TABLE namespaces (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    name TEXT NOT NULL UNIQUE,\n    backend TEXT NOT NULL,  -- 'postgres', 'redis', etc.\n    pattern TEXT NOT NULL,  -- 'keyvalue', 'stream', etc.\n    status TEXT NOT NULL DEFAULT 'active',  -- 'active', 'disabled', 'migrating'\n\n    -- Backend configuration (JSON blob)\n    backend_config TEXT NOT NULL,\n\n    -- Access pattern settings\n    consistency TEXT NOT NULL DEFAULT 'eventual',\n    cache_ttl_seconds INTEGER,\n    rate_limit_rps INTEGER,\n\n    -- Operational metadata\n    created_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),\n    updated_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),\n    created_by TEXT,\n\n    -- Tags for filtering\n    tags TEXT,  -- JSON array: [\"production\", \"high-traffic\"]\n\n    CHECK(status IN ('active', 'disabled', 'migrating'))\n);\n\n-- Indexes for common queries\nCREATE INDEX idx_namespaces_backend ON namespaces(backend);\nCREATE INDEX idx_namespaces_status ON namespaces(status);\nCREATE INDEX idx_namespaces_pattern ON namespaces(pattern);\n\n-- Configuration change history\nCREATE TABLE namespace_history (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    namespace_id INTEGER NOT NULL,\n    operation TEXT NOT NULL,  -- 'create', 'update', 'delete'\n    changed_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),\n    changed_by TEXT,\n    old_config TEXT,  -- JSON snapshot before change\n    new_config TEXT,  -- JSON snapshot after change\n\n    FOREIGN KEY(namespace_id) REFERENCES namespaces(id)\n);\n\nCREATE INDEX idx_history_namespace ON namespace_history(namespace_id);\nCREATE INDEX idx_history_changed_at ON namespace_history(changed_at);\n\n-- Feature flags per namespace\nCREATE TABLE namespace_features (\n    namespace_id INTEGER NOT NULL,\n    feature_name TEXT NOT NULL,\n    enabled BOOLEAN NOT NULL DEFAULT 0,\n    updated_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),\n\n    PRIMARY KEY(namespace_id, feature_name),\n    FOREIGN KEY(namespace_id) REFERENCES namespaces(id) ON DELETE CASCADE\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"file-location",children:"File Location"}),"\n",(0,s.jsx)(n.p,{children:"/var/lib/prism/\n\u251c\u2500\u2500 config.db           # Primary SQLite database\n\u251c\u2500\u2500 config.db-wal       # Write-Ahead Log (SQLite WAL mode)\n\u2514\u2500\u2500 config.db-shm       # Shared memory file"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n### Admin API Integration\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"use rusqlite::{Connection, params};"}),"\n",(0,s.jsx)(n.p,{children:"pub struct ConfigStore {\nconn: Connection,\n}"}),"\n",(0,s.jsxs)(n.p,{children:["impl ConfigStore {\npub fn open(path: &Path) -> Result",(0,s.jsx)(n.self,{children:" {\nlet conn = Connection::open(path)?;"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'    // Enable WAL mode for better concurrency\n    conn.execute_batch("PRAGMA journal_mode=WAL;")?;\n    conn.execute_batch("PRAGMA synchronous=NORMAL;")?;\n\n    Ok(Self { conn })\n}\n\npub fn create_namespace(&self, ns: &Namespace) -> Result<i64> {\n    let tx = self.conn.transaction()?;\n\n    // Insert namespace\n    tx.execute(\n        "INSERT INTO namespaces (name, backend, pattern, backend_config, consistency, created_by)\n         VALUES (?1, ?2, ?3, ?4, ?5, ?6)",\n        params![ns.name, ns.backend, ns.pattern, ns.backend_config_json, ns.consistency, ns.created_by],\n    )?;\n\n    let namespace_id = tx.last_insert_rowid();\n\n    // Record in history\n    tx.execute(\n        "INSERT INTO namespace_history (namespace_id, operation, new_config, changed_by)\n         VALUES (?1, \'create\', ?2, ?3)",\n        params![namespace_id, ns.to_json(), ns.created_by],\n    )?;\n\n    tx.commit()?;\n\n    Ok(namespace_id)\n}\n\npub fn get_namespace(&self, name: &str) -> Result<Option<Namespace>> {\n    let mut stmt = self.conn.prepare(\n        "SELECT id, name, backend, pattern, backend_config, consistency, status, cache_ttl_seconds\n         FROM namespaces WHERE name = ?1 AND status = \'active\'"\n    )?;\n\n    let ns = stmt.query_row(params![name], |row| {\n        Ok(Namespace {\n            id: row.get(0)?,\n            name: row.get(1)?,\n            backend: row.get(2)?,\n            pattern: row.get(3)?,\n            backend_config_json: row.get(4)?,\n            consistency: row.get(5)?,\n            status: row.get(6)?,\n            cache_ttl_seconds: row.get(7)?,\n        })\n    }).optional()?;\n\n    Ok(ns)\n}\n\npub fn list_namespaces_by_backend(&self, backend: &str) -> Result<Vec<Namespace>> {\n    let mut stmt = self.conn.prepare(\n        "SELECT id, name, backend, pattern, backend_config, consistency\n         FROM namespaces WHERE backend = ?1 AND status = \'active\'\n         ORDER BY name"\n    )?;\n\n    let namespaces = stmt.query_map(params![backend], |row| {\n        Ok(Namespace {\n            id: row.get(0)?,\n            name: row.get(1)?,\n            backend: row.get(2)?,\n            pattern: row.get(3)?,\n            backend_config_json: row.get(4)?,\n            consistency: row.get(5)?,\n            ..Default::default()\n        })\n    })?.collect::<Result<Vec<_>, _>>()?;\n\n    Ok(namespaces)\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"}"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n## Rationale\n\n### Why SQLite?\n\n**Embedded**: No external database to deploy, manage, or monitor\n- Prism proxy is self-contained\n- Works in containers, bare metal, edge deployments\n- Zero operational overhead\n\n**Performance**:\n- Reads: &lt;0.1ms for indexed queries\n- Writes: &lt;1ms with WAL mode\n- Concurrent reads: unlimited (with WAL mode)\n- File size: ~10KB per namespace (1000 namespaces = 10MB)\n\n**Reliability**:\n- ACID transactions prevent corruption\n- WAL mode for crash recovery\n- Proven: used by browsers, mobile apps, billions of deployments\n\n**Queryability**:\n- SQL enables complex filters: `WHERE backend = 'redis' AND tags LIKE '%production%'`\n- Aggregations: `SELECT backend, COUNT(*) FROM namespaces GROUP BY backend`\n- Joins: correlate namespace configs with history\n\n**Versioning**:\n- `namespace_history` table tracks all changes\n- Rollback: restore from `old_config` snapshot\n- Audit: who changed what, when\n\n### Compared to Alternatives\n\n**vs File-based YAML**:\n- \u2705 Transactional updates (YAML = all-or-nothing file rewrite)\n- \u2705 Query support (YAML = linear scan)\n- \u2705 Version history (YAML = external version control needed)\n\n**vs etcd/Consul**:\n- \u2705 No external dependencies (etcd = separate cluster)\n- \u2705 No network hops (etcd = remote calls)\n- \u274c No distributed consensus (etcd = multi-node consistency)\n- **When to use etcd**: Multi-instance Prism clusters sharing config (see ADR-037)\n\n**vs PostgreSQL**:\n- \u2705 Embedded, no separate database (PostgreSQL = external service)\n- \u2705 Simpler operations (PostgreSQL = backups, replication, etc.)\n- \u274c Not distributed (PostgreSQL = HA, replication)\n- **When to use PostgreSQL**: Large-scale multi-region deployments\n\n## Alternatives Considered\n\n### 1. Continue with YAML Files\n\n- **Pros**: Simple, human-readable, easy to version control\n- **Cons**: No transactions, no queries, slow at scale, no history\n- **Rejected because**: Doesn't scale beyond 100s of namespaces\n\n### 2. etcd/Consul for Configuration\n\n- **Pros**: Distributed, HA, multi-instance sharing\n- **Cons**: External dependency, operational complexity, network latency\n- **Rejected because**: Overkill for single-instance Prism, adds deployment complexity\n- **Reconsidered for**: Multi-instance clusters (see ADR-037)\n\n### 3. PostgreSQL as Config Store\n\n- **Pros**: Full SQL, proven at scale, rich ecosystem\n- **Cons**: External dependency, separate HA/backup strategy, network latency\n- **Rejected because**: Defeats purpose of Prism being self-contained\n\n### 4. Protobuf Binary Files\n\n- **Pros**: Compact, type-safe, fast parsing\n- **Cons**: Not human-readable, no SQL queries, no transactions\n- **Rejected because**: Gives up queryability and atomicity\n\n## Consequences\n\n### Positive\n\n- **Fast lookups**: O(log n) index scans, &lt;1ms latency\n- **Atomic updates**: Transactions prevent config corruption\n- **Rich queries**: SQL enables filtering, aggregation, joins\n- **Audit trail**: History table tracks all changes\n- **Zero dependencies**: Embedded, no external services needed\n- **Small footprint**: ~10KB per namespace, 10MB for 1000 namespaces\n\n### Negative\n\n- **Single-instance only**: SQLite file not shareable across proxy instances\n- **Write concurrency**: Single writer (WAL mode helps, but still a bottleneck at high write rates)\n- **No replication**: Losing the file means losing config (backup strategy needed)\n- **File corruption risk**: Rare, but disk corruption can invalidate database\n\n### Neutral\n\n- **Backup strategy**: Must back up SQLite file (simple file copy during WAL checkpoint)\n- **Migration from YAML**: Need one-time migration script to import existing configs\n- **Multi-instance deployments**: Need different approach (etcd, or Kubernetes CRDs via ADR-037)\n\n## Implementation Notes\n\n### Initialization on Startup\n\n"})}),"\n",(0,s.jsxs)(n.p,{children:["pub async fn initialize_config_store() -> Result",(0,s.jsx)(n.configstore,{children:' {\nlet db_path = Path::new("/var/lib/prism/config.db");'})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'// Create parent directory\nstd::fs::create_dir_all(db_path.parent().unwrap())?;\n\nlet store = ConfigStore::open(db_path)?;\n\n// Run migrations\nstore.migrate()?;\n\n// Import from YAML if database is empty\nif store.count_namespaces()? == 0 {\n    store.import_from_yaml("config/namespaces.yaml").await?;\n}\n\nOk(store)\n'})}),"\n",(0,s.jsx)(n.p,{children:"}"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n### Backup Strategy\n\n"})}),"\n",(0,s.jsx)(n.h1,{id:"daily-backup-via-cron",children:"Daily backup via cron"}),"\n",(0,s.jsx)(n.p,{children:"#!/bin/bash"}),"\n",(0,s.jsx)(n.h1,{id:"etccrondailyprism-config-backup",children:"/etc/cron.daily/prism-config-backup"}),"\n",(0,s.jsx)(n.p,{children:"DB_PATH=/var/lib/prism/config.db\nBACKUP_DIR=/var/backups/prism"}),"\n",(0,s.jsx)(n.h1,{id:"wait-for-wal-checkpoint",children:"Wait for WAL checkpoint"}),"\n",(0,s.jsx)(n.p,{children:'sqlite3 $DB_PATH "PRAGMA wal_checkpoint(TRUNCATE);"'}),"\n",(0,s.jsx)(n.h1,{id:"copy-database-file",children:"Copy database file"}),"\n",(0,s.jsx)(n.p,{children:"cp $DB_PATH $BACKUP_DIR/config-$(date +%Y%m%d).db"}),"\n",(0,s.jsx)(n.h1,{id:"retain-last-30-days",children:"Retain last 30 days"}),"\n",(0,s.jsx)(n.p,{children:'find $BACKUP_DIR -name "config-*.db" -mtime +30 -delete'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n### Read-Heavy Optimization\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"// Use connection pool for concurrent reads\nuse r2d2_sqlite::SqliteConnectionManager;\nuse r2d2::Pool;"}),"\n",(0,s.jsxs)(n.p,{children:["pub struct ConfigStore {\npool: Pool",(0,s.jsx)(n.sqliteconnectionmanager,{children:",\n}"})]}),"\n",(0,s.jsxs)(n.p,{children:["impl ConfigStore {\npub fn open(path: &Path) -> Result",(0,s.jsx)(n.self,{children:' {\nlet manager = SqliteConnectionManager::file(path)\n.with_init(|conn| {\nconn.execute_batch("PRAGMA journal_mode=WAL;")?;\nconn.execute_batch("PRAGMA query_only=ON;")?;  // Read-only for pooled connections\nOk(())\n});'})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"    let pool = Pool::builder()\n        .max_size(10)  // 10 concurrent read connections\n        .build(manager)?;\n\n    Ok(Self { pool })\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"}"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"\n### Multi-Instance Deployment (Future)\n\nFor multi-instance Prism deployments (ADR-034 sharding, ADR-037 Kubernetes):\n\n**Option 1**: Each instance has own SQLite, sync via Kubernetes ConfigMaps\n**Option 2**: Use etcd for distributed config, fall back to SQLite cache\n**Option 3**: Kubernetes CRDs as source of truth, SQLite as local cache\n\nSee ADR-037 for full multi-instance strategy.\n\n## References\n\n- [SQLite in Production](https://www.sqlite.org/whentouse.html)\n- [SQLite WAL Mode](https://www.sqlite.org/wal.html)\n- [rusqlite Documentation](https://docs.rs/rusqlite/)\n- ADR-037: Kubernetes Operator (multi-instance config sync)\n- ADR-033: Capability API (reads from config store)\n\n## Revision History\n\n- 2025-10-08: Initial draft proposing SQLite for local config storage\n\n"})})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);