"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[3189],{28453:(e,r,n)=>{n.d(r,{R:()=>o,x:()=>a});var t=n(96540);const s={},i=t.createContext(s);function o(e){const r=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(i.Provider,{value:r},e.children)}},41673:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"adr-018","title":"Rust Error Handling Strategy","description":"Context","source":"@site/../docs-cms/adr/adr-018-rust-error-handling-strategy.md","sourceDirName":".","slug":"/adr-018","permalink":"/prism-data-layer/adr/adr-018","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/adr-018-rust-error-handling-strategy.md","tags":[{"inline":true,"label":"rust","permalink":"/prism-data-layer/adr/tags/rust"},{"inline":true,"label":"error-handling","permalink":"/prism-data-layer/adr/tags/error-handling"},{"inline":true,"label":"reliability","permalink":"/prism-data-layer/adr/tags/reliability"},{"inline":true,"label":"observability","permalink":"/prism-data-layer/adr/tags/observability"}],"version":"current","frontMatter":{"date":"2025-10-07T00:00:00.000Z","deciders":"Core Team","doc_uuid":"29154172-3d41-4c9e-aef8-11a5dc56f602","id":"adr-018","project_id":"prism-data-layer","status":"Accepted","tags":["rust","error-handling","reliability","observability"],"title":"Rust Error Handling Strategy"},"sidebar":"adrSidebar","previous":{"title":"Go Structured Logging with slog \u2022 ADR-017","permalink":"/prism-data-layer/adr/adr-017"},"next":{"title":"Rust Async Concurrency Patterns \u2022 ADR-019","permalink":"/prism-data-layer/adr/adr-019"}}');var s=n(74848),i=n(28453);const o={date:new Date("2025-10-07T00:00:00.000Z"),deciders:"Core Team",doc_uuid:"29154172-3d41-4c9e-aef8-11a5dc56f602",id:"adr-018",project_id:"prism-data-layer",status:"Accepted",tags:["rust","error-handling","reliability","observability"],title:"Rust Error Handling Strategy"},a=void 0,l={},d=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Why thiserror + anyhow",id:"why-thiserror--anyhow",level:3},{value:"Error Conversion Pattern",id:"error-conversion-pattern",level:3},{value:"Alternatives Considered",id:"alternatives-considered",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Implementation Notes",id:"implementation-notes",level:2},{value:"Module Structure",id:"module-structure",level:3}];function c(e){const r={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",proxyerror:"proxyerror",putrequest:"putrequest",putresponse:"putresponse",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.h2,{id:"context",children:"Context"}),"\n",(0,s.jsx)(r.p,{children:"Rust proxy implementation requires consistent error handling that:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Preserves error context through call chains"}),"\n",(0,s.jsx)(r.li,{children:"Enables debugging without verbose logging"}),"\n",(0,s.jsx)(r.li,{children:"Leverages Rust's type system for compile-time safety"}),"\n",(0,s.jsx)(r.li,{children:"Integrates with async/await"}),"\n",(0,s.jsx)(r.li,{children:"Provides structured error information for observability"}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"decision",children:"Decision"}),"\n",(0,s.jsxs)(r.p,{children:["Adopt modern Rust error handling with ",(0,s.jsx)(r.code,{children:"thiserror"})," and ",(0,s.jsx)(r.code,{children:"anyhow"}),":"]}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsxs)(r.strong,{children:["Use ",(0,s.jsx)(r.code,{children:"thiserror"})," for library code"]})," (typed errors with context)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsxs)(r.strong,{children:["Use ",(0,s.jsx)(r.code,{children:"anyhow"})," for application code"]})," (error propagation with context)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsxs)(r.strong,{children:["Implement ",(0,s.jsx)(r.code,{children:"From"})," traits"]})," for error conversion"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsxs)(r.strong,{children:["Use ",(0,s.jsx)(r.code,{children:"?"})," operator"]})," for error propagation"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsxs)(r.strong,{children:["Add context with ",(0,s.jsx)(r.code,{children:".context()"})]})," at each layer"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Define domain-specific error types"})," per module"]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"rationale",children:"Rationale"}),"\n",(0,s.jsx)(r.h3,{id:"why-thiserror--anyhow",children:"Why thiserror + anyhow"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"thiserror"})," for library/domain errors:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum BackendError {\n    #[error("backend unavailable: {0}")]\n    Unavailable(String),\n\n    #[error("namespace not found: {namespace}")]\n    NamespaceNotFound { namespace: String },\n\n    #[error("invalid configuration: {0}")]\n    InvalidConfig(String),\n\n    #[error("database error: {0}")]\n    Database(#[from] sqlx::Error),\n}\n'})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"anyhow"})," for application/handler errors:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use anyhow::{Context, Result};\n\nasync fn handle_put_request(req: PutRequest) -> Result<PutResponse> {\n    let backend = get_backend(&req.namespace)\n        .await\n        .context(format!("failed to get backend for namespace: {}", req.namespace))?;\n\n    backend\n        .put(req.items)\n        .await\n        .context("failed to put items")?;\n\n    Ok(PutResponse { success: true })\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Benefits:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Compile-time error type checking (thiserror)"}),"\n",(0,s.jsx)(r.li,{children:"Ergonomic error propagation (anyhow)"}),"\n",(0,s.jsx)(r.li,{children:"Rich error context without manual wrapping"}),"\n",(0,s.jsx)(r.li,{children:"Stack traces in debug builds"}),"\n",(0,s.jsx)(r.li,{children:"Structured error information"}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"error-conversion-pattern",children:"Error Conversion Pattern"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'// Domain error type\n#[derive(Error, Debug)]\npub enum KeyValueError {\n    #[error("item not found: {key}")]\n    NotFound { key: String },\n\n    #[error("backend error: {0}")]\n    Backend(#[from] BackendError),\n}\n\n// Automatic conversion via From trait\nimpl From<sqlx::Error> for KeyValueError {\n    fn from(e: sqlx::Error) -> Self {\n        Self::Backend(BackendError::Database(e))\n    }\n}\n\n// Usage\nasync fn get_item(key: &str) -> Result<Item, KeyValueError> {\n    let row = sqlx::query_as("SELECT * FROM items WHERE key = ?")\n        .bind(key)\n        .fetch_one(&pool)\n        .await?;  // Automatic conversion via From\n\n    Ok(row)\n}\n'})}),"\n",(0,s.jsx)(r.h3,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Manual error wrapping"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Pros: No dependencies"}),"\n",(0,s.jsx)(r.li,{children:"Cons: Verbose, error-prone, no stack traces"}),"\n",(0,s.jsx)(r.li,{children:"Rejected: Too much boilerplate"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:(0,s.jsxs)(r.strong,{children:[(0,s.jsx)(r.code,{children:"eyre"})," instead of ",(0,s.jsx)(r.code,{children:"anyhow"})]})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Pros: Customizable reports, similar API"}),"\n",(0,s.jsx)(r.li,{children:"Cons: Smaller ecosystem, less battle-tested"}),"\n",(0,s.jsx)(r.li,{children:"Rejected: anyhow more widely adopted"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:(0,s.jsxs)(r.strong,{children:[(0,s.jsx)(r.code,{children:"snafu"})," instead of ",(0,s.jsx)(r.code,{children:"thiserror"})]})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Pros: Context selectors, different API"}),"\n",(0,s.jsx)(r.li,{children:"Cons: More complex, steeper learning curve"}),"\n",(0,s.jsx)(r.li,{children:"Rejected: thiserror simpler and more idiomatic"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"consequences",children:"Consequences"}),"\n",(0,s.jsx)(r.h3,{id:"positive",children:"Positive"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Type-safe error handling with thiserror"}),"\n",(0,s.jsxs)(r.li,{children:["Ergonomic error propagation with ",(0,s.jsx)(r.code,{children:"?"})," operator"]}),"\n",(0,s.jsx)(r.li,{children:"Rich error context for debugging"}),"\n",(0,s.jsx)(r.li,{children:"Stack traces in development"}),"\n",(0,s.jsx)(r.li,{children:"Structured errors for observability"}),"\n",(0,s.jsx)(r.li,{children:"Compile-time guarantees"}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"negative",children:"Negative"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Two dependencies (but they work together seamlessly)"}),"\n",(0,s.jsx)(r.li,{children:"Must decide when to use thiserror vs anyhow"}),"\n",(0,s.jsx)(r.li,{children:"Error types require upfront design"}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"neutral",children:"Neutral"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Error handling is explicit (Rust's philosophy)"}),"\n",(0,s.jsx)(r.li,{children:"Need to define error types per module"}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,s.jsx)(r.h3,{id:"module-structure",children:"Module Structure"}),"\n",(0,s.jsx)(r.p,{children:"proxy/src/\n\u251c\u2500\u2500 error.rs          # Top-level error types\n\u251c\u2500\u2500 backend/\n\u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u2514\u2500\u2500 error.rs      # Backend-specific errors\n\u251c\u2500\u2500 keyvalue/\n\u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u2514\u2500\u2500 error.rs      # KeyValue-specific errors\n\u2514\u2500\u2500 main.rs"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-text",children:"\n### Top-Level Error Types\n\n"})}),"\n",(0,s.jsx)(r.p,{children:"// proxy/src/error.rs\nuse thiserror::Error;"}),"\n",(0,s.jsx)(r.p,{children:'#[derive(Error, Debug)]\npub enum ProxyError {\n#[error("configuration error: {0}")]\nConfig(String),'}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:'#[error("backend error: {0}")]\nBackend(#[from] crate::backend::BackendError),\n\n#[error("keyvalue error: {0}")]\nKeyValue(#[from] crate::keyvalue::KeyValueError),\n\n#[error("gRPC error: {0}")]\nGrpc(#[from] tonic::Status),\n'})}),"\n",(0,s.jsx)(r.p,{children:"}"}),"\n",(0,s.jsxs)(r.p,{children:["// Convert to gRPC Status for responses\nimpl From",(0,s.jsx)(r.proxyerror,{children:" for tonic::Status {\nfn from(e: ProxyError) -> Self {\nmatch e {\nProxyError::Backend(BackendError::NamespaceNotFound { .. }) =>\ntonic::Status::not_found(e.to_string()),\nProxyError::Config(_) =>\ntonic::Status::invalid_argument(e.to_string()),\n_ =>\ntonic::Status::internal(e.to_string()),\n}\n}\n}"})]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-text",children:"\n### Handler Pattern\n\n"})}),"\n",(0,s.jsx)(r.p,{children:"use anyhow::{Context, Result};\nuse tonic::{Request, Response, Status};"}),"\n",(0,s.jsxs)(r.p,{children:["#[tonic::async_trait]\nimpl KeyValueService for KeyValueHandler {\nasync fn put(\n&self,\nrequest: Request",(0,s.jsxs)(r.putrequest,{children:[",\n) -> Result<Response",(0,s.jsx)(r.putresponse,{children:", Status> {\nlet req = request.into_inner();"})]})]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:'    // Use anyhow::Result internally\n    let result: Result<PutResponse> = async {\n        let backend = self\n            .get_backend(&req.namespace)\n            .await\n            .context(format!("namespace: {}", req.namespace))?;\n\n        backend\n            .put(&req.id, req.items)\n            .await\n            .context("backend put operation")?;\n\n        Ok(PutResponse { success: true })\n    }\n    .await;\n\n    // Convert to gRPC Status\n    match result {\n        Ok(resp) => Ok(Response::new(resp)),\n        Err(e) => {\n            tracing::error!("put request failed: {:?}", e);\n            Err(Status::internal(e.to_string()))\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:"}"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-text",children:"\n### Backend Error Definition\n\n"})}),"\n",(0,s.jsx)(r.p,{children:"// proxy/src/backend/error.rs\nuse thiserror::Error;"}),"\n",(0,s.jsx)(r.p,{children:'#[derive(Error, Debug)]\npub enum BackendError {\n#[error("connection failed: {endpoint}")]\nConnectionFailed { endpoint: String },'}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:'#[error("timeout after {timeout_ms}ms")]\nTimeout { timeout_ms: u64 },\n\n#[error("namespace not found: {namespace}")]\nNamespaceNotFound { namespace: String },\n\n#[error("sqlx error: {0}")]\nSqlx(#[from] sqlx::Error),\n\n#[error("io error: {0}")]\nIo(#[from] std::io::Error),\n'})}),"\n",(0,s.jsx)(r.p,{children:"}"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-text",children:"\n### Testing Error Conditions\n\n"})}),"\n",(0,s.jsx)(r.p,{children:"#[cfg(test)]\nmod tests {\nuse super::*;"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:'#[tokio::test]\nasync fn test_get_nonexistent_namespace() {\n    let handler = KeyValueHandler::new();\n    let req = Request::new(GetRequest {\n        namespace: "nonexistent".to_string(),\n        id: "123".to_string(),\n        predicate: None,\n    });\n\n    let result = handler.get(req).await;\n    assert!(result.is_err());\n    assert_eq!(result.unwrap_err().code(), tonic::Code::NotFound);\n}\n\n#[tokio::test]\nasync fn test_backend_error_conversion() {\n    let backend_err = BackendError::NamespaceNotFound {\n        namespace: "test".to_string(),\n    };\n    let proxy_err: ProxyError = backend_err.into();\n    let status: tonic::Status = proxy_err.into();\n\n    assert_eq!(status.code(), tonic::Code::NotFound);\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:"}"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-text",children:"\n### Error Logging\n\nIntegrate with structured logging:\n\n"})}),"\n",(0,s.jsx)(r.p,{children:"use tracing::error;"}),"\n",(0,s.jsx)(r.p,{children:'match do_operation().await {\nOk(result) => result,\nErr(e) => {\nerror!(\nerror = %e,\nerror_debug = ?e,  // Full debug representation\nnamespace = %namespace,\n"operation failed"\n);\nreturn Err(e);\n}\n}'}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-text",children:"\n## References\n\n- [thiserror documentation](https://docs.rs/thiserror)\n- [anyhow documentation](https://docs.rs/anyhow)\n- [Rust Error Handling](https://doc.rust-lang.org/book/ch09-00-error-handling.html)\n- ADR-001: Rust for the Proxy\n- ADR-013: Go Error Handling Strategy (parallel Go patterns)\n\n## Revision History\n\n- 2025-10-07: Initial draft and acceptance\n\n"})})]})}function u(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);