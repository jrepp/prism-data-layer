"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[14565],{9470:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>c,default:()=>m,frontMatter:()=>t,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"adr-053","title":"ADR-053: Claim Check TTL and Garbage Collection","description":"Status","source":"@site/../docs-cms/adr/adr-053-claim-check-ttl-garbage-collection.md","sourceDirName":".","slug":"/adr-053","permalink":"/prism-data-layer/adr/adr-053","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/adr-053-claim-check-ttl-garbage-collection.md","tags":[{"inline":true,"label":"claim-check","permalink":"/prism-data-layer/adr/tags/claim-check"},{"inline":true,"label":"ttl","permalink":"/prism-data-layer/adr/tags/ttl"},{"inline":true,"label":"lifecycle","permalink":"/prism-data-layer/adr/tags/lifecycle"},{"inline":true,"label":"garbage-collection","permalink":"/prism-data-layer/adr/tags/garbage-collection"},{"inline":true,"label":"operations","permalink":"/prism-data-layer/adr/tags/operations"},{"inline":true,"label":"cost","permalink":"/prism-data-layer/adr/tags/cost"},{"inline":true,"label":"s3","permalink":"/prism-data-layer/adr/tags/s-3"},{"inline":true,"label":"minio","permalink":"/prism-data-layer/adr/tags/minio"}],"version":"current","frontMatter":{"title":"ADR-053: Claim Check TTL and Garbage Collection","status":"Proposed","date":"2025-10-14T00:00:00.000Z","deciders":"Core Team","tags":["claim-check","ttl","lifecycle","garbage-collection","operations","cost","s3","minio"],"id":"adr-053","project_id":"prism-data-layer","doc_uuid":"492c4b32-6f67-4676-aa6f-21a8a9aac13c"},"sidebar":"adrSidebar","previous":{"title":"Object Store Interface Design \u2022 ADR-052","permalink":"/prism-data-layer/adr/adr-052"}}');var l=i(74848),a=i(28453);const t={title:"ADR-053: Claim Check TTL and Garbage Collection",status:"Proposed",date:new Date("2025-10-14T00:00:00.000Z"),deciders:"Core Team",tags:["claim-check","ttl","lifecycle","garbage-collection","operations","cost","s3","minio"],id:"adr-053",project_id:"prism-data-layer",doc_uuid:"492c4b32-6f67-4676-aa6f-21a8a9aac13c"},c="ADR-053: Claim Check TTL and Garbage Collection",s={},o=[{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Problem Statement",id:"problem-statement",level:3},{value:"Requirements",id:"requirements",level:3},{value:"Decision",id:"decision",level:2},{value:"Strategy Overview",id:"strategy-overview",level:3},{value:"Configuration Model",id:"configuration-model",level:3},{value:"Implementation",id:"implementation",level:3},{value:"1. Producer: Set Bucket Lifecycle at Startup",id:"1-producer-set-bucket-lifecycle-at-startup",level:4},{value:"2. Producer: Upload Claim with Metadata",id:"2-producer-upload-claim-with-metadata",level:4},{value:"3. Consumer: Retrieve and Conditionally Delete",id:"3-consumer-retrieve-and-conditionally-delete",level:4},{value:"4. Proxy Validation: TTL Compatibility Check",id:"4-proxy-validation-ttl-compatibility-check",level:4},{value:"TTL Configuration Examples",id:"ttl-configuration-examples",level:3},{value:"Example 1: Aggressive Cleanup (Minimize Storage Cost)",id:"example-1-aggressive-cleanup-minimize-storage-cost",level:4},{value:"Example 2: Conservative (Handle Slow Consumers)",id:"example-2-conservative-handle-slow-consumers",level:4},{value:"Example 3: Redelivery Protection (Handle Message Broker Retries)",id:"example-3-redelivery-protection-handle-message-broker-retries",level:4},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Lifecycle Policy Details",id:"lifecycle-policy-details",level:2},{value:"S3/MinIO Lifecycle Behavior",id:"s3minio-lifecycle-behavior",level:3},{value:"Workaround for Fine-Grained TTL",id:"workaround-for-fine-grained-ttl",level:3},{value:"Monitoring and Alerting",id:"monitoring-and-alerting",level:2},{value:"Metrics to Track",id:"metrics-to-track",level:3},{value:"Alerts",id:"alerts",level:3},{value:"Dashboard Panels",id:"dashboard-panels",level:3},{value:"Testing Strategy",id:"testing-strategy",level:2},{value:"Unit Tests (Time Simulation)",id:"unit-tests-time-simulation",level:3},{value:"Integration Tests (MinIO Lifecycle)",id:"integration-tests-minio-lifecycle",level:3},{value:"Alternatives Considered",id:"alternatives-considered",level:2},{value:"1. No Automatic Cleanup",id:"1-no-automatic-cleanup",level:3},{value:"2. Separate Cleanup Service",id:"2-separate-cleanup-service",level:3},{value:"3. Database-Tracked TTL",id:"3-database-tracked-ttl",level:3},{value:"4. Always Delete Immediately",id:"4-always-delete-immediately",level:3},{value:"5. Never Delete Explicitly",id:"5-never-delete-explicitly",level:3},{value:"Open Questions",id:"open-questions",level:2},{value:"References",id:"references",level:2},{value:"Related Documents",id:"related-documents",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"adr-053-claim-check-ttl-and-garbage-collection",children:"ADR-053: Claim Check TTL and Garbage Collection"})}),"\n",(0,l.jsx)(n.h2,{id:"status",children:"Status"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Proposed"})," - Pending review"]}),"\n",(0,l.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,l.jsx)(n.p,{children:"The claim check pattern (RFC-033) stores large payloads in object storage. Without proper cleanup, storage costs grow unboundedly as claims accumulate. We need a strategy for:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Automatic Expiration"}),": Remove claims after consumer retrieval"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Orphan Cleanup"}),": Delete claims from failed/crashed consumers"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Cost Control"}),": Prevent storage bloat from forgotten claims"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Audit Trail"}),": Track claim lifecycle for debugging"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Configurable TTL"}),": Different namespaces have different retention needs"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Scenario 1: Happy Path"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-text",children:"Producer \u2192 Upload claim \u2192 Consumer retrieves \u2192 Claim should be deleted\n          (claim valid)                       (immediate cleanup)\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Scenario 2: Consumer Crash"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-text",children:"Producer \u2192 Upload claim \u2192 Consumer crashes \u2192 Claim orphaned\n          (claim valid)   (never retrieved)  (needs TTL cleanup)\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Scenario 3: Slow Consumer"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-text",children:"Producer \u2192 Upload claim \u2192 Long processing \u2192 Consumer retrieves \u2192 Claim deleted\n          (claim valid)   (still valid)                         (delayed cleanup)\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Scenario 4: Replay/Redelivery"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-text",children:"Producer \u2192 Upload claim \u2192 Consumer retrieves \u2192 Message redelivered \u2192 Claim missing\n          (claim valid)   (claim deleted)                            (ERROR!)\n"})}),"\n",(0,l.jsx)(n.h3,{id:"requirements",children:"Requirements"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"No Orphans"}),": All claims must eventually expire"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Safe TTL"}),": TTL must account for max consumer processing time"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Immediate Cleanup Option"}),": Delete claim after successful retrieval"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Idempotent Retrieval"}),": Multiple retrievals should work (for redelivery scenarios)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Cost Effective"}),": Minimize storage costs without breaking functionality"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Use a two-phase TTL strategy: short consumer-driven cleanup + long safety net."})}),"\n",(0,l.jsx)(n.h3,{id:"strategy-overview",children:"Strategy Overview"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-text",children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Claim Lifecycle                                             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                              \u2502\n\u2502  Producer Upload                                             \u2502\n\u2502  \u251c\u2500 Set bucket lifecycle policy (safety net: 24h)          \u2502\n\u2502  \u2514\u2500 Store claim reference in message                        \u2502\n\u2502                                                              \u2502\n\u2502  Consumer Retrieval                                          \u2502\n\u2502  \u251c\u2500 Download claim payload                                  \u2502\n\u2502  \u251c\u2500 Verify checksum                                         \u2502\n\u2502  \u251c\u2500 Process message                                         \u2502\n\u2502  \u2514\u2500 [Optional] Delete claim immediately                     \u2502\n\u2502                                                              \u2502\n\u2502  Background Cleanup (if not deleted by consumer)            \u2502\n\u2502  \u2514\u2500 Bucket lifecycle policy expires claim after 24h        \u2502\n\u2502                                                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,l.jsx)(n.h3,{id:"configuration-model",children:"Configuration Model"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-yaml",children:"# Namespace-level claim check configuration\nnamespace: video-processing\n\nclaim_check:\n  enabled: true\n  threshold: 1048576  # 1MB\n\n  # TTL Strategy\n  ttl:\n    # Safety net: hard expiration via bucket lifecycle\n    max_age: 86400  # 24 hours\n\n    # Consumer behavior: delete after successful retrieval\n    delete_after_read: true  # Default: true\n\n    # Redelivery protection: keep claim briefly after first read\n    retention_after_read: 300  # 5 minutes (for message redelivery)\n\n    # Grace period before lifecycle policy kicks in\n    # Allows for slow consumers, retries, debugging\n    grace_period: 3600  # 1 hour minimum before eligible for cleanup\n"})}),"\n",(0,l.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,l.jsx)(n.h4,{id:"1-producer-set-bucket-lifecycle-at-startup",children:"1. Producer: Set Bucket Lifecycle at Startup"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-go",children:'func (p *Producer) Start(ctx context.Context) error {\n    // ... existing startup logic\n\n    if p.claimCheck != nil {\n        // Ensure bucket exists with lifecycle policy\n        if err := p.ensureBucketLifecycle(ctx); err != nil {\n            return fmt.Errorf("failed to configure claim check bucket: %w", err)\n        }\n    }\n\n    return nil\n}\n\nfunc (p *Producer) ensureBucketLifecycle(ctx context.Context) error {\n    bucket := p.claimCheck.Bucket\n\n    // Create bucket if needed\n    if err := p.objectStore.CreateBucket(ctx, bucket); err != nil {\n        return err\n    }\n\n    // Set lifecycle policy (idempotent)\n    policy := &LifecyclePolicy{\n        Rules: []LifecycleRule{\n            {\n                ID:     "expire-claims",\n                Status: "Enabled",\n                Filter: &LifecycleFilter{\n                    Prefix: p.namespace + "/", // Only claims from this namespace\n                },\n                Expiration: &LifecycleExpiration{\n                    Days: p.claimCheck.TTL.MaxAge / 86400, // Convert seconds to days\n                },\n            },\n        },\n    }\n\n    return p.objectStore.SetBucketLifecycle(ctx, bucket, policy)\n}\n'})}),"\n",(0,l.jsx)(n.h4,{id:"2-producer-upload-claim-with-metadata",children:"2. Producer: Upload Claim with Metadata"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-go",children:'func (p *Producer) uploadClaim(ctx context.Context, payload []byte) (*ClaimCheckMessage, error) {\n    claimID := generateClaimID()\n    objectKey := fmt.Sprintf("%s/%s/%s", p.namespace, topic, claimID)\n\n    // Compress if configured\n    data := payload\n    if p.claimCheck.Compression != "none" {\n        data = compress(payload, p.claimCheck.Compression)\n    }\n\n    // Upload with metadata\n    metadata := map[string]string{\n        "prism-namespace":     p.namespace,\n        "prism-created-at":    time.Now().Format(time.RFC3339),\n        "prism-original-size": strconv.FormatInt(int64(len(payload)), 10),\n        "prism-compression":   p.claimCheck.Compression,\n        "prism-checksum":      hex.EncodeToString(sha256.Sum256(payload)),\n    }\n\n    if err := p.objectStore.PutWithMetadata(ctx, p.claimCheck.Bucket, objectKey, data, metadata); err != nil {\n        return nil, fmt.Errorf("claim upload failed: %w", err)\n    }\n\n    return &ClaimCheckMessage{\n        ClaimID:      claimID,\n        Bucket:       p.claimCheck.Bucket,\n        ObjectKey:    objectKey,\n        OriginalSize: int64(len(payload)),\n        Compression:  p.claimCheck.Compression,\n        Checksum:     sha256.Sum256(payload),\n        CreatedAt:    time.Now().Unix(),\n        ExpiresAt:    time.Now().Add(time.Duration(p.claimCheck.TTL.MaxAge) * time.Second).Unix(),\n    }, nil\n}\n'})}),"\n",(0,l.jsx)(n.h4,{id:"3-consumer-retrieve-and-conditionally-delete",children:"3. Consumer: Retrieve and Conditionally Delete"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-go",children:'func (c *Consumer) retrieveClaim(ctx context.Context, claim *ClaimCheckMessage) ([]byte, error) {\n    // Check if claim has expired\n    if time.Now().Unix() > claim.ExpiresAt {\n        return nil, fmt.Errorf("claim expired: %s", claim.ClaimID)\n    }\n\n    // Download claim\n    data, err := c.objectStore.Get(ctx, claim.Bucket, claim.ObjectKey)\n    if err != nil {\n        if errors.Is(err, ErrObjectNotFound) {\n            return nil, fmt.Errorf("claim not found (may have expired): %s", claim.ClaimID)\n        }\n        return nil, fmt.Errorf("claim retrieval failed: %w", err)\n    }\n\n    // Verify checksum\n    actualChecksum := sha256.Sum256(data)\n    if !bytes.Equal(actualChecksum[:], claim.Checksum[:]) {\n        return nil, fmt.Errorf("claim checksum mismatch: %s", claim.ClaimID)\n    }\n\n    // Decompress if needed\n    if claim.Compression != "none" {\n        data, err = decompress(data, claim.Compression)\n        if err != nil {\n            return nil, fmt.Errorf("claim decompression failed: %w", err)\n        }\n    }\n\n    // Delete claim based on configuration\n    if c.claimCheck.TTL.DeleteAfterRead {\n        // Option 1: Immediate deletion (default)\n        go c.deleteClaim(context.Background(), claim)\n\n    } else if c.claimCheck.TTL.RetentionAfterRead > 0 {\n        // Option 2: Delayed deletion (for redelivery protection)\n        go c.scheduleClaimDeletion(context.Background(), claim,\n            time.Duration(c.claimCheck.TTL.RetentionAfterRead)*time.Second)\n    }\n\n    // Otherwise: Let bucket lifecycle policy handle cleanup\n\n    return data, nil\n}\n\nfunc (c *Consumer) deleteClaim(ctx context.Context, claim *ClaimCheckMessage) {\n    if err := c.objectStore.Delete(ctx, claim.Bucket, claim.ObjectKey); err != nil {\n        // Log but don\'t fail - lifecycle policy will clean up eventually\n        slog.Warn("failed to delete claim after read",\n            "claim_id", claim.ClaimID,\n            "error", err)\n\n        // Emit metric for monitoring\n        c.metrics.ClaimDeleteFailures.Inc()\n    } else {\n        slog.Debug("claim deleted after retrieval", "claim_id", claim.ClaimID)\n        c.metrics.ClaimsDeleted.Inc()\n    }\n}\n\nfunc (c *Consumer) scheduleClaimDeletion(ctx context.Context, claim *ClaimCheckMessage, delay time.Duration) {\n    time.Sleep(delay)\n    c.deleteClaim(ctx, claim)\n}\n'})}),"\n",(0,l.jsx)(n.h4,{id:"4-proxy-validation-ttl-compatibility-check",children:"4. Proxy Validation: TTL Compatibility Check"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-go",children:'func (p *Proxy) validateClaimCheckTTL(producerTTL, consumerTTL ClaimCheckTTL) error {\n    // Both must use same max age\n    if producerTTL.MaxAge != consumerTTL.MaxAge {\n        return fmt.Errorf("producer/consumer max_age mismatch: %d != %d",\n            producerTTL.MaxAge, consumerTTL.MaxAge)\n    }\n\n    // If consumer keeps claims after read, ensure TTL is longer than retention\n    if consumerTTL.RetentionAfterRead > 0 {\n        if consumerTTL.RetentionAfterRead > producerTTL.MaxAge {\n            return fmt.Errorf("retention_after_read (%d) exceeds max_age (%d)",\n                consumerTTL.RetentionAfterRead, producerTTL.MaxAge)\n        }\n    }\n\n    // Warn if delete_after_read differs (not fatal, but inconsistent)\n    if producerTTL.DeleteAfterRead != consumerTTL.DeleteAfterRead {\n        slog.Warn("producer/consumer delete_after_read mismatch",\n            "producer", producerTTL.DeleteAfterRead,\n            "consumer", consumerTTL.DeleteAfterRead)\n    }\n\n    return nil\n}\n'})}),"\n",(0,l.jsx)(n.h3,{id:"ttl-configuration-examples",children:"TTL Configuration Examples"}),"\n",(0,l.jsx)(n.h4,{id:"example-1-aggressive-cleanup-minimize-storage-cost",children:"Example 1: Aggressive Cleanup (Minimize Storage Cost)"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-yaml",children:"claim_check:\n  ttl:\n    max_age: 3600            # 1 hour safety net\n    delete_after_read: true  # Immediate deletion\n    retention_after_read: 0  # No redelivery protection\n    grace_period: 300        # 5 min before eligible for lifecycle\n"})}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Use Case"}),": High-throughput, reliable consumers, no message redelivery."]}),"\n",(0,l.jsx)(n.h4,{id:"example-2-conservative-handle-slow-consumers",children:"Example 2: Conservative (Handle Slow Consumers)"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-yaml",children:"claim_check:\n  ttl:\n    max_age: 86400           # 24 hour safety net\n    delete_after_read: false # Let lifecycle policy handle cleanup\n    retention_after_read: 0  # N/A (not deleting after read)\n    grace_period: 7200       # 2 hours for slow processing\n"})}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Use Case"}),": Long-running ML processing, batch jobs, debugging."]}),"\n",(0,l.jsx)(n.h4,{id:"example-3-redelivery-protection-handle-message-broker-retries",children:"Example 3: Redelivery Protection (Handle Message Broker Retries)"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-yaml",children:"claim_check:\n  ttl:\n    max_age: 7200            # 2 hour safety net\n    delete_after_read: true  # Delete to save costs\n    retention_after_read: 600 # Keep 10 min for retries\n    grace_period: 600        # 10 min before eligible\n"})}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Use Case"}),": NATS/Kafka with message redelivery on failure."]}),"\n",(0,l.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,l.jsx)(n.h3,{id:"positive",children:"Positive"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"No Orphaned Claims"}),": Bucket lifecycle policy ensures eventual cleanup"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Cost Optimization"}),": Immediate deletion reduces storage costs"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Flexible"}),": Configuration adapts to different use cases"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Redelivery Safe"}),": Retention window protects against message redelivery edge cases"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Fail-Safe"}),": If consumer deletion fails, lifecycle policy backstops"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Namespace Isolation"}),": Each namespace controls its own TTL policy"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Debugging Friendly"}),": Long TTLs enable post-mortem investigation"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"negative",children:"Negative"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Complexity"}),": Multiple cleanup mechanisms (consumer + lifecycle)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Redelivery Edge Case"}),": If claim deleted and message redelivered, consumer fails"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Storage Cost"}),": Retention windows increase storage usage"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Clock Skew"}),": TTL relies on accurate system clocks"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Lifecycle Granularity"}),": S3 lifecycle runs once per day (not immediate)"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"neutral",children:"Neutral"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Configuration Surface"}),": More TTL knobs = more tuning required"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Monitoring Need"}),": Must track claim creation/deletion rates"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Testing Complexity"}),": TTL tests require time simulation"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"lifecycle-policy-details",children:"Lifecycle Policy Details"}),"\n",(0,l.jsx)(n.h3,{id:"s3minio-lifecycle-behavior",children:"S3/MinIO Lifecycle Behavior"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Lifecycle Rules"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-xml",children:"<LifecycleConfiguration>\n  <Rule>\n    <ID>expire-claims</ID>\n    <Status>Enabled</Status>\n    <Filter>\n      <Prefix>video-processing/</Prefix>\n    </Filter>\n    <Expiration>\n      <Days>1</Days>\n    </Expiration>\n  </Rule>\n</LifecycleConfiguration>\n"})}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Timing"}),":"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"S3 processes lifecycle rules once per day (typically midnight UTC)"}),"\n",(0,l.jsxs)(n.li,{children:["Objects become eligible for deletion after ",(0,l.jsx)(n.code,{children:"Days"})," have passed"]}),"\n",(0,l.jsx)(n.li,{children:"Deletion is not immediate - may take up to 48 hours"}),"\n",(0,l.jsx)(n.li,{children:"MinIO processes rules hourly (more responsive)"}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Limitations"}),":"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Cannot set expiration <1 day on S3 (MinIO supports minutes)"}),"\n",(0,l.jsx)(n.li,{children:"Lifecycle applies to entire bucket or prefix"}),"\n",(0,l.jsx)(n.li,{children:"Cannot set per-object expiration (workaround: use object tags)"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"workaround-for-fine-grained-ttl",children:"Workaround for Fine-Grained TTL"}),"\n",(0,l.jsx)(n.p,{children:"If sub-day TTL needed:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-go",children:'// Use object tagging for fine-grained expiration\nfunc (p *Producer) uploadClaimWithTag(ctx context.Context, payload []byte) error {\n    // Upload with expiration tag\n    tags := map[string]string{\n        "expires-at": strconv.FormatInt(time.Now().Add(1*time.Hour).Unix(), 10),\n    }\n\n    err := p.objectStore.PutWithTags(ctx, bucket, key, data, tags)\n    // ...\n\n    // Separate cleanup service reads tags and deletes expired claims\n    // (More complex, but enables hour/minute-level TTL)\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"monitoring-and-alerting",children:"Monitoring and Alerting"}),"\n",(0,l.jsx)(n.h3,{id:"metrics-to-track",children:"Metrics to Track"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-go",children:"// Claim lifecycle metrics\ntype ClaimCheckMetrics struct {\n    // Producer metrics\n    ClaimsCreated         prometheus.Counter\n    ClaimUploadDuration   prometheus.Histogram\n    ClaimUploadBytes      prometheus.Histogram\n\n    // Consumer metrics\n    ClaimsRetrieved       prometheus.Counter\n    ClaimsDeleted         prometheus.Counter\n    ClaimDeleteFailures   prometheus.Counter\n    ClaimRetrievalDuration prometheus.Histogram\n    ClaimNotFoundErrors   prometheus.Counter  // Expired or missing\n\n    // Lifecycle metrics\n    ClaimsExpired         prometheus.Counter  // From lifecycle policy\n    OrphanedClaims        prometheus.Gauge    // Claims > max_age not deleted\n}\n"})}),"\n",(0,l.jsx)(n.h3,{id:"alerts",children:"Alerts"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-yaml",children:'# Alert if claims not being deleted (storage leak)\n- alert: ClaimCheckStorageLeak\n  expr: rate(claim_check_claims_created[5m]) > rate(claim_check_claims_deleted[5m]) * 1.5\n  for: 30m\n  labels:\n    severity: warning\n  annotations:\n    summary: "Claim check storage leak detected"\n    description: "Claims being created faster than deleted for {{ $labels.namespace }}"\n\n# Alert if many claims not found (TTL too short)\n- alert: ClaimCheckTTLTooShort\n  expr: rate(claim_check_claim_not_found_errors[5m]) > 0.01\n  for: 10m\n  labels:\n    severity: warning\n  annotations:\n    summary: "Claim check TTL may be too short"\n    description: "Consumers encountering expired claims in {{ $labels.namespace }}"\n\n# Alert if claim delete failures\n- alert: ClaimCheckDeleteFailures\n  expr: rate(claim_check_claim_delete_failures[5m]) > 0.1\n  for: 10m\n  labels:\n    severity: warning\n  annotations:\n    summary: "Claim check delete failures"\n    description: "Consumer failing to delete claims in {{ $labels.namespace }}"\n'})}),"\n",(0,l.jsx)(n.h3,{id:"dashboard-panels",children:"Dashboard Panels"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-promql",children:"# Claim creation rate\nrate(claim_check_claims_created[5m])\n\n# Claim deletion rate\nrate(claim_check_claims_deleted[5m])\n\n# Outstanding claims (created - deleted)\nsum(claim_check_claims_created) - sum(claim_check_claims_deleted)\n\n# Average claim lifetime (creation to deletion)\nhistogram_quantile(0.50, claim_check_claim_lifetime_seconds_bucket)\n\n# Storage usage (estimated)\nsum(claim_check_claim_upload_bytes) * (1 - rate(claim_check_claims_deleted[5m]) / rate(claim_check_claims_created[5m]))\n"})}),"\n",(0,l.jsx)(n.h2,{id:"testing-strategy",children:"Testing Strategy"}),"\n",(0,l.jsx)(n.h3,{id:"unit-tests-time-simulation",children:"Unit Tests (Time Simulation)"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-go",children:"func TestClaimExpiration(t *testing.T) {\n    // Use mock clock\n    clock := clockwork.NewFakeClock()\n\n    producer := NewProducerWithClock(config, clock)\n    claim, err := producer.uploadClaim(ctx, largePayload)\n    require.NoError(t, err)\n\n    // Advance clock past expiration\n    clock.Advance(25 * time.Hour)\n\n    // Consumer should fail to retrieve\n    _, err = consumer.retrieveClaim(ctx, claim)\n    assert.ErrorIs(t, err, ErrClaimExpired)\n}\n\nfunc TestDeleteAfterRead(t *testing.T) {\n    config := Config{\n        ClaimCheck: &ClaimCheckConfig{\n            TTL: ClaimCheckTTL{\n                DeleteAfterRead: true,\n            },\n        },\n    }\n\n    consumer := NewConsumer(config)\n    payload, err := consumer.retrieveClaim(ctx, claim)\n    require.NoError(t, err)\n\n    // Wait for async deletion\n    time.Sleep(100 * time.Millisecond)\n\n    // Claim should be gone\n    exists, err := objectStore.Exists(ctx, claim.Bucket, claim.ObjectKey)\n    require.NoError(t, err)\n    assert.False(t, exists)\n}\n"})}),"\n",(0,l.jsx)(n.h3,{id:"integration-tests-minio-lifecycle",children:"Integration Tests (MinIO Lifecycle)"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-go",children:"func TestLifecycleCleanup(t *testing.T) {\n    // Start MinIO with lifecycle enabled\n    driver, cleanup := setupMinIOWithLifecycle(t)\n    defer cleanup()\n\n    // Upload claim\n    claim, err := producer.uploadClaim(ctx, largePayload)\n    require.NoError(t, err)\n\n    // Verify claim exists\n    exists, _ := driver.Exists(ctx, claim.Bucket, claim.ObjectKey)\n    assert.True(t, exists)\n\n    // Fast-forward lifecycle (MinIO test mode can run lifecycle on-demand)\n    driver.TriggerLifecycle(ctx, claim.Bucket)\n\n    // Claim should be deleted after lifecycle runs\n    exists, _ = driver.Exists(ctx, claim.Bucket, claim.ObjectKey)\n    assert.False(t, exists)\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,l.jsx)(n.h3,{id:"1-no-automatic-cleanup",children:"1. No Automatic Cleanup"}),"\n",(0,l.jsx)(n.p,{children:"Require manual claim deletion by consumers."}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Rejected"}),": Error-prone, orphans accumulate, unbounded storage cost."]}),"\n",(0,l.jsx)(n.h3,{id:"2-separate-cleanup-service",children:"2. Separate Cleanup Service"}),"\n",(0,l.jsx)(n.p,{children:"Background service scans object store and deletes expired claims."}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Rejected"}),": Adds operational complexity, lifecycle policies are simpler."]}),"\n",(0,l.jsx)(n.h3,{id:"3-database-tracked-ttl",children:"3. Database-Tracked TTL"}),"\n",(0,l.jsx)(n.p,{children:"Store claim metadata in database with TTL, delete objects based on DB."}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Rejected"}),": Adds database dependency, lifecycle policies are native to object stores."]}),"\n",(0,l.jsx)(n.h3,{id:"4-always-delete-immediately",children:"4. Always Delete Immediately"}),"\n",(0,l.jsx)(n.p,{children:"No retention window, delete claim as soon as consumer retrieves."}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Rejected"}),": Breaks message redelivery scenarios (NATS retries, Kafka rebalancing)."]}),"\n",(0,l.jsx)(n.h3,{id:"5-never-delete-explicitly",children:"5. Never Delete Explicitly"}),"\n",(0,l.jsx)(n.p,{children:"Rely entirely on lifecycle policies for cleanup."}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Rejected"}),": Storage costs higher, lifecycle granularity insufficient (daily runs)."]}),"\n",(0,l.jsx)(n.h2,{id:"open-questions",children:"Open Questions"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Cross-Namespace Claims"}),": Can producer in namespace A store claim for consumer in namespace B?\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Answer"}),": No - namespace isolation enforced by bucket prefix"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Multipart Cleanup"}),": How are abandoned multipart uploads cleaned?\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Answer"}),": Separate lifecycle rule for incomplete multipart uploads"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Claim Reuse"}),": Should we support updating/extending claim TTL?\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Answer"}),": No - simplicity over flexibility"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Storage Class"}),": Should old claims move to cheaper storage (Glacier)?\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Answer"}),": Deferred - typically deleted before archival makes sense"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-lifecycle-mgmt.html",children:"S3 Lifecycle Configuration"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"https://min.io/docs/minio/linux/administration/object-management/object-lifecycle-management.html",children:"MinIO Lifecycle Management"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"https://cloud.google.com/storage/docs/lifecycle",children:"GCS Object Lifecycle"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/azure/storage/blobs/lifecycle-management-overview",children:"Azure Blob Lifecycle"})}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"related-documents",children:"Related Documents"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"RFC-033: Claim Check Pattern for Large Payloads"}),"\n",(0,l.jsx)(n.li,{children:"ADR-051: MinIO for Claim Check Testing"}),"\n",(0,l.jsx)(n.li,{children:"ADR-052: Object Store Interface Design"}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>c});var r=i(96540);const l={},a=r.createContext(l);function t(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:t(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);