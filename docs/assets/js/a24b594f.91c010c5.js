"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[1452],{4925:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"go-error-handling-strategy","title":"ADR-013: Go Error Handling Strategy","description":"Context","source":"@site/../docs-cms/adr/013-go-error-handling-strategy.md","sourceDirName":".","slug":"/go-error-handling-strategy","permalink":"/prism-data-layer/adr/go-error-handling-strategy","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/013-go-error-handling-strategy.md","tags":[{"inline":true,"label":"go","permalink":"/prism-data-layer/adr/tags/go"},{"inline":true,"label":"error-handling","permalink":"/prism-data-layer/adr/tags/error-handling"},{"inline":true,"label":"reliability","permalink":"/prism-data-layer/adr/tags/reliability"},{"inline":true,"label":"observability","permalink":"/prism-data-layer/adr/tags/observability"}],"version":"current","sidebarPosition":13,"frontMatter":{"title":"ADR-013: Go Error Handling Strategy","status":"Accepted","date":"2025-10-07T00:00:00.000Z","deciders":"Core Team","tags":["go","error-handling","reliability","observability"]},"sidebar":"adrSidebar","previous":{"title":"ADR-012: Go for Tooling and CLI Utilities","permalink":"/prism-data-layer/adr/go-for-tooling"},"next":{"title":"ADR-014: Go Concurrency Patterns","permalink":"/prism-data-layer/adr/go-concurrency-patterns"}}');var t=r(4848),s=r(8453);const l={title:"ADR-013: Go Error Handling Strategy",status:"Accepted",date:new Date("2025-10-07T00:00:00.000Z"),deciders:"Core Team",tags:["go","error-handling","reliability","observability"]},o=void 0,a={},d=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Why Error Wrapping",id:"why-error-wrapping",level:3},{value:"Why Early Error Reporting",id:"why-early-error-reporting",level:3},{value:"Alternatives Considered",id:"alternatives-considered",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Implementation Notes",id:"implementation-notes",level:2},{value:"Sentinel Errors",id:"sentinel-errors",level:3},{value:"Error Wrapping Pattern",id:"error-wrapping-pattern",level:3},{value:"Testing Error Conditions",id:"testing-error-conditions",level:3},{value:"Error Context Guidelines",id:"error-context-guidelines",level:3},{value:"References",id:"references",level:2},{value:"Revision History",id:"revision-history",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,t.jsx)(n.p,{children:"Go tooling and CLI utilities require consistent error handling patterns. We need a strategy that:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Preserves error context through call chains"}),"\n",(0,t.jsx)(n.li,{children:"Enables debugging without verbose logging"}),"\n",(0,t.jsx)(n.li,{children:"Follows Go 1.25+ best practices"}),"\n",(0,t.jsx)(n.li,{children:"Reports errors at handler boundaries"}),"\n",(0,t.jsx)(n.li,{children:"Supports structured error analysis"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,t.jsx)(n.p,{children:"Adopt modern Go error handling with wrapped context and early error reporting:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.strong,{children:["Use ",(0,t.jsx)(n.code,{children:"fmt.Errorf"})," with ",(0,t.jsx)(n.code,{children:"%w"})," for error wrapping"]})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Report errors at the top of handlers"})," (fail-fast principle)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Add context at each layer"})," (function name, operation, parameters)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use sentinel errors"})," for well-known error conditions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Return errors immediately"})," rather than accumulating"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"rationale",children:"Rationale"}),"\n",(0,t.jsx)(n.h3,{id:"why-error-wrapping",children:"Why Error Wrapping"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'// Modern approach - preserves full context\nif err := connectBackend(namespace); err != nil {\n    return fmt.Errorf("connectBackend(%s): %w", namespace, err)\n}\n\n// Allows callers to unwrap and inspect\nif errors.Is(err, ErrBackendUnavailable) {\n    // Handle specific error\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Full stack trace without overhead"}),"\n",(0,t.jsxs)(n.li,{children:["Programmatic error inspection with ",(0,t.jsx)(n.code,{children:"errors.Is"})," and ",(0,t.jsx)(n.code,{children:"errors.As"})]}),"\n",(0,t.jsx)(n.li,{children:"Clear failure path through logs"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"why-early-error-reporting",children:"Why Early Error Reporting"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'// Report errors at the top (fail-fast)\nfunc MigrateData(ctx context.Context, source, dest string) error {\n    srcConn, err := openConnection(source)\n    if err != nil {\n        return fmt.Errorf("MigrateData: open source: %w", err)\n    }\n    defer srcConn.Close()\n\n    destConn, err := openConnection(dest)\n    if err != nil {\n        return fmt.Errorf("MigrateData: open dest: %w", err)\n    }\n    defer destConn.Close()\n\n    // ... continue processing\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Reduces nesting and improves readability"}),"\n",(0,t.jsx)(n.li,{children:"Makes error paths explicit"}),"\n",(0,t.jsx)(n.li,{children:"Aligns with Go idioms"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Exception-style panic/recover"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Pros: Simpler control flow"}),"\n",(0,t.jsx)(n.li,{children:"Cons: Not idiomatic Go, hides errors, harder to debug"}),"\n",(0,t.jsx)(n.li,{children:"Rejected: Go community consensus favors explicit errors"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Error accumulation patterns"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Pros: Can process multiple failures"}),"\n",(0,t.jsx)(n.li,{children:"Cons: Harder to reason about, delayed failure detection"}),"\n",(0,t.jsx)(n.li,{children:"Rejected: Infrastructure tools should fail fast"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Third-party error libraries (pkg/errors)"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Pros: Stack traces, additional features"}),"\n",(0,t.jsx)(n.li,{children:"Cons: Dependency overhead, stdlib now sufficient"}),"\n",(0,t.jsx)(n.li,{children:"Rejected: Go 1.13+ error wrapping is sufficient"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,t.jsx)(n.h3,{id:"positive",children:"Positive"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Errors carry full context without verbose logging"}),"\n",(0,t.jsx)(n.li,{children:"Debugging is straightforward (follow the wrapped chain)"}),"\n",(0,t.jsx)(n.li,{children:"Error handling is testable (check for sentinel errors)"}),"\n",(0,t.jsx)(n.li,{children:"Aligns with Go 1.25 idioms"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"negative",children:"Negative"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Requires discipline to wrap at every layer"}),"\n",(0,t.jsx)(n.li,{children:"Error messages can become verbose if not carefully structured"}),"\n",(0,t.jsx)(n.li,{children:"Must decide what context to add at each layer"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"neutral",children:"Neutral"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Error handling code is explicit (not hidden in abstractions)"}),"\n",(0,t.jsx)(n.li,{children:"Need to define sentinel errors for known conditions"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,t.jsx)(n.h3,{id:"sentinel-errors",children:"Sentinel Errors"}),"\n",(0,t.jsx)(n.p,{children:"Define package-level sentinel errors:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'package backend\n\nimport "errors"\n\nvar (\n    ErrBackendUnavailable = errors.New("backend unavailable")\n    ErrNamespaceNotFound  = errors.New("namespace not found")\n    ErrInvalidConfig      = errors.New("invalid configuration")\n)\n'})}),"\n",(0,t.jsx)(n.h3,{id:"error-wrapping-pattern",children:"Error Wrapping Pattern"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'// Low-level function\nfunc validateConfig(cfg *Config) error {\n    if cfg.Namespace == "" {\n        return fmt.Errorf("validateConfig: %w: namespace empty", ErrInvalidConfig)\n    }\n    return nil\n}\n\n// Mid-level function\nfunc connectBackend(namespace string) (*Connection, error) {\n    cfg, err := loadConfig(namespace)\n    if err != nil {\n        return nil, fmt.Errorf("connectBackend: load config: %w", err)\n    }\n\n    if err := validateConfig(cfg); err != nil {\n        return nil, fmt.Errorf("connectBackend: %w", err)\n    }\n\n    conn, err := dial(cfg.Endpoint)\n    if err != nil {\n        return nil, fmt.Errorf("connectBackend: dial %s: %w", cfg.Endpoint, err)\n    }\n\n    return conn, nil\n}\n\n// Top-level handler\nfunc MigrateNamespace(ctx context.Context, namespace string) error {\n    conn, err := connectBackend(namespace)\n    if err != nil {\n        return fmt.Errorf("MigrateNamespace(%s): %w", namespace, err)\n    }\n    defer conn.Close()\n\n    return runMigration(ctx, conn)\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"testing-error-conditions",children:"Testing Error Conditions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'func TestConnectBackend_InvalidConfig(t *testing.T) {\n    _, err := connectBackend("")\n    if !errors.Is(err, ErrInvalidConfig) {\n        t.Errorf("expected ErrInvalidConfig, got %v", err)\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"error-context-guidelines",children:"Error Context Guidelines"}),"\n",(0,t.jsx)(n.p,{children:"Add context that helps debugging:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Function name (especially at package boundaries)"}),"\n",(0,t.jsx)(n.li,{children:"Parameters that identify the operation (namespace, path, endpoint)"}),"\n",(0,t.jsx)(n.li,{children:"Operation description (what was being attempted)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Avoid adding:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Redundant context (don't repeat what's already in wrapped error)"}),"\n",(0,t.jsx)(n.li,{children:"Secrets or sensitive data"}),"\n",(0,t.jsx)(n.li,{children:"Full object dumps (use identifiers instead)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://go.dev/blog/error-handling-and-go",children:"Go Blog: Error handling and Go"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://go.dev/blog/go1.13-errors",children:"Go Blog: Working with Errors in Go 1.13"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://go.dev/doc/effective_go#errors",children:"Effective Go: Errors"})}),"\n",(0,t.jsx)(n.li,{children:"ADR-012: Go for Tooling"}),"\n",(0,t.jsx)(n.li,{children:"org-stream-producer ADR-005: Error Handling Strategy"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"2025-10-07: Initial draft and acceptance (adapted from org-stream-producer)"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>o});var i=r(6540);const t={},s=i.createContext(t);function l(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);