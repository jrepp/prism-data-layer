"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[8317],{1539:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"go-structured-logging","title":"ADR-017: Go Structured Logging with slog","description":"Context","source":"@site/../docs-cms/adr/017-go-structured-logging.md","sourceDirName":".","slug":"/go-structured-logging","permalink":"/prism-data-layer/adr/go-structured-logging","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/017-go-structured-logging.md","tags":[{"inline":true,"label":"go","permalink":"/prism-data-layer/adr/tags/go"},{"inline":true,"label":"logging","permalink":"/prism-data-layer/adr/tags/logging"},{"inline":true,"label":"observability","permalink":"/prism-data-layer/adr/tags/observability"},{"inline":true,"label":"debugging","permalink":"/prism-data-layer/adr/tags/debugging"}],"version":"current","sidebarPosition":17,"frontMatter":{"title":"ADR-017: Go Structured Logging with slog","status":"Accepted","date":"2025-10-07T00:00:00.000Z","deciders":"Core Team","tags":["go","logging","observability","debugging"]},"sidebar":"adrSidebar","previous":{"title":"ADR-016: Go CLI and Configuration Management","permalink":"/prism-data-layer/adr/go-cli-configuration"},"next":{"title":"ADR-018: Rust Error Handling Strategy","permalink":"/prism-data-layer/adr/rust-error-handling-strategy"}}');var l=r(4848),t=r(8453);const o={title:"ADR-017: Go Structured Logging with slog",status:"Accepted",date:new Date("2025-10-07T00:00:00.000Z"),deciders:"Core Team",tags:["go","logging","observability","debugging"]},s=void 0,a={},d=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Why slog (Go 1.21+ Standard Library)",id:"why-slog-go-121-standard-library",level:3},{value:"Why NOT zap or logrus?",id:"why-not-zap-or-logrus",level:3},{value:"Context Propagation Pattern",id:"context-propagation-pattern",level:3},{value:"Logging Schema",id:"logging-schema",level:2},{value:"Log Levels",id:"log-levels",level:3},{value:"Standard Fields (always present)",id:"standard-fields-always-present",level:3},{value:"Contextual Fields (operation-specific)",id:"contextual-fields-operation-specific",level:3},{value:"Error Fields",id:"error-fields",level:3},{value:"Implementation Pattern",id:"implementation-pattern",level:2},{value:"Package Structure",id:"package-structure",level:3},{value:"Core API",id:"core-api",level:3},{value:"Usage Examples",id:"usage-examples",level:3},{value:"Performance-Critical Paths",id:"performance-critical-paths",level:3},{value:"Testing Pattern",id:"testing-pattern",level:3},{value:"Logging Guidelines",id:"logging-guidelines",level:2},{value:"DO:",id:"do",level:3},{value:"DON&#39;T:",id:"dont",level:3},{value:"Log Level Guidelines",id:"log-level-guidelines",level:2},{value:"Debug",id:"debug",level:3},{value:"Info",id:"info",level:3},{value:"Warn",id:"warn",level:3},{value:"Error",id:"error",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Mitigations",id:"mitigations",level:3},{value:"References",id:"references",level:2},{value:"Revision History",id:"revision-history",level:2}];function g(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,l.jsx)(n.p,{children:"Go tooling requires production-grade logging with:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Structured fields for machine parsing"}),"\n",(0,l.jsx)(n.li,{children:"Context propagation through call stacks"}),"\n",(0,l.jsx)(n.li,{children:"High performance (minimal overhead)"}),"\n",(0,l.jsx)(n.li,{children:"Integration with observability systems"}),"\n",(0,l.jsx)(n.li,{children:"Standard library compatibility"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,l.jsxs)(n.p,{children:["Use ",(0,l.jsx)(n.strong,{children:"slog"})," (Go standard library) for structured logging with context management."]}),"\n",(0,l.jsx)(n.h2,{id:"rationale",children:"Rationale"}),"\n",(0,l.jsx)(n.h3,{id:"why-slog-go-121-standard-library",children:"Why slog (Go 1.21+ Standard Library)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Standard Library"}),": No external dependency, guaranteed compatibility"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Performance"}),": Designed for high-throughput logging"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Structured by Default"}),": Key-value pairs, not string formatting"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Context Integration"}),": First-class ",(0,l.jsx)(n.code,{children:"context.Context"})," support"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Handlers"}),": JSON, Text, and custom handlers"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Levels"}),": Debug, Info, Warn, Error"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Attributes"}),": Rich type support (string, int, bool, time, error, etc.)"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"why-not-zap-or-logrus",children:"Why NOT zap or logrus?"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"zap"}),": Excellent performance, but slog is now in stdlib with comparable speed"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"logrus"}),": Mature but slower, maintenance mode, superseded by slog"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"zerolog"}),": Fast but non-standard API, less idiomatic"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"context-propagation-pattern",children:"Context Propagation Pattern"}),"\n",(0,l.jsx)(n.p,{children:"Logging flows through context to maintain operation correlation:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-go",children:'// Add logger to context\nctx := log.WithContext(ctx, logger.With("operation", "migrate", "namespace", ns))\n\n// Extract logger from context\nlogger := log.FromContext(ctx)\nlogger.Info("starting migration")\n'})}),"\n",(0,l.jsx)(n.h2,{id:"logging-schema",children:"Logging Schema"}),"\n",(0,l.jsx)(n.h3,{id:"log-levels",children:"Log Levels"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Debug"}),": Detailed diagnostic information (disabled in production)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Info"}),": General informational messages (normal operations)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Warn"}),": Warning conditions that don't prevent operation"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Error"}),": Error conditions that prevent specific operation"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"standard-fields-always-present",children:"Standard Fields (always present)"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-json",children:'{\n  "time": "2025-10-07T12:00:00Z",\n  "level": "info",\n  "msg": "migration completed",\n  "service": "prism-migrate",\n  "version": "1.0.0"\n}\n'})}),"\n",(0,l.jsx)(n.h3,{id:"contextual-fields-operation-specific",children:"Contextual Fields (operation-specific)"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-json",children:'{\n  "time": "2025-10-07T12:00:00Z",\n  "level": "info",\n  "msg": "migration completed",\n  "service": "prism-migrate",\n  "version": "1.0.0",\n  "namespace": "production",\n  "operation": "migrate",\n  "rows_migrated": 15234,\n  "duration_ms": 5230,\n  "workers": 8\n}\n'})}),"\n",(0,l.jsx)(n.h3,{id:"error-fields",children:"Error Fields"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-json",children:'{\n  "time": "2025-10-07T12:00:00Z",\n  "level": "error",\n  "msg": "migration failed",\n  "service": "prism-migrate",\n  "error": "backend unavailable",\n  "error_type": "ErrBackendUnavailable",\n  "namespace": "production",\n  "retry_count": 3\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"implementation-pattern",children:"Implementation Pattern"}),"\n",(0,l.jsx)(n.h3,{id:"package-structure",children:"Package Structure"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"tools/internal/\n  log/\n    log.go           # slog wrapper with context helpers\n    context.go       # Context management\n    log_test.go      # Tests\n"})}),"\n",(0,l.jsx)(n.h3,{id:"core-api",children:"Core API"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-go",children:'package log\n\nimport (\n    "context"\n    "log/slog"\n    "os"\n)\n\nvar global *slog.Logger\n\n// Init initializes the global logger\nfunc Init(level slog.Level, format string) error {\n    var handler slog.Handler\n\n    switch format {\n    case "json":\n        handler = slog.NewJSONHandler(os.Stderr, &slog.HandlerOptions{\n            Level:     level,\n            AddSource: level == slog.LevelDebug,\n        })\n    case "text":\n        handler = slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{\n            Level:     level,\n            AddSource: level == slog.LevelDebug,\n        })\n    default:\n        return fmt.Errorf("unknown log format: %s", format)\n    }\n\n    // Add service metadata\n    handler = withServiceMetadata(handler)\n\n    global = slog.New(handler)\n    slog.SetDefault(global)\n\n    return nil\n}\n\n// WithContext adds logger to context\nfunc WithContext(ctx context.Context, logger *slog.Logger) context.Context {\n    return context.WithValue(ctx, loggerKey{}, logger)\n}\n\n// FromContext extracts logger from context (or returns default)\nfunc FromContext(ctx context.Context) *slog.Logger {\n    if logger, ok := ctx.Value(loggerKey{}).(*slog.Logger); ok {\n        return logger\n    }\n    return slog.Default()\n}\n\n// With adds fields to logger in context\nfunc With(ctx context.Context, args ...any) context.Context {\n    logger := FromContext(ctx).With(args...)\n    return WithContext(ctx, logger)\n}\n\ntype loggerKey struct{}\n'})}),"\n",(0,l.jsx)(n.h3,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-go",children:'// Initialize at startup\nif err := log.Init(slog.LevelInfo, "json"); err != nil {\n    panic(err)\n}\n\n// Add operation context\nctx := log.WithContext(ctx, slog.Default().With(\n    "operation", "migrate",\n    "namespace", namespace,\n))\n\n// Log with context\nlogger := log.FromContext(ctx)\nlogger.Info("starting migration")\n\n// Add more fields\nctx = log.With(ctx, "rows", count)\nlog.FromContext(ctx).Info("migrated rows")\n\n// Error logging\nlogger.Error("migration failed",\n    "error", err,\n    "namespace", namespace,\n    "retry", retry,\n)\n\n// Debug logging (only in debug mode)\nlogger.Debug("worker started",\n    "worker_id", workerID,\n    "queue_size", queueSize,\n)\n'})}),"\n",(0,l.jsx)(n.h3,{id:"performance-critical-paths",children:"Performance-Critical Paths"}),"\n",(0,l.jsx)(n.p,{children:"For hot paths, use conditional logging:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-go",children:'if logger.Enabled(ctx, slog.LevelDebug) {\n    logger.DebugContext(ctx, "processing item",\n        "item_id", id,\n        "batch", batchNum,\n    )\n}\n'})}),"\n",(0,l.jsx)(n.h3,{id:"testing-pattern",children:"Testing Pattern"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-go",children:'// Custom handler for testing\ntype TestHandler struct {\n    logs []slog.Record\n    mu   sync.Mutex\n}\n\nfunc (h *TestHandler) Handle(ctx context.Context, r slog.Record) error {\n    h.mu.Lock()\n    defer h.mu.Unlock()\n    h.logs = append(h.logs, r)\n    return nil\n}\n\n// Test example\nfunc TestMigrate_Logging(t *testing.T) {\n    handler := &TestHandler{}\n    logger := slog.New(handler)\n    ctx := log.WithContext(context.Background(), logger)\n\n    // Code that logs\n    migrate(ctx, "test-namespace")\n\n    // Assert logs\n    if len(handler.logs) < 1 {\n        t.Error("expected at least 1 log entry")\n    }\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"logging-guidelines",children:"Logging Guidelines"}),"\n",(0,l.jsx)(n.h3,{id:"do",children:"DO:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Use structured fields, not string formatting"}),"\n",(0,l.jsx)(n.li,{children:"Pass context through call stack"}),"\n",(0,l.jsx)(n.li,{children:"Log errors with context (namespace, operation, etc.)"}),"\n",(0,l.jsx)(n.li,{children:"Use appropriate log levels"}),"\n",(0,l.jsx)(n.li,{children:"Include duration for operations"}),"\n",(0,l.jsx)(n.li,{children:"Log at service boundaries (start/end of major operations)"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"dont",children:"DON'T:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Log in tight loops"}),"\n",(0,l.jsx)(n.li,{children:"Log sensitive data (credentials, PII)"}),"\n",(0,l.jsx)(n.li,{children:"Use global logger (use context instead)"}),"\n",(0,l.jsx)(n.li,{children:"Format strings with %v (use structured fields)"}),"\n",(0,l.jsx)(n.li,{children:"Log at Info level for internal function calls"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"log-level-guidelines",children:"Log Level Guidelines"}),"\n",(0,l.jsx)(n.h3,{id:"debug",children:"Debug"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Internal function entry/exit"}),"\n",(0,l.jsx)(n.li,{children:"Variable values during debugging"}),"\n",(0,l.jsx)(n.li,{children:"Detailed state information"}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.strong,{children:"Disabled in production"})}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"info",children:"Info"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Service start/stop"}),"\n",(0,l.jsx)(n.li,{children:"Major operation start/complete"}),"\n",(0,l.jsx)(n.li,{children:"Configuration loaded"}),"\n",(0,l.jsx)(n.li,{children:"Summary statistics"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"warn",children:"Warn"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Degraded performance"}),"\n",(0,l.jsx)(n.li,{children:"Retryable errors"}),"\n",(0,l.jsx)(n.li,{children:"Non-fatal issues"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"error",children:"Error"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Failed operations"}),"\n",(0,l.jsx)(n.li,{children:"Unrecoverable errors"}),"\n",(0,l.jsx)(n.li,{children:"Connection failures"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,l.jsx)(n.h3,{id:"positive",children:"Positive"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Zero external dependencies (stdlib)"}),"\n",(0,l.jsx)(n.li,{children:"Excellent performance"}),"\n",(0,l.jsx)(n.li,{children:"First-class context support"}),"\n",(0,l.jsx)(n.li,{children:"Structured logging enforced by API"}),"\n",(0,l.jsx)(n.li,{children:"Easy testing with custom handlers"}),"\n",(0,l.jsx)(n.li,{children:"Future-proof (Go stdlib commitment)"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"negative",children:"Negative"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"slog is relatively new (Go 1.21+)"}),"\n",(0,l.jsx)(n.li,{children:"Basic functionality (no log rotation, sampling, etc.)"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"mitigations",children:"Mitigations"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Require Go 1.25 (already planned)"}),"\n",(0,l.jsx)(n.li,{children:"Use external tools for log aggregation (Fluentd, Logstash)"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"https://pkg.go.dev/log/slog",children:"slog Documentation"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"https://go.googlesource.com/proposal/+/master/design/56345-structured-logging.md",children:"slog Design Proposal"})}),"\n",(0,l.jsx)(n.li,{children:"ADR-012: Go for Tooling"}),"\n",(0,l.jsx)(n.li,{children:"ADR-008: Observability Strategy"}),"\n",(0,l.jsx)(n.li,{children:"org-stream-producer ADR-011: Structured Logging"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"2025-10-07: Initial draft and acceptance (adapted from org-stream-producer)"}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(g,{...e})}):g(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>s});var i=r(6540);const l={},t=i.createContext(l);function o(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);