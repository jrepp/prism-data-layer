"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[33103],{28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>a});var r=t(96540);const i={},s=r.createContext(i);function c(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),r.createElement(s.Provider,{value:n},e.children)}},44676:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>u,frontMatter:()=>c,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"adr-052","title":"ADR-052: Object Store Interface Design","description":"Status","source":"@site/../docs-cms/adr/adr-052-object-store-interface.md","sourceDirName":".","slug":"/adr-052","permalink":"/prism-data-layer/adr/adr-052","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/adr-052-object-store-interface.md","tags":[{"inline":true,"label":"architecture","permalink":"/prism-data-layer/adr/tags/architecture"},{"inline":true,"label":"interfaces","permalink":"/prism-data-layer/adr/tags/interfaces"},{"inline":true,"label":"object-storage","permalink":"/prism-data-layer/adr/tags/object-storage"},{"inline":true,"label":"s3","permalink":"/prism-data-layer/adr/tags/s-3"},{"inline":true,"label":"abstraction","permalink":"/prism-data-layer/adr/tags/abstraction"},{"inline":true,"label":"plugin","permalink":"/prism-data-layer/adr/tags/plugin"}],"version":"current","frontMatter":{"title":"ADR-052: Object Store Interface Design","status":"Proposed","date":"2025-10-14T00:00:00.000Z","deciders":"Core Team","tags":["architecture","interfaces","object-storage","s3","abstraction","plugin"],"id":"adr-052","project_id":"prism-data-layer","doc_uuid":"9efef801-ccc1-4e28-a5f3-3c3c13b1994b"},"sidebar":"adrSidebar","previous":{"title":"MinIO for Claim Check Pattern Testing \u2022 ADR-051","permalink":"/prism-data-layer/adr/adr-051"},"next":{"title":"Claim Check TTL and Garbage Collection \u2022 ADR-053","permalink":"/prism-data-layer/adr/adr-053"}}');var i=t(74848),s=t(28453);const c={title:"ADR-052: Object Store Interface Design",status:"Proposed",date:new Date("2025-10-14T00:00:00.000Z"),deciders:"Core Team",tags:["architecture","interfaces","object-storage","s3","abstraction","plugin"],id:"adr-052",project_id:"prism-data-layer",doc_uuid:"9efef801-ccc1-4e28-a5f3-3c3c13b1994b"},a="ADR-052: Object Store Interface Design",o={},l=[{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Design Constraints",id:"design-constraints",level:3},{value:"Decision",id:"decision",level:2},{value:"Core Interface",id:"core-interface",level:3},{value:"Design Principles",id:"design-principles",level:3},{value:"1. Minimal Surface Area",id:"1-minimal-surface-area",level:4},{value:"2. Bucket-Scoped",id:"2-bucket-scoped",level:4},{value:"3. Streaming Support",id:"3-streaming-support",level:4},{value:"4. Idempotent Deletes",id:"4-idempotent-deletes",level:4},{value:"5. Metadata Separation",id:"5-metadata-separation",level:4},{value:"6. TTL Abstraction",id:"6-ttl-abstraction",level:4},{value:"Implementation Strategy",id:"implementation-strategy",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Implementation Phases",id:"implementation-phases",level:2},{value:"Phase 1: Interface Definition (1 day)",id:"phase-1-interface-definition-1-day",level:3},{value:"Phase 2: MinIO Driver (3 days)",id:"phase-2-minio-driver-3-days",level:3},{value:"Phase 3: S3 Driver (3 days)",id:"phase-3-s3-driver-3-days",level:3},{value:"Phase 4: Mock Implementation (1 day)",id:"phase-4-mock-implementation-1-day",level:3},{value:"Testing Strategy",id:"testing-strategy",level:2},{value:"Unit Tests (No External Dependencies)",id:"unit-tests-no-external-dependencies",level:3},{value:"Integration Tests (MinIO via testcontainers)",id:"integration-tests-minio-via-testcontainers",level:3},{value:"Contract Tests (Verify Backend Compatibility)",id:"contract-tests-verify-backend-compatibility",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Error Types",id:"error-types",level:3},{value:"Error Translation",id:"error-translation",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"1. Access Control",id:"1-access-control",level:3},{value:"2. Encryption",id:"2-encryption",level:3},{value:"3. Network Security",id:"3-network-security",level:3},{value:"4. Audit Logging",id:"4-audit-logging",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"1. Connection Pooling",id:"1-connection-pooling",level:3},{value:"2. Retry Strategy",id:"2-retry-strategy",level:3},{value:"3. Streaming Thresholds",id:"3-streaming-thresholds",level:3},{value:"4. Metadata Caching",id:"4-metadata-caching",level:3},{value:"Alternatives Considered",id:"alternatives-considered",level:2},{value:"1. Blob-Specific Interfaces",id:"1-blob-specific-interfaces",level:3},{value:"2. Full S3 API Coverage",id:"2-full-s3-api-coverage",level:3},{value:"3. Generic Key-Value Interface",id:"3-generic-key-value-interface",level:3},{value:"4. Pre-signed URL Generation",id:"4-pre-signed-url-generation",level:3},{value:"Open Questions",id:"open-questions",level:2},{value:"References",id:"references",level:2},{value:"Related Documents",id:"related-documents",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"adr-052-object-store-interface-design",children:"ADR-052: Object Store Interface Design"})}),"\n",(0,i.jsx)(n.h2,{id:"status",children:"Status"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Proposed"})," - Pending review"]}),"\n",(0,i.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,i.jsx)(n.p,{children:"The claim check pattern (RFC-033) requires storing large payloads in object storage (S3, MinIO, GCS, Azure Blob). We need a unified interface that:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Abstracts Backend Differences"}),": S3, GCS, Azure Blob have similar but different APIs"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Supports Claim Check Operations"}),": Put, Get, Delete, TTL management"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Enables Testing"}),": Works with MinIO for local testing and real backends in production"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Maintains Performance"}),": Efficient for both small metadata and large payloads"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Follows Plugin Architecture"}),": Consistent with existing driver patterns"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"design-constraints",children:"Design Constraints"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Must support S3-compatible backends (MinIO, DigitalOcean Spaces, Wasabi)"}),"\n",(0,i.jsx)(n.li,{children:"Must support native cloud APIs (GCS, Azure Blob)"}),"\n",(0,i.jsx)(n.li,{children:"Should handle objects from 1KB to 5GB+"}),"\n",(0,i.jsx)(n.li,{children:"Must support object metadata (content-type, checksums, custom headers)"}),"\n",(0,i.jsx)(n.li,{children:"Must support TTL/expiration via lifecycle policies"}),"\n",(0,i.jsx)(n.li,{children:"Should enable streaming for large objects"}),"\n",(0,i.jsx)(n.li,{children:"Must be testable without real cloud accounts"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Define a minimal ",(0,i.jsx)(n.code,{children:"ObjectStoreInterface"})," focused on claim check use cases."]})}),"\n",(0,i.jsx)(n.h3,{id:"core-interface",children:"Core Interface"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// pkg/plugin/interfaces.go\n\n// ObjectStoreInterface defines object storage operations for claim check pattern\ntype ObjectStoreInterface interface {\n    // Put stores an object at the given key\n    // Returns error if bucket doesn't exist or operation fails\n    Put(ctx context.Context, bucket, key string, data []byte) error\n\n    // PutStream stores an object from a reader (for large payloads)\n    // Caller is responsible for closing the reader\n    PutStream(ctx context.Context, bucket, key string, reader io.Reader, size int64) error\n\n    // Get retrieves an object\n    // Returns error if object doesn't exist\n    Get(ctx context.Context, bucket, key string) ([]byte, error)\n\n    // GetStream retrieves an object as a stream (for large payloads)\n    // Caller must close the returned reader\n    GetStream(ctx context.Context, bucket, key string) (io.ReadCloser, error)\n\n    // Delete removes an object\n    // Returns nil if object doesn't exist (idempotent)\n    Delete(ctx context.Context, bucket, key string) error\n\n    // Exists checks if an object exists without downloading\n    Exists(ctx context.Context, bucket, key string) (bool, error)\n\n    // GetMetadata retrieves object metadata without downloading content\n    GetMetadata(ctx context.Context, bucket, key string) (*ObjectMetadata, error)\n\n    // SetTTL sets object expiration (seconds from now)\n    // Not all backends support per-object TTL - may use bucket lifecycle policies\n    SetTTL(ctx context.Context, bucket, key string, ttlSeconds int) error\n\n    // CreateBucket creates a bucket if it doesn't exist (idempotent)\n    CreateBucket(ctx context.Context, bucket string) error\n\n    // DeleteBucket deletes a bucket and all its contents\n    // Returns error if bucket doesn't exist or isn't empty (unless force=true)\n    DeleteBucket(ctx context.Context, bucket string) error\n\n    // BucketExists checks if a bucket exists\n    BucketExists(ctx context.Context, bucket string) (bool, error)\n}\n\n// ObjectMetadata contains object metadata without the content\ntype ObjectMetadata struct {\n    // Size in bytes\n    Size int64\n\n    // Content type (MIME)\n    ContentType string\n\n    // Last modification time\n    LastModified time.Time\n\n    // ETag (typically MD5 hash)\n    ETag string\n\n    // Content encoding (e.g., \"gzip\")\n    ContentEncoding string\n\n    // Custom metadata (headers starting with x-amz-meta-, x-goog-meta-, etc.)\n    UserMetadata map[string]string\n\n    // Expiration time (if set via TTL)\n    ExpiresAt *time.Time\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"design-principles",children:"Design Principles"}),"\n",(0,i.jsx)(n.h4,{id:"1-minimal-surface-area",children:"1. Minimal Surface Area"}),"\n",(0,i.jsx)(n.p,{children:"Only operations needed for claim check - no listing, versioning, ACLs, etc."}),"\n",(0,i.jsx)(n.h4,{id:"2-bucket-scoped",children:"2. Bucket-Scoped"}),"\n",(0,i.jsx)(n.p,{children:"All operations require explicit bucket parameter - no default bucket magic."}),"\n",(0,i.jsx)(n.h4,{id:"3-streaming-support",children:"3. Streaming Support"}),"\n",(0,i.jsxs)(n.p,{children:["Large payload operations use ",(0,i.jsx)(n.code,{children:"io.Reader"}),"/",(0,i.jsx)(n.code,{children:"io.ReadCloser"})," to avoid loading entire object into memory."]}),"\n",(0,i.jsx)(n.h4,{id:"4-idempotent-deletes",children:"4. Idempotent Deletes"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Delete()"})," returns nil if object doesn't exist - simplifies cleanup logic."]}),"\n",(0,i.jsx)(n.h4,{id:"5-metadata-separation",children:"5. Metadata Separation"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"GetMetadata()"})," allows checking object properties without downloading (useful for size/checksum validation)."]}),"\n",(0,i.jsx)(n.h4,{id:"6-ttl-abstraction",children:"6. TTL Abstraction"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"SetTTL()"})," abstracts per-object expiration vs bucket lifecycle policies."]}),"\n",(0,i.jsx)(n.h3,{id:"implementation-strategy",children:"Implementation Strategy"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// pkg/drivers/minio/driver.go (example)\ntype MinioDriver struct {\n    client *minio.Client\n    config MinioConfig\n\n    // Lifecycle policy cache (avoid repeated bucket policy queries)\n    lifecycleMu sync.RWMutex\n    lifecycles  map[string]*LifecyclePolicy\n}\n\nfunc (d *MinioDriver) Put(ctx context.Context, bucket, key string, data []byte) error {\n    _, err := d.client.PutObject(ctx, bucket, key,\n        bytes.NewReader(data), int64(len(data)),\n        minio.PutObjectOptions{\n            ContentType: "application/octet-stream",\n        })\n    return err\n}\n\nfunc (d *MinioDriver) PutStream(ctx context.Context, bucket, key string, reader io.Reader, size int64) error {\n    _, err := d.client.PutObject(ctx, bucket, key, reader, size,\n        minio.PutObjectOptions{\n            ContentType: "application/octet-stream",\n        })\n    return err\n}\n\nfunc (d *MinioDriver) Get(ctx context.Context, bucket, key string) ([]byte, error) {\n    obj, err := d.client.GetObject(ctx, bucket, key, minio.GetObjectOptions{})\n    if err != nil {\n        return nil, err\n    }\n    defer obj.Close()\n\n    return io.ReadAll(obj)\n}\n\nfunc (d *MinioDriver) GetStream(ctx context.Context, bucket, key string) (io.ReadCloser, error) {\n    obj, err := d.client.GetObject(ctx, bucket, key, minio.GetObjectOptions{})\n    if err != nil {\n        return nil, err\n    }\n\n    // Caller must close\n    return obj, nil\n}\n\nfunc (d *MinioDriver) Delete(ctx context.Context, bucket, key string) error {\n    err := d.client.RemoveObject(ctx, bucket, key, minio.RemoveObjectOptions{})\n\n    // MinIO returns error if object doesn\'t exist - make it idempotent\n    if minio.ToErrorResponse(err).Code == "NoSuchKey" {\n        return nil\n    }\n\n    return err\n}\n\nfunc (d *MinioDriver) Exists(ctx context.Context, bucket, key string) (bool, error) {\n    _, err := d.client.StatObject(ctx, bucket, key, minio.StatObjectOptions{})\n    if err != nil {\n        if minio.ToErrorResponse(err).Code == "NoSuchKey" {\n            return false, nil\n        }\n        return false, err\n    }\n    return true, nil\n}\n\nfunc (d *MinioDriver) GetMetadata(ctx context.Context, bucket, key string) (*ObjectMetadata, error) {\n    stat, err := d.client.StatObject(ctx, bucket, key, minio.StatObjectOptions{})\n    if err != nil {\n        return nil, err\n    }\n\n    return &ObjectMetadata{\n        Size:            stat.Size,\n        ContentType:     stat.ContentType,\n        LastModified:    stat.LastModified,\n        ETag:            stat.ETag,\n        ContentEncoding: stat.Metadata.Get("Content-Encoding"),\n        UserMetadata:    extractUserMetadata(stat.Metadata),\n    }, nil\n}\n\nfunc (d *MinioDriver) SetTTL(ctx context.Context, bucket, key string, ttlSeconds int) error {\n    // MinIO doesn\'t support per-object TTL - use bucket lifecycle policies\n    // This is a common limitation of S3-compatible stores\n\n    d.lifecycleMu.Lock()\n    defer d.lifecycleMu.Unlock()\n\n    // Check if bucket already has lifecycle policy for this TTL\n    policy, exists := d.lifecycles[bucket]\n    if exists && policy.HasRule(ttlSeconds) {\n        return nil // Already configured\n    }\n\n    // Create or update lifecycle policy\n    config := lifecycle.NewConfiguration()\n    config.Rules = []lifecycle.Rule{\n        {\n            ID:         fmt.Sprintf("expire-after-%d", ttlSeconds),\n            Status:     "Enabled",\n            Expiration: lifecycle.Expiration{Days: ttlSeconds / 86400},\n        },\n    }\n\n    err := d.client.SetBucketLifecycle(ctx, bucket, config)\n    if err != nil {\n        return err\n    }\n\n    // Cache policy\n    d.lifecycles[bucket] = &LifecyclePolicy{Rules: config.Rules}\n\n    return nil\n}\n\nfunc (d *MinioDriver) CreateBucket(ctx context.Context, bucket string) error {\n    exists, err := d.client.BucketExists(ctx, bucket)\n    if err != nil {\n        return err\n    }\n    if exists {\n        return nil // Idempotent\n    }\n\n    return d.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{\n        Region: d.config.Region,\n    })\n}\n\nfunc (d *MinioDriver) DeleteBucket(ctx context.Context, bucket string) error {\n    // Remove all objects first\n    objectsCh := d.client.ListObjects(ctx, bucket, minio.ListObjectsOptions{\n        Recursive: true,\n    })\n\n    for object := range objectsCh {\n        if object.Err != nil {\n            return object.Err\n        }\n        if err := d.client.RemoveObject(ctx, bucket, object.Key, minio.RemoveObjectOptions{}); err != nil {\n            return err\n        }\n    }\n\n    // Remove bucket\n    err := d.client.RemoveBucket(ctx, bucket)\n    if err != nil && minio.ToErrorResponse(err).Code == "NoSuchBucket" {\n        return nil // Idempotent\n    }\n\n    return err\n}\n\nfunc (d *MinioDriver) BucketExists(ctx context.Context, bucket string) (bool, error) {\n    return d.client.BucketExists(ctx, bucket)\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,i.jsx)(n.h3,{id:"positive",children:"Positive"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Backend Portability"}),": Same interface works with S3, GCS, Azure Blob, MinIO"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Testable"}),": Easy to mock or use in-memory implementation for unit tests"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Streaming Support"}),": Efficient for multi-GB payloads"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Minimal Dependencies"}),": Small interface surface = fewer breaking changes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consistent"}),": Follows existing plugin interface patterns"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Metadata Access"}),": Can validate size/checksum before downloading"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"negative",children:"Negative"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Limited Scope"}),": Doesn't support advanced features (versioning, multipart, ACLs)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"TTL Abstraction"}),": Per-object TTL on backends that only support bucket policies requires workarounds"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Semantics"}),": Different backends return different error types - need careful handling"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"No Pagination"}),": List operations not included (not needed for claim check)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"neutral",children:"Neutral"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"No Multipart Upload"}),": Would add complexity - revisit if needed for >5GB payloads"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"No Presigned URLs"}),": Could enable direct client-to-S3 transfers - future enhancement"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"No Server-Side Encryption"}),": Handled by backend configuration, not interface"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"implementation-phases",children:"Implementation Phases"}),"\n",(0,i.jsx)(n.h3,{id:"phase-1-interface-definition-1-day",children:"Phase 1: Interface Definition (1 day)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Define ",(0,i.jsx)(n.code,{children:"ObjectStoreInterface"})," in ",(0,i.jsx)(n.code,{children:"pkg/plugin/interfaces.go"})]}),"\n",(0,i.jsxs)(n.li,{children:["Define ",(0,i.jsx)(n.code,{children:"ObjectMetadata"})," type"]}),"\n",(0,i.jsxs)(n.li,{children:["Add ",(0,i.jsx)(n.code,{children:"PatternObjectStore"})," constant to framework"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"phase-2-minio-driver-3-days",children:"Phase 2: MinIO Driver (3 days)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"pkg/drivers/minio/\n\u251c\u2500\u2500 driver.go          # Main implementation\n\u251c\u2500\u2500 config.go          # Configuration parsing\n\u251c\u2500\u2500 lifecycle.go       # TTL handling via lifecycle policies\n\u251c\u2500\u2500 errors.go          # Error type conversion\n\u2514\u2500\u2500 driver_test.go     # Unit tests\n"})}),"\n",(0,i.jsx)(n.h3,{id:"phase-3-s3-driver-3-days",children:"Phase 3: S3 Driver (3 days)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"pkg/drivers/s3/\n\u251c\u2500\u2500 driver.go          # AWS SDK v2 implementation\n\u251c\u2500\u2500 config.go          # IAM, regions, encryption\n\u251c\u2500\u2500 lifecycle.go       # Native lifecycle API\n\u2514\u2500\u2500 driver_test.go     # Unit tests (requires AWS credentials)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"phase-4-mock-implementation-1-day",children:"Phase 4: Mock Implementation (1 day)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"pkg/drivers/mock/\n\u2514\u2500\u2500 objectstore.go     # In-memory implementation for unit tests\n"})}),"\n",(0,i.jsx)(n.h2,{id:"testing-strategy",children:"Testing Strategy"}),"\n",(0,i.jsx)(n.h3,{id:"unit-tests-no-external-dependencies",children:"Unit Tests (No External Dependencies)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func TestObjectStoreInterface(t *testing.T) {\n    // Use in-memory mock\n    store := mock.NewObjectStore()\n\n    // Test basic operations\n    err := store.CreateBucket(ctx, "test")\n    require.NoError(t, err)\n\n    err = store.Put(ctx, "test", "key1", []byte("data"))\n    require.NoError(t, err)\n\n    data, err := store.Get(ctx, "test", "key1")\n    require.NoError(t, err)\n    assert.Equal(t, []byte("data"), data)\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"integration-tests-minio-via-testcontainers",children:"Integration Tests (MinIO via testcontainers)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func TestMinIODriver(t *testing.T) {\n    driver, cleanup := setupMinIO(t)\n    defer cleanup()\n\n    // Run interface compliance tests\n    runObjectStoreTests(t, driver)\n}\n\nfunc runObjectStoreTests(t *testing.T, store ObjectStoreInterface) {\n    // Shared test suite for all implementations\n    t.Run("Put/Get", func(t *testing.T) { ... })\n    t.Run("Streaming", func(t *testing.T) { ... })\n    t.Run("Metadata", func(t *testing.T) { ... })\n    t.Run("TTL", func(t *testing.T) { ... })\n    t.Run("Delete", func(t *testing.T) { ... })\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"contract-tests-verify-backend-compatibility",children:"Contract Tests (Verify Backend Compatibility)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// tests/interface-suites/objectstore/\nfunc TestObjectStoreContract(t *testing.T) {\n    backends := []struct {\n        name  string\n        setup func(t *testing.T) ObjectStoreInterface\n    }{\n        {"MinIO", setupMinIOBackend},\n        {"S3", setupS3Backend},      // Requires AWS creds\n        {"GCS", setupGCSBackend},    // Requires GCP creds\n        {"Mock", setupMockBackend},\n    }\n\n    for _, backend := range backends {\n        t.Run(backend.name, func(t *testing.T) {\n            store := backend.setup(t)\n            runObjectStoreTests(t, store)\n        })\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsx)(n.h3,{id:"error-types",children:"Error Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// pkg/plugin/errors.go\n\nvar (\n    // ErrObjectNotFound indicates object doesn\'t exist\n    ErrObjectNotFound = errors.New("object not found")\n\n    // ErrBucketNotFound indicates bucket doesn\'t exist\n    ErrBucketNotFound = errors.New("bucket not found")\n\n    // ErrBucketAlreadyExists indicates bucket creation conflict\n    ErrBucketAlreadyExists = errors.New("bucket already exists")\n\n    // ErrAccessDenied indicates permission error\n    ErrAccessDenied = errors.New("access denied")\n\n    // ErrQuotaExceeded indicates storage quota exceeded\n    ErrQuotaExceeded = errors.New("quota exceeded")\n)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"error-translation",children:"Error Translation"}),"\n",(0,i.jsx)(n.p,{children:"Each driver must translate backend-specific errors to standard errors:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func (d *MinioDriver) translateError(err error) error {\n    if err == nil {\n        return nil\n    }\n\n    resp := minio.ToErrorResponse(err)\n    switch resp.Code {\n    case "NoSuchKey":\n        return ErrObjectNotFound\n    case "NoSuchBucket":\n        return ErrBucketNotFound\n    case "BucketAlreadyOwnedByYou", "BucketAlreadyExists":\n        return ErrBucketAlreadyExists\n    case "AccessDenied":\n        return ErrAccessDenied\n    default:\n        return err // Wrap unknown errors\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"1-access-control",children:"1. Access Control"}),"\n",(0,i.jsx)(n.p,{children:"Interface doesn't include ACL operations - manage via backend configuration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"minio:\n  access_key: ${MINIO_ACCESS_KEY}\n  secret_key: ${MINIO_SECRET_KEY}\n\ns3:\n  iam_role: arn:aws:iam::123456789:role/prism-s3-access\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-encryption",children:"2. Encryption"}),"\n",(0,i.jsx)(n.p,{children:"Backend-specific encryption handled via driver configuration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"s3:\n  server_side_encryption: AES256\n  kms_key_id: arn:aws:kms:us-west-2:123456789:key/abc\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-network-security",children:"3. Network Security"}),"\n",(0,i.jsx)(n.p,{children:"TLS configuration per backend:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"minio:\n  use_ssl: true\n  ca_cert: /path/to/ca.pem\n"})}),"\n",(0,i.jsx)(n.h3,{id:"4-audit-logging",children:"4. Audit Logging"}),"\n",(0,i.jsx)(n.p,{children:"All operations logged via driver observability hooks:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func (d *MinioDriver) Put(ctx context.Context, bucket, key string, data []byte) error {\n    start := time.Now()\n    defer func() {\n        slog.Info("object store put",\n            "backend", "minio",\n            "bucket", bucket,\n            "key", key,\n            "size", len(data),\n            "duration", time.Since(start))\n    }()\n\n    // ... implementation\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"1-connection-pooling",children:"1. Connection Pooling"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"type MinioDriver struct {\n    client *minio.Client  // Internally connection-pooled\n\n    // Connection pool tuning\n    maxIdleConns     int\n    maxConnsPerHost  int\n    idleConnTimeout  time.Duration\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-retry-strategy",children:"2. Retry Strategy"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'type Config struct {\n    MaxRetries      int           `json:"max_retries"`\n    RetryBackoff    time.Duration `json:"retry_backoff"`\n    Timeout         time.Duration `json:"timeout"`\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"3-streaming-thresholds",children:"3. Streaming Thresholds"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"const (\n    // Use PutStream for payloads > 10MB\n    StreamingThreshold = 10 * 1024 * 1024\n)\n\nfunc (p *Producer) uploadClaim(ctx context.Context, payload []byte) error {\n    if len(payload) > StreamingThreshold {\n        return p.objectStore.PutStream(ctx, bucket, key,\n            bytes.NewReader(payload), int64(len(payload)))\n    }\n    return p.objectStore.Put(ctx, bucket, key, payload)\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"4-metadata-caching",children:"4. Metadata Caching"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// Cache frequently accessed metadata\ntype MetadataCache struct {\n    cache map[string]*ObjectMetadata\n    ttl   time.Duration\n    mu    sync.RWMutex\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,i.jsx)(n.h3,{id:"1-blob-specific-interfaces",children:"1. Blob-Specific Interfaces"}),"\n",(0,i.jsx)(n.p,{children:"Define separate interfaces per backend (S3Interface, GCSInterface, AzureInterface)."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Rejected"}),": Defeats portability, increases complexity, harder to test."]}),"\n",(0,i.jsx)(n.h3,{id:"2-full-s3-api-coverage",children:"2. Full S3 API Coverage"}),"\n",(0,i.jsx)(n.p,{children:"Implement complete S3 API (versioning, ACLs, multipart, CORS, etc.)."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Rejected"}),": Over-engineering for claim check use case, massive scope."]}),"\n",(0,i.jsx)(n.h3,{id:"3-generic-key-value-interface",children:"3. Generic Key-Value Interface"}),"\n",(0,i.jsx)(n.p,{children:"Treat object storage as key-value store (like KeyValueBasicInterface)."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Rejected"}),": Misses object-specific concepts (metadata, streaming, buckets)."]}),"\n",(0,i.jsx)(n.h3,{id:"4-pre-signed-url-generation",children:"4. Pre-signed URL Generation"}),"\n",(0,i.jsxs)(n.p,{children:["Add ",(0,i.jsx)(n.code,{children:"GetPresignedURL()"})," for direct client uploads."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Deferred"}),": Useful feature but not needed for MVP. Add in future RFC."]}),"\n",(0,i.jsx)(n.h2,{id:"open-questions",children:"Open Questions"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Multipart Upload"}),": Do we need multipart upload for >5GB payloads? (Deferred)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Copy Operation"}),": Should we support server-side copy? (Deferred)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Range Reads"}),": Do we need partial object reads? (Deferred)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Checksums"}),": Should we calculate and store checksums automatically? (Yes, in producer)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compression"}),": Should object store handle compression or claim check layer? (Claim check layer)"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://docs.aws.amazon.com/AmazonS3/latest/API/Welcome.html",children:"AWS S3 API Reference"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://min.io/docs/minio/linux/developers/go/API.html",children:"MinIO Go SDK"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://cloud.google.com/storage/docs/reference/libraries",children:"GCS Client Library"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/azure/storage/blobs/storage-quickstart-blobs-go",children:"Azure Blob Storage SDK"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.enterpriseintegrationpatterns.com/patterns/messaging/StoreInLibrary.html",children:"Enterprise Integration Patterns: Claim Check"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"related-documents",children:"Related Documents"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"RFC-033: Claim Check Pattern for Large Payloads"}),"\n",(0,i.jsx)(n.li,{children:"ADR-051: MinIO for Claim Check Testing"}),"\n",(0,i.jsx)(n.li,{children:"ADR-053: Claim Check TTL and Garbage Collection (to be created)"}),"\n",(0,i.jsx)(n.li,{children:"RFC-008: Proxy-Plugin Architecture"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);