"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[32],{5005:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"rust-error-handling-strategy","title":"ADR-018: Rust Error Handling Strategy","description":"Context","source":"@site/../docs-cms/adr/018-rust-error-handling-strategy.md","sourceDirName":".","slug":"/rust-error-handling-strategy","permalink":"/prism-data-layer/adr/rust-error-handling-strategy","draft":false,"unlisted":false,"editUrl":"https://github.com/jrepp/prism-data-layer/tree/main/docs-cms/../docs-cms/adr/018-rust-error-handling-strategy.md","tags":[{"inline":true,"label":"rust","permalink":"/prism-data-layer/adr/tags/rust"},{"inline":true,"label":"error-handling","permalink":"/prism-data-layer/adr/tags/error-handling"},{"inline":true,"label":"reliability","permalink":"/prism-data-layer/adr/tags/reliability"},{"inline":true,"label":"observability","permalink":"/prism-data-layer/adr/tags/observability"}],"version":"current","sidebarPosition":18,"frontMatter":{"title":"ADR-018: Rust Error Handling Strategy","status":"Accepted","date":"2025-10-07T00:00:00.000Z","deciders":"Core Team","tags":["rust","error-handling","reliability","observability"]},"sidebar":"adrSidebar","previous":{"title":"ADR-017: Go Structured Logging with slog","permalink":"/prism-data-layer/adr/go-structured-logging"},"next":{"title":"ADR-019: Rust Async Concurrency Patterns","permalink":"/prism-data-layer/adr/rust-async-concurrency-patterns"}}');var s=n(4848),i=n(8453);const o={title:"ADR-018: Rust Error Handling Strategy",status:"Accepted",date:new Date("2025-10-07T00:00:00.000Z"),deciders:"Core Team",tags:["rust","error-handling","reliability","observability"]},l=void 0,a={},d=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Why thiserror + anyhow",id:"why-thiserror--anyhow",level:3},{value:"Error Conversion Pattern",id:"error-conversion-pattern",level:3},{value:"Alternatives Considered",id:"alternatives-considered",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"Implementation Notes",id:"implementation-notes",level:2},{value:"Module Structure",id:"module-structure",level:3},{value:"Top-Level Error Types",id:"top-level-error-types",level:3},{value:"Handler Pattern",id:"handler-pattern",level:3},{value:"Backend Error Definition",id:"backend-error-definition",level:3},{value:"Testing Error Conditions",id:"testing-error-conditions",level:3},{value:"Error Logging",id:"error-logging",level:3},{value:"References",id:"references",level:2},{value:"Revision History",id:"revision-history",level:2}];function c(e){const r={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.h2,{id:"context",children:"Context"}),"\n",(0,s.jsx)(r.p,{children:"Rust proxy implementation requires consistent error handling that:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Preserves error context through call chains"}),"\n",(0,s.jsx)(r.li,{children:"Enables debugging without verbose logging"}),"\n",(0,s.jsx)(r.li,{children:"Leverages Rust's type system for compile-time safety"}),"\n",(0,s.jsx)(r.li,{children:"Integrates with async/await"}),"\n",(0,s.jsx)(r.li,{children:"Provides structured error information for observability"}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"decision",children:"Decision"}),"\n",(0,s.jsxs)(r.p,{children:["Adopt modern Rust error handling with ",(0,s.jsx)(r.code,{children:"thiserror"})," and ",(0,s.jsx)(r.code,{children:"anyhow"}),":"]}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsxs)(r.strong,{children:["Use ",(0,s.jsx)(r.code,{children:"thiserror"})," for library code"]})," (typed errors with context)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsxs)(r.strong,{children:["Use ",(0,s.jsx)(r.code,{children:"anyhow"})," for application code"]})," (error propagation with context)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsxs)(r.strong,{children:["Implement ",(0,s.jsx)(r.code,{children:"From"})," traits"]})," for error conversion"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsxs)(r.strong,{children:["Use ",(0,s.jsx)(r.code,{children:"?"})," operator"]})," for error propagation"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsxs)(r.strong,{children:["Add context with ",(0,s.jsx)(r.code,{children:".context()"})]})," at each layer"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Define domain-specific error types"})," per module"]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"rationale",children:"Rationale"}),"\n",(0,s.jsx)(r.h3,{id:"why-thiserror--anyhow",children:"Why thiserror + anyhow"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"thiserror"})," for library/domain errors:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum BackendError {\n    #[error("backend unavailable: {0}")]\n    Unavailable(String),\n\n    #[error("namespace not found: {namespace}")]\n    NamespaceNotFound { namespace: String },\n\n    #[error("invalid configuration: {0}")]\n    InvalidConfig(String),\n\n    #[error("database error: {0}")]\n    Database(#[from] sqlx::Error),\n}\n'})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"anyhow"})," for application/handler errors:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use anyhow::{Context, Result};\n\nasync fn handle_put_request(req: PutRequest) -> Result<PutResponse> {\n    let backend = get_backend(&req.namespace)\n        .await\n        .context(format!("failed to get backend for namespace: {}", req.namespace))?;\n\n    backend\n        .put(req.items)\n        .await\n        .context("failed to put items")?;\n\n    Ok(PutResponse { success: true })\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Benefits:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Compile-time error type checking (thiserror)"}),"\n",(0,s.jsx)(r.li,{children:"Ergonomic error propagation (anyhow)"}),"\n",(0,s.jsx)(r.li,{children:"Rich error context without manual wrapping"}),"\n",(0,s.jsx)(r.li,{children:"Stack traces in debug builds"}),"\n",(0,s.jsx)(r.li,{children:"Structured error information"}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"error-conversion-pattern",children:"Error Conversion Pattern"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'// Domain error type\n#[derive(Error, Debug)]\npub enum KeyValueError {\n    #[error("item not found: {key}")]\n    NotFound { key: String },\n\n    #[error("backend error: {0}")]\n    Backend(#[from] BackendError),\n}\n\n// Automatic conversion via From trait\nimpl From<sqlx::Error> for KeyValueError {\n    fn from(e: sqlx::Error) -> Self {\n        Self::Backend(BackendError::Database(e))\n    }\n}\n\n// Usage\nasync fn get_item(key: &str) -> Result<Item, KeyValueError> {\n    let row = sqlx::query_as("SELECT * FROM items WHERE key = ?")\n        .bind(key)\n        .fetch_one(&pool)\n        .await?;  // Automatic conversion via From\n\n    Ok(row)\n}\n'})}),"\n",(0,s.jsx)(r.h3,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Manual error wrapping"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Pros: No dependencies"}),"\n",(0,s.jsx)(r.li,{children:"Cons: Verbose, error-prone, no stack traces"}),"\n",(0,s.jsx)(r.li,{children:"Rejected: Too much boilerplate"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:(0,s.jsxs)(r.strong,{children:[(0,s.jsx)(r.code,{children:"eyre"})," instead of ",(0,s.jsx)(r.code,{children:"anyhow"})]})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Pros: Customizable reports, similar API"}),"\n",(0,s.jsx)(r.li,{children:"Cons: Smaller ecosystem, less battle-tested"}),"\n",(0,s.jsx)(r.li,{children:"Rejected: anyhow more widely adopted"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:(0,s.jsxs)(r.strong,{children:[(0,s.jsx)(r.code,{children:"snafu"})," instead of ",(0,s.jsx)(r.code,{children:"thiserror"})]})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Pros: Context selectors, different API"}),"\n",(0,s.jsx)(r.li,{children:"Cons: More complex, steeper learning curve"}),"\n",(0,s.jsx)(r.li,{children:"Rejected: thiserror simpler and more idiomatic"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"consequences",children:"Consequences"}),"\n",(0,s.jsx)(r.h3,{id:"positive",children:"Positive"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Type-safe error handling with thiserror"}),"\n",(0,s.jsxs)(r.li,{children:["Ergonomic error propagation with ",(0,s.jsx)(r.code,{children:"?"})," operator"]}),"\n",(0,s.jsx)(r.li,{children:"Rich error context for debugging"}),"\n",(0,s.jsx)(r.li,{children:"Stack traces in development"}),"\n",(0,s.jsx)(r.li,{children:"Structured errors for observability"}),"\n",(0,s.jsx)(r.li,{children:"Compile-time guarantees"}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"negative",children:"Negative"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Two dependencies (but they work together seamlessly)"}),"\n",(0,s.jsx)(r.li,{children:"Must decide when to use thiserror vs anyhow"}),"\n",(0,s.jsx)(r.li,{children:"Error types require upfront design"}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"neutral",children:"Neutral"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Error handling is explicit (Rust's philosophy)"}),"\n",(0,s.jsx)(r.li,{children:"Need to define error types per module"}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,s.jsx)(r.h3,{id:"module-structure",children:"Module Structure"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"proxy/src/\n\u251c\u2500\u2500 error.rs          # Top-level error types\n\u251c\u2500\u2500 backend/\n\u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u2514\u2500\u2500 error.rs      # Backend-specific errors\n\u251c\u2500\u2500 keyvalue/\n\u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u2514\u2500\u2500 error.rs      # KeyValue-specific errors\n\u2514\u2500\u2500 main.rs\n"})}),"\n",(0,s.jsx)(r.h3,{id:"top-level-error-types",children:"Top-Level Error Types"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'// proxy/src/error.rs\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum ProxyError {\n    #[error("configuration error: {0}")]\n    Config(String),\n\n    #[error("backend error: {0}")]\n    Backend(#[from] crate::backend::BackendError),\n\n    #[error("keyvalue error: {0}")]\n    KeyValue(#[from] crate::keyvalue::KeyValueError),\n\n    #[error("gRPC error: {0}")]\n    Grpc(#[from] tonic::Status),\n}\n\n// Convert to gRPC Status for responses\nimpl From<ProxyError> for tonic::Status {\n    fn from(e: ProxyError) -> Self {\n        match e {\n            ProxyError::Backend(BackendError::NamespaceNotFound { .. }) =>\n                tonic::Status::not_found(e.to_string()),\n            ProxyError::Config(_) =>\n                tonic::Status::invalid_argument(e.to_string()),\n            _ =>\n                tonic::Status::internal(e.to_string()),\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(r.h3,{id:"handler-pattern",children:"Handler Pattern"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use anyhow::{Context, Result};\nuse tonic::{Request, Response, Status};\n\n#[tonic::async_trait]\nimpl KeyValueService for KeyValueHandler {\n    async fn put(\n        &self,\n        request: Request<PutRequest>,\n    ) -> Result<Response<PutResponse>, Status> {\n        let req = request.into_inner();\n\n        // Use anyhow::Result internally\n        let result: Result<PutResponse> = async {\n            let backend = self\n                .get_backend(&req.namespace)\n                .await\n                .context(format!("namespace: {}", req.namespace))?;\n\n            backend\n                .put(&req.id, req.items)\n                .await\n                .context("backend put operation")?;\n\n            Ok(PutResponse { success: true })\n        }\n        .await;\n\n        // Convert to gRPC Status\n        match result {\n            Ok(resp) => Ok(Response::new(resp)),\n            Err(e) => {\n                tracing::error!("put request failed: {:?}", e);\n                Err(Status::internal(e.to_string()))\n            }\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(r.h3,{id:"backend-error-definition",children:"Backend Error Definition"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'// proxy/src/backend/error.rs\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum BackendError {\n    #[error("connection failed: {endpoint}")]\n    ConnectionFailed { endpoint: String },\n\n    #[error("timeout after {timeout_ms}ms")]\n    Timeout { timeout_ms: u64 },\n\n    #[error("namespace not found: {namespace}")]\n    NamespaceNotFound { namespace: String },\n\n    #[error("sqlx error: {0}")]\n    Sqlx(#[from] sqlx::Error),\n\n    #[error("io error: {0}")]\n    Io(#[from] std::io::Error),\n}\n'})}),"\n",(0,s.jsx)(r.h3,{id:"testing-error-conditions",children:"Testing Error Conditions"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_get_nonexistent_namespace() {\n        let handler = KeyValueHandler::new();\n        let req = Request::new(GetRequest {\n            namespace: "nonexistent".to_string(),\n            id: "123".to_string(),\n            predicate: None,\n        });\n\n        let result = handler.get(req).await;\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err().code(), tonic::Code::NotFound);\n    }\n\n    #[tokio::test]\n    async fn test_backend_error_conversion() {\n        let backend_err = BackendError::NamespaceNotFound {\n            namespace: "test".to_string(),\n        };\n        let proxy_err: ProxyError = backend_err.into();\n        let status: tonic::Status = proxy_err.into();\n\n        assert_eq!(status.code(), tonic::Code::NotFound);\n    }\n}\n'})}),"\n",(0,s.jsx)(r.h3,{id:"error-logging",children:"Error Logging"}),"\n",(0,s.jsx)(r.p,{children:"Integrate with structured logging:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use tracing::error;\n\nmatch do_operation().await {\n    Ok(result) => result,\n    Err(e) => {\n        error!(\n            error = %e,\n            error_debug = ?e,  // Full debug representation\n            namespace = %namespace,\n            "operation failed"\n        );\n        return Err(e);\n    }\n}\n'})}),"\n",(0,s.jsx)(r.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://docs.rs/thiserror",children:"thiserror documentation"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://docs.rs/anyhow",children:"anyhow documentation"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://doc.rust-lang.org/book/ch09-00-error-handling.html",children:"Rust Error Handling"})}),"\n",(0,s.jsx)(r.li,{children:"ADR-001: Rust for the Proxy"}),"\n",(0,s.jsx)(r.li,{children:"ADR-013: Go Error Handling Strategy (parallel Go patterns)"}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"revision-history",children:"Revision History"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"2025-10-07: Initial draft and acceptance"}),"\n"]})]})}function u(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>o,x:()=>l});var t=n(6540);const s={},i=t.createContext(s);function o(e){const r=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(i.Provider,{value:r},e.children)}}}]);