# Example: PrismPattern with HPA auto-scaling (CPU-based)
# Use case: Producer pattern that scales based on CPU utilization
apiVersion: prism.io/v1alpha1
kind: PrismPattern
metadata:
  name: producer-kafka-events
  namespace: prism-system
spec:
  # Pattern configuration
  pattern: producer
  backend: kafka

  # Container image
  image: ghcr.io/prism/producer-runner:latest

  # Initial replicas (will be managed by HPA)
  replicas: 2

  # Resource requirements
  resources:
    requests:
      cpu: "1000m"
      memory: "2Gi"
    limits:
      cpu: "4000m"
      memory: "8Gi"

  # Service configuration
  service:
    type: ClusterIP
    port: 8080

  # HPA auto-scaling configuration
  autoscaling:
    enabled: true
    scaler: hpa  # Use Kubernetes HPA

    # Replica bounds
    minReplicas: 2
    maxReplicas: 20

    # CPU-based scaling
    targetCPUUtilizationPercentage: 75

    # Memory-based scaling (optional)
    targetMemoryUtilizationPercentage: 80

    # Custom metrics (requires Prometheus adapter)
    metrics:
      - type: Pods
        pods:
          metric:
            name: kafka_messages_produced_per_second
          target:
            type: AverageValue
            averageValue: "5000"

    # Scaling behavior
    behavior:
      scaleDown:
        stabilizationWindowSeconds: 300  # 5 minutes
        policies:
          - type: Percent
            value: 50
            periodSeconds: 60
          - type: Pods
            value: 2
            periodSeconds: 60
      scaleUp:
        stabilizationWindowSeconds: 0  # Scale up immediately
        policies:
          - type: Percent
            value: 100
            periodSeconds: 15
          - type: Pods
            value: 4
            periodSeconds: 15

  # Backend configuration
  backendConfig:
    name: kafka-production
    namespace: prism-system

  # Pattern-specific configuration
  config:
    kafkaBootstrapServers: "kafka.prism-system.svc.cluster.local:9092"
    kafkaTopic: "events"
    batchSize: "1000"
